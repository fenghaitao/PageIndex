{
  "doc_name": "drm.pdf",
  "structure": [
    {
      "title": "Preface",
      "start_index": 1,
      "end_index": 1,
      "node_id": "0000",
      "summary": "Reference manual for Device Modeling Language (DML) version 1.4. Covers an introductory overview, details of the DML compiler, and the full language specification for DML 1.4. Documents available libraries and built-in elements and provides standard templates for common modeling tasks. Appendices include compiler messages, provisional language features, guidance for managing deprecated features, a changelog of differences from DML 1.2 to 1.4, and the formal grammar."
    },
    {
      "title": "Introduction",
      "start_index": 2,
      "end_index": 2,
      "nodes": [
        {
          "title": "Source File Example",
          "start_index": 2,
          "end_index": 4,
          "node_id": "0002",
          "summary": "- Overview: Introduces Device Modeling Language (DML) v1.4 as a domain-specific, object-oriented language for writing device models to run in Simics; the DML compiler (dmlc) translates DML into C source for Simics modules.\n\n- Purpose and scope of a DML model: a single device description that declares its name/metadata, register banks and memory mappings, expected connections to other Simics objects, connections others may make to it and their handlers, and attributes accessible for configuration, inspection, or checkpointing.\n\n- Static, hierarchical object model: DML objects are statically declared and form a nested scope/hierarchy (device \u2192 banks \u2192 registers \u2192 fields, plus groups and subobjects), enabling encapsulation and separate namespaces.\n\n- Example walkthrough: shows a sample device (\"contraption\") with a connect (wakeup) using a signal interface, a bank (config_registers) with registers and fields, methods implementing read/write behavior, and an array of register objects (coefficient[i < 4]) to demonstrate parameterized object arrays and address arithmetic.\n\n- Methods and language features: methods resemble C functions with similar statements and special features such as integer bit-slicing (value[a:b]); methods live in the object hierarchy and can access object state and connections.\n\n- Templates and metaprogramming: DML supports templates for reusable code patterns (e.g., read, write, read_unimpl) allowing generated default behavior and overridable methods; templates are used via the \"is\" clause to instantiate behavior for objects/fields.\n\n- Registers, banks, and fields: banks map registers into address spaces; registers (1\u20138 bytes) represent integer hardware registers with non-overlapping addresses; fields subdivide registers at the bit level and may be individually readable/writable.\n\n- Object types and their roles:\n  - device object: the model root; top-level declarations are its members.\n  - attribute: Simics configuration attribute for configuration, checkpointing, or pseudo-attributes for inspection.\n  - bank: groups registers and maps them into memory spaces.\n  - register: integer storage for memory-mapped I/O.\n  - field: bit-level subdivisions of registers.\n  - group: generic container for logical organization and abstractions.\n  - connect: reference to a Simics configuration object/interface, exposed as a device attribute and typically initialized on configuration or checkpoint restore.\n\n- Additional notes: DML emphasizes language constructs for the specific needs of device modeling (memory mapping, connections, checkpointable state) and provides metaprogramming facilities to reduce code duplication; the document references the Simics Model Builder User\u2019s Guide for introductory material."
        },
        {
          "title": "Object types",
          "start_index": 4,
          "end_index": 5,
          "node_id": "0003",
          "summary": "- Templates for fields: read and write templates generate code to make fields software-readable/writable and provide overridable read/write methods; read_unimpl generates code that logs a warning on software reads.\n- Methods in DML: resemble C functions but support differences such as integer bitslicing (value[a:b]), have access to an object's state and connections, and live in the object hierarchy; methods may be overridden to customize behavior.\n- Object arrays: syntax like coefficient[i < size] instantiates an object template per element; the index parameter i can be used for element-specific logic (e.g., assigning address offsets).\n- Top-level model structure: each DML model defines a single device object; all top-level declarations become members of that device.\n- Attribute objects: create Simics configuration attributes used for device configuration, checkpoint save/restore (serialization), or as pseudo attributes for inspection/debugging.\n- Bank objects: expose sets of registers in an address space and can be mapped into Simics memory spaces.\n- Register objects: model hardware registers (1\u20138 bytes), hold integer values, and partition a bank's address space into non-overlapping elements.\n- Field objects: subdivide registers at the bit level; fields are individually readable/writable and must not overlap.\n- Group objects: generic container objects for organizing registers or creating abstractions; no special restrictions.\n- Connect and interface objects: connect holds a reference to a Simics configuration object (often with an interface declaration specifying the expected Simics interface); initialization typically occurs when the device is configured.\n- Port and implement objects: port defines external connection points (e.g., dev.port.irq); implement declares implementations of Simics interfaces (usually inside a port) and its methods must match the Simics interface functions; a device can implement the same interface multiple times via multiple ports.\n- Event objects: encapsulate Simics events that can be posted on time queues (CPU or clock).\n- Subdevice objects: represent subsystems that can contain their own ports, banks, and attributes.\n- Method declaration semantics: methods may be declared on any object or template, accept multiple input parameters, and may return multiple values (absence of return values indicated by an empty return list); examples include parameterless noop and a div_mod returning quotient and remainder."
        },
        {
          "title": "Methods and Mutable Variables",
          "start_index": 5,
          "end_index": 6,
          "node_id": "0004",
          "summary": "- Object types and relationships:\n  - interface objects declare a Simics interface assumed implemented by a connected object; often just the interface name with an empty body is sufficient.\n  - port objects are connection points for external devices; instantiated ports are named dev.port.name (e.g., dev.port.irq).\n  - implement objects declare an implementation of a Simics interface and are normally placed inside a port (but may also appear at top-level or in a bank); methods inside implement must match the Simics interface functions. A device may implement the same interface multiple times by using multiple ports with implement objects of the same name.\n  - event objects encapsulate Simics events that can be posted on time queues (CPU or clock).\n  - subdevice objects represent subsystems with their own ports, banks, and attributes.\n\n- Methods and mutable variables:\n  - Methods are DML subroutines attachable to any object or template, support multiple input parameters and multiple return values (empty return list replaces void).\n  - Method syntax examples shown (noop with no params/returns; div_mod demonstrating multiple inputs, multiple returns, and local variables).\n  - local variables are stack-allocated and declared with the local keyword.\n  - session and saved variables are other variable kinds that may also be object members and must be initialized with constant expressions.\n    - session variables behave like C static variables and persist for the simulation session but are NOT automatically serialized on checkpoints (developer must serialize/restore them manually).\n    - saved variables behave like session variables but ARE serialized and restored on checkpoint; therefore saved variables must be of serializable types (most built-in non-pointer C types and structs composed solely of serializable types). Pointer types are never serializable.\n  - Basic exception handling: throw raises an exception without data; try { ... } except { ... } catches exceptions. Methods that may let an exception escape must be declared with throws.\n\n- Templates and parameters:\n  - Templates (declared at top-level as template name { body }) define reusable blocks of object statements.\n  - Templates are instantiated into objects or other templates using the is statement (e.g., is templateA; or is (templateB, templateC);), which injects the template bodies into the containing object or template."
        },
        {
          "title": "Templates and Parameters",
          "start_index": 6,
          "end_index": 7,
          "node_id": "0005",
          "summary": "- Variable kinds: describes local (stack-allocated) variables declared with the local keyword (analogous to C\u2019s auto but explicit), and two other kinds\u2014session and saved. Session and saved variables can also be object members and must be initialized only with constant expressions. Session variables persist for the simulation session but are not automatically checkpoint-serialized (model author must serialize/restore them). Saved variables behave like session variables but are serialized/restored during checkpointing. Serializability rules: most built-in non-pointer C types and structs composed solely of serializable types are serializable; pointer types are never serializable.\n\n- Exception handling: methods can raise exceptions with throw and catch them with try { ... } except { ... }. Methods that may allow uncaught exceptions must be declared with throws (example provided).\n\n- Templates: templates are top-level code blocks that can be injected into objects via the is object statement. Examples show single and multiple template instantiation and an idiomatic inline form (object declaration with is (...)). The is statement injects the template body into the containing object/template.\n\n- Parameters: parameters act as expression macros tied to an object or template. They can be declared abstract (param name; \u2014 must be overridden or cause a compile-time error), with an overridable default (param name default expression;), or with an unoverridable definition (param name = expression;). Templates commonly use parameters to require or allow overrideable values for instances.\n\n- Notes on DML tooling: templates are central to DML\u2019s infrastructure and built-in features; the language provides additional mechanisms to manipulate and reference template instances (e.g., templates as types, each-in expressions, in each declarations)."
        }
      ],
      "node_id": "0001",
      "summary": "- Introduces Device Modeling Language (DML), a domain-specific, object-oriented language for writing device models to run in the Simics simulator.  \n- Describes DML\u2019s purpose and key constructs: representing device objects with mutable state, configurable parameters/attributes, methods, subobjects, memory-mapped hardware registers, and checkpointable state.  \n- Explains DML\u2019s static object declaration model and how a complete DML model specifies a single device plus its register banks and memory mappings, expected connections to other devices, incoming connections and message handling, Simics-accessible attributes, and device metadata (name/description).  \n- Notes specialized language features (e.g., templates and metaprogramming) for code reuse and abstraction.  \n- Introduces the DML compiler (dmlc), which translates DML into C source to build Simics modules, and states the document covers DML, standard libraries, and dmlc for version 1.4; references the Simics Model Builder User\u2019s Guide and includes a short source-file example."
    },
    {
      "title": "The DML compiler",
      "start_index": 8,
      "end_index": 8,
      "nodes": [
        {
          "title": "Building dmlc",
          "start_index": 8,
          "end_index": 8,
          "node_id": "0007",
          "summary": "Summary of partial document \u2014 main points covered:\n\n- Purpose: Introduction to the DML compiler (dmlc) which compiles DML source files into C files suitable for building Simics modules.\n- Availability: dmlc and its libraries are included in the Simics Base package.\n- Building dmlc locally: requirements and steps\n  - Requires Simics 6 base package.\n  - Checkout the DML repository into modules/dmlc of your Simics project.\n  - Build with make dmlc; output placed under host/bin/dml (e.g., linux64 or win64).\n  - Build artifacts: host/bin/dml/python (compiler Python module), host/bin/dml/1.4 (standard libraries), host/bin/dml/api (.dml files exposing Simics API).\n  - To use the local dmlc, set DMLC_DIR in config-user.mk to your project host/bin directory.\n- Running dmlc: command-line form and expectations\n  - Usage: dmlc [options] input [output-base]; input is a .dml file containing a device declaration.\n  - If output-base provided, it names generated files.\n- Compiler outputs: primary output is <output-base>.c (plus helper .h and .c files) which can be compiled/linked into a Simics module with gcc.\n- Command-line options: the document begins listing available options (e.g., -h, --help)."
        },
        {
          "title": "Running dmlc",
          "start_index": 8,
          "end_index": 9,
          "node_id": "0008",
          "summary": "Summary of partial document: main points covered\n\n- Purpose and outputs: Describes the DML compiler (dmlc) which compiles a DML source file (normally .dml and containing a device declaration) into a C file (<output-base>.c) and supporting .h/.c helper files that can be compiled/linked into a Simics module.\n\n- Availability: The DML compiler and its libraries are included in the Simics Base package.\n\n- Building dmlc locally: Requirements and steps to build dmlc:\n  - Requires Simics 6 base package.\n  - Check out the DML repository into modules/dmlc of the Simics project.\n  - Build with make dmlc.\n  - Build artifacts are placed in host/bin/dml (host is linux64 or win64) and consist of:\n    - host/bin/dml/python \u2014 the Python module implementing the compiler\n    - host/bin/dml/1.4 \u2014 standard libraries for device compilation\n    - host/bin/dml/api \u2014 .dml files exposing the Simics API\n  - To use the local build, set DMLC_DIR in config-user.mk to $(SIMICS_PROJECT)/$(HOST_TYPE)/bin.\n\n- Running dmlc: Command-line syntax and behavior:\n  - Usage: dmlc [options] input [output-base]\n  - input is a DML source file (typically .dml); output-base (if given) names the produced files.\n  - Main produced file is <output-base>.c for compilation into a Simics module.\n\n- Command-line options: Lists and describes available dmlc options, including:\n  - -h, --help: print usage help.\n  - -I path: add search path for imported modules.\n  - -D name=definition: define a compile-time parameter (literal expression).\n  - --dep: output makefile dependency rules.\n  - -T: show tags on warnings (used with --warn/--nowarn).\n  - -g: generate artifacts for easier source-level debugging (DML debug file, closer C code mapping).\n  - --coverity: add Coverity analysis annotations to suppress common false positives; allows manual suppression via COVERITY pragma; note that this affects line-directive generation and may interfere with other debugging/coverage tools \u2014 recommended only when needed.\n  - --warn=tag / --nowarn=tag: enable or suppress specific warnings (tags from -T).\n  - --werror: treat all warnings as errors.\n  - --strict: report errors for constructs that will be forbidden in future DML versions.\n  - --noline: suppress C preprocessor line directives.\n  - --info: enable output of an XML file describing register layout."
        },
        {
          "title": "Command Line Options",
          "start_index": 9,
          "end_index": 11,
          "node_id": "0009",
          "summary": "Partial excerpt from the Device Modeling Language (DML) 1.4 reference: \n- Command-line/usage options for the dmlc compiler: printing usage and version, adding include/search paths (-I), defining compile-time parameters (-D name=definition), emitting dependency rules (--dep), showing warning tags (-T), enabling debug-friendly output (-g), adding Coverity annotations (--coverity) with caveats, enabling/suppressing warnings (--warn, --nowarn), treating warnings as errors (--werror), strict-mode checks (--strict), suppressing C preprocessor line directives (--noline), emitting register-layout XML (--info), selecting Simics API version (--simics-api), and limiting reported errors (--max-errors).  \n- Introduction and overview of DML 1.4: DML is a domain-specific modeling language for writing Simics device models; it has C-like algorithmic syntax but emphasizes simple object-oriented constructs for static device data and automatic Simics bindings. Key features noted include bit-slicing for bitfields, new/delete memory operators, a basic try/throw error mechanism, built-in log and assert, and metaprogramming facilities (templates and in-each constructs). Much Simics-specific logic is provided in standard library modules rather than the compiler.  \n- Lexical structure and lexical rules: names generally need not be declared before use; source files use UTF-8 with restrictions (non-ASCII only in comments and string literals, certain Unicode BiDi controls disallowed), strings are byte arrays; and an extensive set of reserved words is listed\u2014C/C99/C++ reserved words plus DML-specific reserved identifiers (e.g., after, assert, each, foreach, log, param, sizeoftype, typeof, async/await, stringify, etc.)."
        }
      ],
      "node_id": "0006",
      "summary": "Summary of main points in the partial document:\n\n- Purpose and outputs: The DML compiler (dmlc) translates a DML source file (device declaration) into a C file and supporting helper .c/.h files which can be compiled and linked with gcc into a Simics module.\n\n- Availability: dmlc and its libraries are included in the Simics Base package.\n\n- Building dmlc: Requires an installation of the Simics 6 base package. To build locally, check out the DML repository into modules/dmlc of your Simics project and run make dmlc. The build produces host/bin/dml (e.g., linux64 or win64) containing:\n  - host/bin/dml/python \u2014 the Python module implementing the compiler\n  - host/bin/dml/1.4 \u2014 standard libraries for compiling devices\n  - host/bin/dml/api \u2014 .dml files exposing the Simics API\n  To use the locally built compiler, set DMLC_DIR = $(SIMICS_PROJECT)/$(HOST_TYPE)/bin in config-user.mk.\n\n- Running dmlc: Command-line form is dmlc [options] input [output-base], where input is typically a .dml file containing a device declaration. If output-base is given, the main output is <output-base>.c; the compiler also emits helper .h and .c files referenced by the main output.\n\n- Command-line options: A set of options (including -h/--help) is available to control dmlc invocation."
    },
    {
      "title": "Device Modeling Language, version 1.4",
      "start_index": 11,
      "end_index": 8,
      "nodes": [
        {
          "title": "Overview",
          "start_index": 8,
          "end_index": 12,
          "node_id": "0011",
          "summary": "- Describes the DML compiler (dmlc): its purpose (compiles DML source into a C file that becomes a Simics module) and that it is distributed with the Simics Base package.\n- Instructions for building dmlc locally: checkout the DML repo into modules/dmlc of a Simics project, run make dmlc, and the build artifacts appear under host/bin/dml (e.g., linux64 or win64). The build output contains:\n  - host/bin/dml/python \u2014 the Python compiler implementation\n  - host/bin/dml/1.4 \u2014 standard libraries for compiling devices\n  - host/bin/dml/api \u2014 .dml files exposing the Simics API\n  - How to point a local Simics build at the compiler via DMLC_DIR in config-user.mk.\n- How to run dmlc: command-line syntax dmlc [options] input [output-base]; input is normally a .dml file containing a device declaration; main output is <output-base>.c plus helper .h/.c files for compilation into a Simics module.\n- Command-line options overview and notable flags:\n  - -I to add import search paths; -D to define compile-time parameters; --dep to emit makefile dependency rules.\n  - -T to show warning tags; --warn/--nowarn to enable/suppress specific warnings; --werror to treat warnings as errors; --max-errors to limit errors.\n  - -g to generate debug-friendly artifacts; --coverity to add Coverity annotations (with caveats about line-directive/diagnostic effects).\n  - --strict to enable future-breaking errors; --noline to suppress C line directives; --info to emit XML register layout; --version and --simics-api to control API versioning.\n- Begins DML language reference (version 1.4): an overview that DML is a modeling language targeted at Simics device models, with C-like algorithmic parts but strong static data/object constructs, bit-slicing, new/delete, basic try/throw, log/assert, and metaprogramming (templates, in each).\n- Lexical structure details:\n  - Source encoding: UTF-8; non-ASCII allowed only in comments and string literals; certain Unicode BiDi controls disallowed; strings are byte arrays.\n  - Reserved words: all C reserved words plus many C99/C++ and DML-specific reserved identifiers (list of examples provided), and identifiers starting with underscore are reserved.\n  - Identifiers follow C rules; those beginning with _ are reserved and should be avoided.\n  - Literals: strings, chars, integers (decimal, hex 0x, binary 0b), booleans, floats; underscores allowed inside integer literals for readability; string/char escape sequences described, and escaped bytes restricted for Unicode strings.\n  - Comments: C-style /*...*/ and //...\n- Module system: simple import-based modules (import merges file contents, parsed in isolation, idempotent imports); import hierarchy affects which modules can override declarations\u2014overrides allowed only by files that (directly or indirectly) import the module being overridden.\n- Notes that a DML source file combines device structure and behavioral actions; further language details follow in subsequent sections."
        },
        {
          "title": "Lexical Structure",
          "start_index": 12,
          "end_index": 11,
          "node_id": "0012",
          "summary": "The partial document is blank and contains no content or identifiable main points."
        },
        {
          "title": "Module System",
          "start_index": 11,
          "end_index": 12,
          "node_id": "0013",
          "summary": "Partial document describes Device Modeling Language (DML) version 1.4 and covers these main points:\n\n- Purpose and overview\n  - DML is a modeling language for writing Simics device models (not a general-purpose language).\n  - Syntax for algorithmic parts is C-like, but strength lies in simple object-oriented constructs for defining static device data and automatic bindings to Simics.\n  - Language features: bit-slicing for bit-field manipulation, new/delete for memory management, a basic try/throw error mechanism, built-in log and assert, and metaprogramming via templates and in each statements.\n  - Much Simics-specific functionality lives in standard library modules imported by DML; the compiler itself keeps Simics-specific knowledge minimal.\n\n- Lexical structure and naming\n  - Names generally need not be defined before first use (unlike C).\n  - Source files are UTF-8; non-ASCII allowed only in comments and string literals. Certain Unicode BiDi control characters forbidden.\n  - String values are treated as byte arrays (literal character count may differ from byte count).\n\n- Reserved words and identifiers\n  - All C reserved words are reserved; additional C99/C++ words and many DML-specific reserved words are listed (e.g., new, delete, try, throw, template, after, assert, call, each, foreach, in, log, param, typeof, async, await, etc.).\n  - Identifiers follow C rules (start with letter or underscore, then letters/digits/underscores); identifiers beginning with underscore are reserved and should be avoided.\n\n- Literals and comments\n  - Literal types: strings, characters, integers, booleans, floating-point.\n  - Integer literals: decimal, hex (0x...), binary (0b...); underscores allowed for digit grouping (with placement restrictions).\n  - String escape sequences supported (\\n, \\r, \\t, \\b, \\\", \\\\, \\xHH with 00-7F restriction when Unicode present).\n  - Character literals are single printable ASCII or escape sequences; evaluate to ASCII value.\n  - C-style comments supported: /*...*/ and //...\n\n- Module system\n  - Simple module/import model: any source file may be imported with import; imported files are merged into the main model (with some exceptions) but must be parseable in isolation.\n  - Imported files may contain file-local declarations (e.g., bitorder) and imports are idempotent.\n  - Import hierarchy affects semantics: only modules that (directly or indirectly) import a module may override declarations from that module; importing unrelated files without the proper import path can cause errors.\n\n- Source file structure\n  - A DML source file describes both the device structure and actions performed on device access (section intro present)."
        },
        {
          "title": "Source File Structure",
          "start_index": 12,
          "end_index": 13,
          "nodes": [
            {
              "title": "Language Version Declaration",
              "start_index": 13,
              "end_index": 13,
              "node_id": "0015",
              "summary": "- Describes the required layout of a DML source file: must begin with a language version declaration and (for a model file) a device declaration; after those, any number of parameter declarations, methods, data fields, object declarations, or global declarations may follow. Imported DML files follow the same layout but do not contain a device declaration.\n- Section 3.4.1 (Language Version Declaration): mandates a version line like \"dml 1.4;\"; explains that the compiler (dmlc) uses it to choose parser and standard libraries; files may not import files with a different language version; the version declaration must be the first declaration aside from comments; example shown.\n- Section 3.4.2 (Device Declaration): explains that a file with a device declaration defines a Simics device class and is a DML model; only the initial/top-level file may contain a device declaration; the device declaration must be the first proper declaration after comments and the version line; example shown.\n- Section 3.5 (Pragmas): introduces pragma syntax /*% tag ... %*/; explains that tags determine pragma syntax, are case-insensitive (conventionally uppercase), and that dmlc warns on unrecognized tags; notes pragmas can appear where inline comments are allowed but their meaning depends on placement; the list of supported pragmas is referenced but not included in the partial text."
            },
            {
              "title": "Device Declaration",
              "start_index": 13,
              "end_index": 13,
              "node_id": "0016",
              "summary": "Summary of main points in the partial document:\n\n- DML file structure: A device-defining DML source file must begin with a language version declaration followed by a device declaration; after these, any number of parameter declarations, methods, data fields, object declarations, or global declarations may follow. Files intended for import follow the same layout but do not include a device declaration.\n\n- Language version declaration (3.4.1): Must appear first (aside from comments) in the form \"dml 1.4;\". The declared version selects the parser and standard libraries; files cannot import other files with a different language version.\n\n- Device declaration (3.4.2): A file with a device declaration is a DML model that defines a Simics device class with the given name. Only the initial/top-level file may contain a device declaration, and it must be the first proper declaration after the version and optional comments.\n\n- Pragmas (3.5): Pragmas use the syntax \"/*% tag ... %*/\", where the tag (case-insensitive, conventionally uppercase) determines the pragma syntax. Pragmas can appear wherever inline comments are allowed, their meaning depends on placement, unrecognized tags generate a compiler warning, and the compiler supports a set of specific pragmas."
            }
          ],
          "node_id": "0014",
          "summary": "- Identifiers: syntax follows C (start with letter or underscore, then letters/digits/underscores); identifiers beginning with underscore are reserved for DML and the standard library.\n\n- Constant literals: supported types are strings, characters, integers, booleans, and floating-point numbers. Integer literals can be decimal, hexadecimal (0x...), or binary (0b...), and may include underscores for digit grouping (with placement restrictions). String literals use double quotes with standard backslash escapes (\\\", \\\\, \\n, \\r, \\t, \\b) and \\xHH for arbitrary byte values (restricted for strings with Unicode above U+007F). Character literals use single quotes and represent printable ASCII or escapes; their value is the ASCII code.\n\n- Comments: C-style comments are supported, both block (/*...*/) and line (//...).\n\n- Module system: modules are importable source files (no device declaration) that are merged into the main model but must be parseable in isolation. Imports are idempotent (no duplicate definitions), may contain file-local declarations (e.g., bitorder), and import hierarchy controls which files may override methods or parameters\u2014overrides are only allowed from files that explicitly (directly or indirectly) import the module.\n\n- Source file structure: a device-defining DML file must begin with a language version declaration (e.g., dml 1.4;) followed by a device declaration; only the initial file may contain a device declaration. Imported files follow the same layout except they omit the device declaration. A file cannot import another file with a different language version.\n\n- Language version declaration: must be the first declaration (aside from comments) to allow the compiler to select parsers and standard libraries.\n\n- Device declaration: must be the first proper declaration after the version and comments; files with a device declaration define a Simics device class of the given name.\n\n- Pragmas: special compiler directives embedded in comments using the form /*% TAG ... %*/; tags are case-insensitive (conventionally uppercase). Pragmas are orthogonal to DML semantics, their meaning depends on placement, unrecognized tags produce compiler warnings, and misuse can render them meaningless."
        },
        {
          "title": "Pragmas",
          "start_index": 13,
          "end_index": 13,
          "nodes": [
            {
              "title": "COVERITY pragma",
              "start_index": 14,
              "end_index": 14,
              "node_id": "0018",
              "summary": "- COVERITY pragma in DML\n  - Provides a way to manually suppress or classify defects reported by Synopsys Coverity for a specific DML line when the --coverity option is passed to DMLC.\n  - Syntax: /*% COVERITY event [classification] %*/ and it maps to a C annotation /* coverity[event : classification] */ or /* coverity[event] */ if classification is omitted.\n  - Pragmas apply to every generated C line corresponding to the DML line and are cumulative for consecutive COVERITY pragma lines; an empty line breaks the sequence.\n  - Example: multiple COVERITY pragmas preceding a function call produce multiple annotations for that call, and a pragma with FALSE can mark a defect as a false positive.\n\n- The DML object model\n  - A DML model represents a single device object containing nested member objects; nesting can be arbitrarily deep.\n  - Objects can have methods (behavior) and parameters (static properties); members, methods and parameters can be added or overridden locally, effectively creating a one-off local subtype.\n  - Object types are fixed (e.g., bank, register); user-defined object types are not supported.\n  - Models are instantiated atomically as a whole (no standalone object instantiation), allowing siblings and any method to assume and access the full object hierarchy state."
            }
          ],
          "node_id": "0017",
          "summary": "- Overall structure: a DML source file begins with a language version declaration, optionally followed by a device declaration; after that it may contain any number of parameter declarations, methods, data fields, object declarations, or global declarations. Files intended to be imported follow the same layout but must not contain a device declaration.\n\n- Language version declaration: must appear as the first declaration (comments allowed before it), e.g. \"dml 1.4;\". The dmlc compiler uses this to select the correct parser and standard libraries; a file may not import another file with a different language version.\n\n- Device declaration: a file that contains a device declaration defines a Simics device class and is considered a DML model. Only the initial/top-level file may contain a device declaration, and it must be the first proper declaration after the version declaration and comments.\n\n- Pragmas: DML supports compiler directives written as /*% tag ... %*/. The tag (conventionally capitalized but case-insensitive) selects the pragma and the syntax of its contents. Pragmas are not part of DML semantics (and should not affect semantics), their meaning depends on placement, and misplacement can render them meaningless. The compiler warns on unrecognized pragma tags."
        },
        {
          "title": "The Object Model",
          "start_index": 14,
          "end_index": 15,
          "nodes": [
            {
              "title": "Device Structure",
              "start_index": 15,
              "end_index": 15,
              "node_id": "0020",
              "summary": "Summary of main points covered:\n\n- Templates: described as a unit of instantiation in DML \u2014 reusable blocks of code that are expanded into objects when instantiated.\n- Mapping to Simics: many DML object-model elements are automatically mapped to Simics configuration objects; notably a DML device maps to a Simics configuration class, and DML attributes and interfaces map to Simics attributes and interfaces (see Simics Model Builder User\u2019s Guide for details).\n- Device structure and containment rules: a device is composed of member objects and methods and may contain nested objects. The document enumerates which object types are valid only in specific contexts:\n  - Exactly one device object exists at the top level.\n  - bank, port, subdevice: only inside a device or subdevice.\n  - implement: only inside a device, port, bank, or subdevice.\n  - register: only inside a bank.\n  - field: only inside a register.\n  - connect: only inside a device, subdevice, bank, or port.\n  - interface: only directly under a connect.\n  - attribute: only inside device, bank, port, subdevice, or implement.\n  - event: allowed almost everywhere except as part of a field, interface, implement, or another event.\n  - group: neutral container \u2014 any object may contain a group, and a group may contain any object its parent could contain, except it cannot contain interface or implement objects.\n- Parameters (param): treated like compile-time expressions similar to macros:\n  - Parameter references are expanded to their definition during compilation and re-evaluated on each use.\n  - No type declarations required; definitions must be syntactically valid expressions.\n  - Unfolded parameter expressions are evaluated in the scope where the parameter was defined (not where referenced).\n  - Parameters cannot be updated at run-time, though they can be declared to allow later overriding (see Parameter Declarations)."
            },
            {
              "title": "Parameters",
              "start_index": 15,
              "end_index": 22,
              "node_id": "0021",
              "summary": "- Templates and instantiation: DML templates are reusable code blocks that can be instantiated in objects to provide common behaviors (e.g., read/write, read_only, unimpl, init). Templates control method implementations and checkpointing behavior.\n\n- Mapping to Simics: Most DML object types map automatically to Simics configuration classes/attributes/interfaces. A DML device becomes a Simics configuration class; DML attributes, registers, connects, and interfaces become Simics attributes/interfaces.\n\n- Device structure and containment rules: exactly one top-level device object; strict rules about where object types may appear (e.g., bank, port, subdevice only inside device/subdevice; register only in a bank; field only in a register; interface only under connect; group objects are neutral but cannot contain interface/implement).\n\n- Parameters (param): behave like compile-time expressions/macros (no type required), evaluated in definition scope, can be overridden but are not dynamic at runtime. Commonly used for static properties (names, sizes, offsets, byte_order).\n\n- Methods: DML methods implement object functionality, may have multiple inputs and returns, and support basic exception handling (throw/try). Detailed syntax covered elsewhere.\n\n- Device declaration: DML file must start with a single device declaration (e.g., \"dml 1.4; device name;\") which names the Simics configuration class and marks the top-level file.\n\n- Register banks: banks group registers and expose them via Simics io_memory and register_view interfaces. Bank arrays are supported (each element is a separate Simics object) and Simics names use .bank prefix (e.g., dev.bank.regs[0]).\n\n- Registers:\n  - Represent integer storage (1\u20138 bytes), must belong to a bank; size set by size param or shorthand, default from bank.register_size.\n  - Mapping: offset parameter or shorthand (@) maps registers into bank address space; byte_order controls endianness mapping.\n  - Unmapped registers: allowed (offset = unmapped_offset or using unmapped template); useful for internal state but Saved Variables are generally preferred for simple state and checkpointing.\n  - Value storage: register value in member val; get/set methods and val used for access; checkpointing follows get/set implementations.\n\n- Register fields: registers may contain fields defined as bit ranges; field values are stored in register bits; access via get/set methods. Bit numbering: most significant bit listed first in range irrespective of endian bitorder. Instantiation of templates on a register can override field-level behavior.\n\n- Register-related templates: three categories \u2014 simple read/write that just update values, abstract read/write templates to supply custom behavior (read_field/write_field variants provide extra access info), and specialized templates (unimpl, read_only, etc.).\n\n- Attributes: explicit DML attributes expose Simics configuration attributes for user configuration, checkpointing, or pseudo back-doors. Attributes are get/set pairs, typed via type param. Four standard templates (bool_attr, int64_attr, uint64_attr, double_attr) store a val session variable and provide init()/init_val for initialization. Prefer Saved Variables over attributes for simple internal state.\n\n- Connects and interfaces:\n  - A connect holds a reference to another Simics conf object and creates a corresponding Simics attribute; the pointer is stored in .obj.\n  - Interfaces declared inside a connect describe expected Simics interfaces on the connected object; interface.required (default true) enforces implementation. Interface C type defaults to <name>_interface_t.\n  - Calling interface functions omits the explicit object pointer argument in DML.\n\n- Implements: implement objects define methods that export Simics interfaces from the device. The implement name maps to a Simics interface type (name + \"_interface_t\"); method signatures must match the corresponding C function pointers. Commonly placed under ports.\n\n- Events: event objects represent schedulable Simics events with a built-in post() and an abstract event() callback. Events must instantiate one of pre-defined templates (time vs cycle and simple/uint64/custom variants). Custom events require extra methods (get_event_info, set_event_info, destroy) to support checkpointing; posted events may carry template-dependent data."
            },
            {
              "title": "Methods",
              "start_index": 22,
              "end_index": 15,
              "node_id": "0022",
              "summary": "The partial document is empty or missing; no content is provided, so no main points can be identified."
            },
            {
              "title": "The Device",
              "start_index": 15,
              "end_index": 16,
              "node_id": "0023",
              "summary": "- Templates: reusable code blocks that can be instantiated into objects (expanded into the object).\n- Mapping to Simics: DML device objects map to Simics configuration classes; DML attributes and interfaces map to Simics attributes and interfaces (see Simics Model Builder guide for details).\n- Device structure and containment rules: exactly one top-level device; allowed containment contexts summarized:\n  - bank, port, subdevice only inside device or subdevice\n  - implement only inside device, port, bank, or subdevice\n  - register only inside a bank\n  - field only inside a register\n  - connect only inside device, subdevice, bank, or port\n  - interface only directly below connect\n  - attribute inside device, bank, port, subdevice, or implement\n  - event anywhere except inside field, interface, implement, or another event\n  - group is neutral: any object may contain a group and a group may contain any objects its parent may, except group cannot contain interface or implement\n- Parameters (param): macro-like expression members that are re-evaluated at each use, must be valid expressions, evaluated in the scope where defined, not runtime-updatable (but can be declared overridable); used for static object properties (e.g., bank byte_order).\n- Methods: object members implementing functionality; support multiple input/output values and a basic exception mechanism (throw/try); detailed syntax covered elsewhere.\n- Device declaration: a DML device corresponds to a Simics configuration object and is the top-level scope; the DML file must start with the language/version and a single device declaration (e.g., \"dml 1.4; device name;\"); device declaration appears only once and identifies the top-level DML file and the Simics config class name.\n- Register banks: group registers and expose them externally (io_memory, register_view, register_view_read_only, register_view_catalog, bank_instrumentation_subscribe). Bank arrays model rows of similar banks; each array element is a separate Simics configuration object.\n- Naming convention for banks in Simics: bank instances are accessible as dev.bank.<name>[index], i.e., a .bank prefix on the device instance name.\n- Registers: integer-valued objects that normally map to consecutive locations in a bank\u2019s address space but may be unmapped; all registers must belong to a register bank."
            },
            {
              "title": "Register Banks",
              "start_index": 16,
              "end_index": 16,
              "node_id": "0024",
              "summary": "- Parameters: describe static, overridable object properties (e.g., names, sizes, offsets); example: per-bank byte_order defaults to little-endian but can be overridden per bank.\n- Methods: define object functionality; similar to C functions but allow any number of inputs/returns and include basic exception handling via throw/try; full declaration details are in another section.\n- Device: a DML device maps to a Simics configuration object and is represented by the top-level scope; DML files must begin with a language version and a single device declaration (e.g., \"dml 1.4; device name;\"), which may appear only once and serves to name the Simics configuration class and mark the top-level DML file.\n- Register banks: group registers and expose them to the system via Simics interfaces (io_memory, register_view, register_view_read_only, register_view_catalog, bank_instrumentation_subscribe); support bank arrays (each element is a separate Simics configuration object and individually mappable).\n- Naming convention: Simics names bank instances with a .bank prefix (example: dev.bank.regs[0], dev.bank.regs[1] for a regs[i < 2] declaration on a device instance named dev).\n- Registers: objects holding integer values, typically mapped to consecutive addresses in a bank but can be unmapped; every register must belong to a register bank."
            },
            {
              "title": "Registers",
              "start_index": 16,
              "end_index": 17,
              "nodes": [
                {
                  "title": "Mapping Addresses To Registers",
                  "start_index": 17,
                  "end_index": 18,
                  "node_id": "0026",
                  "summary": "- Register size rules: sizes are integer, nonzero counts of 8\u2011bit bytes; maximum width is 8 bytes. Size is set via the size parameter or the shorthand \"register r size N\". If not given, the bank\u2019s register_size provides a default.\n\n- Accessing and manipulating values: each register stores its value in a member named val (e.g., r1.val) which can be read, logged, or incremented directly. Checkpointing normally saves this value unless get/set are overridden.\n\n- Mapping registers into a bank address space: a register\u2019s starting address is specified by the offset parameter or shorthand \"register r @ 0xADDR\". The occupied address range is offset .. offset+size-1.\n\n- Byte ordering: byte_order controls translation between bank addresses and register value. \"little-endian\" (default) maps the lowest address to the least significant byte; \"big-endian\" maps the lowest address to the most significant byte.\n\n- Unmapped registers: registers can be unmapped (useful for internal-only state) by setting offset to unmapped_offset or using the template \"register r is (unmapped)\". Unmapped registers provide benefits like automatic checkpointing and fields, but Saved Variables are preferred for new designs when possible.\n\n- Configuration attributes: each register produces an integer attribute in the generated Simics configuration class; the attribute name reflects the DML hierarchy (e.g., bank0_r1).\n\n- Checkpoint and customization: register values are automatically checkpointed by default, but checkpoint behavior is governed by get/set methods \u2014 overriding them can change what is saved.\n\n- Fields: a register may contain field objects that represent bit ranges within the register to model sub\u2011fields (status bits, flags, reserved bits, etc.)."
                },
                {
                  "title": "Not Mapping Addresses To Registers",
                  "start_index": 18,
                  "end_index": 18,
                  "node_id": "0027",
                  "summary": "- Syntax for declaring registers and banks in DML, including examples:\n  - register r1 size 4 @ 0x0100;\n  - bank b1 { param register_size = 4; register r1 @ 0x0100; register r2 @ 0x0104; ... }\n\n- How addresses map to register byte positions via the byte_order parameter:\n  - Default \"little-endian\": lowest address \u2192 least significant byte.\n  - \"big-endian\": lowest address \u2192 most significant byte.\n\n- Unmapped registers:\n  - Registers need not be memory-mapped; useful for internal registers that aren\u2019t software-accessible.\n  - Benefits of using register objects (automatic checkpointing, register fields) for internal state.\n  - Prefer Saved Variables for simple device state; use unmapped registers only when saved variables are unsuitable.\n  - How to declare an unmapped register: set offset to unmapped_offset or use template: register r is (unmapped);\n\n- Register attributes and checkpointing:\n  - Each register automatically creates an integer attribute in the Simics configuration class; attribute name reflects DML hierarchy (e.g., bank0_r1).\n  - Register values are automatically saved in checkpoints unless configuration parameter disables it.\n  - The register\u2019s stored value lives in a member named val (e.g., r1.val); checkpointed value is normally this member but can be changed by overriding get/set methods.\n\n- Register fields:\n  - Registers may contain field objects that represent named bit ranges within the register (for expressing status bits, flags, reserved bits, etc.)."
                },
                {
                  "title": "Register Attributes",
                  "start_index": 18,
                  "end_index": 18,
                  "node_id": "0028",
                  "summary": "- Syntax and examples for declaring registers and banks (e.g., register r1 size 4 @ 0x0100; and bank b1 with param register_size = 4 and registers at offsets).\n- How bank address space maps to register values via the byte_order parameter: default \"little-endian\" makes the lowest address the least-significant byte; \"big-endian\" makes it the most-significant byte.\n- Support for unmapped registers: registers need not be mapped to addresses (useful for internal-only registers), how to declare unmapped (offset = unmapped_offset or register r is (unmapped);).\n- Guidance that unmapped registers were historically used for device state but Saved Variables are now recommended; unmapped registers should be used only when saved variables do not fit.\n- Automatically generated register attributes in the Simics configuration class (integer typed, named according to the DML hierarchy, e.g., bank0_r1).\n- Checkpoint behavior: register values are automatically saved in checkpoints (unless the configuration parameter overrides), with the stored value kept in a member named val (e.g., r1.val); get/set method overrides can change what is checkpointed.\n- Register fields: registers can contain field objects representing bit ranges (to model status bits, flags, reserved bits, etc.)."
                },
                {
                  "title": "Fields",
                  "start_index": 18,
                  "end_index": 19,
                  "node_id": "0029",
                  "summary": "This partial document describes how to model registers and attributes in a DML/Simics device model. It explains register and bank declarations (size, offsets), how byte_order (little- vs big-endian) maps bank addresses to register bytes, and how to mark registers as unmapped for internal use (with a recommendation to prefer saved variables when possible). It documents automatically created Simics configuration attributes for registers (naming conventions, storage in a .val member, and checkpoint behavior tied to get/set methods). It covers register fields: defining bit ranges, bit-numbering conventions (MSB listed first in ranges), and accessing field values via get/set. It outlines read/write behavior control via templates (read, write, read_field, write_field), using custom overrides, and common predefined templates such as unimpl and read_only, plus the interaction between register-level templates and field descent. Finally, it begins to introduce explicit attribute objects in DML as a way to expose additional configurable device parameters."
                }
              ],
              "node_id": "0025",
              "summary": "Summary of main points covered in the partial document:\n\n- Parameters: used to describe static properties of objects (names, sizes, offsets); many are overridable by users (example: bank byte_order defaults to little-endian but can be overridden per bank).\n\n- Methods: object members that implement functionality; similar to C functions but can have arbitrary numbers of inputs and return values; basic exception handling with throw and try; detailed syntax described elsewhere.\n\n- Device declaration: the DML model\u2019s device corresponds to a Simics configuration object and is represented by the top-level scope. The DML file must start with a device declaration (e.g., \"dml 1.4; device name;\"). A device declaration can only appear once and serves to name the configuration class and mark the top-level DML file.\n\n- Register banks:\n  - Banks group registers and expose them to the simulated system via Simics interfaces (io_memory, register_view, register_view_read_only, register_view_catalog, bank_instrumentation_subscribe).\n  - Bank arrays model rows of similar banks; each element becomes a separate Simics configuration object that can be individually mapped.\n  - Naming convention: Simics objects for banks use a .bank prefix (e.g., dev.bank.regs[0]).\n\n- Registers:\n  - Registers contain integer values and must belong to a register bank; they can be mapped into the bank\u2019s address space or be unmapped.\n  - Size: fixed, nonzero number of 8-bit bytes, max 8 bytes; specified via size parameter or shorthand (register r1 size 4). Default comes from the containing bank\u2019s register_size parameter.\n  - Access: register values manipulated via the val member (examples shown).\n  - Address mapping: registers are mapped by specifying offset (param offset = 0x0100 or shorthand register r1 @ 0x0100); mapped range is offset to offset + size - 1."
            },
            {
              "title": "Attributes",
              "start_index": 19,
              "end_index": 20,
              "node_id": "0030",
              "summary": "- Registers and fields store values in bits of the containing register; values are accessed via get and set methods.\n- Read/write behavior is controlled by instantiating templates. Three broad kinds:\n  - Simple read and write templates for plain updates with no side-effects.\n  - Customizable read/write (and read_field/write_field) templates that require overriding abstract read/write methods; read_field/write_field provide extra parameters.\n  - Predefined specialized templates (notably unimpl and read_only).\n- A register or field may instantiate separate templates for reads and writes; if a register instantiates a read/write template, that behavior overrides descending into its fields (e.g., read_only on a register captures all writes).\n- Example register/bank declaration shown (little-endian default) and note that in ranges the most significant bit is always the left number regardless of bitorder setting.\n- Attributes (DML) map to Simics configuration object attributes:\n  - Use cases: expose user-configurable parameters, expose internal state needed for checkpointing, or create pseudo attributes (not checkpointed) for debugging/back-doors.\n  - Attributes are name + get/set functions; type parameter controls value type.\n  - init template is useful for initializing attribute state.\n  - Four standard attribute templates: bool_attr, int64_attr, uint64_attr, double_attr; they store the value in a session variable val and provide init_val (constant) to set its initial value; custom init() can be used for non-constant initialization.\n  - Recommendation: prefer Saved Variables for simple checkpointed internal state rather than attributes.\n- Connects:\n  - A connect object holds a reference to a Simics configuration object and creates a corresponding attribute in the generated class that can be assigned a Simics object.\n  - Connects are like specialized attributes for object references; they can declare required interfaces the target object must implement.\n  - Connects are initialized from outside (e.g., configuration files); the parameter controls whether initialization is required and whether the connection is saved in checkpoints.\n  - The actual conf_object_t* is stored in a session member obj and accessed as <connect_name>.obj."
            },
            {
              "title": "Connects",
              "start_index": 20,
              "end_index": 21,
              "nodes": [
                {
                  "title": "Interfaces",
                  "start_index": 21,
                  "end_index": 33,
                  "node_id": "0032",
                  "summary": "This partial document covers DML/Simics device-modeling concepts and usage including:\n\n- Connect objects and optional connections\n  - Declaring connect blocks and checking for null object pointers\n  - Example connect usage\n\n- Interfaces for connected objects\n  - Declaring interface objects inside connects, required vs optional interfaces\n  - Default C type naming convention (object_name_interface_t)\n  - Calling interface functions from DML (omitting first object pointer)\n\n- Implements (exporting Simics interfaces)\n  - implement objects define methods that map to C interface functions\n  - Typical placement under port objects; C type naming convention\n  - Example: implementing ethernet_common and importing standard interface DML\n\n- Events\n  - Event objects, posting to time or cycle queues, built-in post method\n  - Six predefined event templates (simple_time/cycle, uint64_time/cycle, custom_time/cycle)\n  - Differences in delay units and associated data, and extra methods required for custom events\n\n- Groups\n  - Namespacing and structuring collections (registers, banks, ports, subdevices)\n  - Group arrays, nesting, and examples creating repeated register instances\n  - Using templates with groups and examples (weird template, FSM abstraction)\n  - How grouped banks/ports/subdevices appear in Simics object hierarchy (dev.g.bank.regs)\n\n- Ports\n  - Structural elements grouping interface implementations\n  - Connecting to specific ports; ports represented as dev.port.name in Simics\n  - Support for port arrays\n\n- Subdevices\n  - Subdevices as separate configuration objects grouping related banks/ports/attributes\n  - Exposure of attributes/connects/saved variables under the subdevice object\n\n- Templates\n  - Definition and reuse via is statements or inline is usage\n  - Override resolution rules (B overrides A if B instantiates A)\n  - Templates as types: template type members (session/saved vars, typed params, shared methods/hooks, inherited members), casting and comparisons\n  - Shared methods: compiled once, restrictions on accessible symbols, use of this, examples and workaround for unrestricted implementations\n  - Typed parameters: param name : type; constraints on definitions (must be constant-like, side-effect free, device-independent), typical use to let shared methods access parameters (example max_val_reg)\n\n- Parameter declarations\n  - Forms: param name = expr, param name default expr, or declaration without definition\n  - Defaults overridden by assignments; examples and notes about auto parameter usage in libraries\n\n- Data types\n  - Overview of eight kinds: integers (int1..int64, uint1..uint64), endian integer types with _be_t/_le_t suffixes, double, bool, arrays, pointers, structs\n  - Layout types (byte-order-specified memory mapping) and rules for member access\n  - Bitfields syntax and behavior\n  - Serializable types: which types are checkpoint-serializable and which are not (pointers, extern structs)\n\n- Methods\n  - DML methods as C-like functions with an implicit device parameter\n  - Support for exceptions (try/throw)\n  - Multiple return values (methods can return multiple results) and C-style parameter syntax"
                }
              ],
              "node_id": "0031",
              "summary": "- Topic: exposing and saving internal device state for checkpointing; attributes are used to expose state (registers/vars usually suffice, but attributes handle non-trivial state like FIFOs).\n- Attributes: represented as a name plus get/set functions; the value type is controlled by a type parameter; can be used as pseudo attributes (back-doors for control/inspection) which are not checkpointed.\n- Standard attribute templates: bool_attr, int64_attr, uint64_attr, double_attr \u2014 each supplies overridable get/set and stores the current value in a session variable named val of the corresponding type (e.g., dev.a.val).\n- Initialization: templates provide an overridable init() that sets val; init_val parameter controls the initial value and must be constant. If a non-constant initialization is required, override init().\n- Recommendation: prefer Saved Variables for storing/checkpointing simple internal device state rather than using attribute objects.\n- Connect objects: act as containers holding references to arbitrary Simics configuration objects; a corresponding attribute is added to the generated configuration class and can be assigned a \"Simics object\".\n- Connection configuration: connect declarations are like attributes specialized for object references; the configuration parameter controls whether the connect must be initialized and whether it is checkpointed.\n- Storage and null checks: the actual object pointer is stored in a session member obj (access via connect_name.obj); if not required, the pointer can be null and user code must check before use.\n- Interfaces inside connects: declare expected Simics interfaces the connected object must implement; interface objects can mark interfaces required (default true) or optional (required = false); missing a required interface causes a runtime error.\n- C type convention and calling: default C type for an interface is interface_name_interface_t; interface functions are called like normal C functions but omit the first argument (the target object pointer) when invoked from DML \u2014 example shows calling plugin.serial_device.write(value)."
            },
            {
              "title": "Implements",
              "start_index": 33,
              "end_index": 22,
              "node_id": "0033",
              "summary": "No content was provided in the partial document, so no main points can be identified or summarized."
            },
            {
              "title": "Events",
              "start_index": 22,
              "end_index": 23,
              "node_id": "0034",
              "summary": "Covers three DML concepts for device modeling:\n\n- Implements: Describes how a device exports a Simics interface via an implement object containing the methods that implement that interface. The implement object's name becomes the Simics interface name and its methods must match the C-function signatures (a device object pointer is implicitly added as the first parameter). The C type is taken from the object name with \"_interface_t\" appended (typically a typedef for a struct of function pointers). Shows an example (ethernet_common) and notes standard interface types can be imported from DML files matching C headers.\n\n- Events: Defines event objects that encapsulate Simics events which can be posted to time or step queues. Each event has a built-in post method and an abstract event callback the user implements. Events must use one of six templates (simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event), with time vs cycle determining delay units. Posted events may carry no data (simple), a uint64, or a void* (custom); custom events require get_event_info, set_event_info and destroy methods for proper checkpointing.\n\n- Groups: Explains grouping of attribute, connect, event, field, register, bank, port and subdevice objects for namespacing and structuring arrays/collections. Shows use cases: repeating register blocks with group arrays, parameterized group templates to share common registers and behavior across groups, and nested groups for hierarchical layouts. Examples illustrate index-driven offsets, parameter passing, and nested group composition."
            },
            {
              "title": "Groups",
              "start_index": 23,
              "end_index": 36,
              "node_id": "0035",
              "summary": "- Groups: neutral namespace objects used to organize attributes, connects, events, fields, registers, banks, ports and subdevices; support arrays and nesting; commonly used to create repeated register structures and to instantiate template-based abstractions (examples: bank with block arrays, nested sub_blocks, FSM implemented via group-instantiated templates).  \n- Ports: structural elements grouping implementations of one or more interfaces; can be arrays; represented in Simics as separate configuration objects with a .port prefix (e.g., dev.port.p[0]).  \n- Subdevices: like groups but presented as distinct configuration objects; attributes/connects/saved variables inside a subdevice become members of that subdevice object.  \n- Templates: reusable declaration blocks introduced with is/name syntax; can be instantiated inline or with standalone is statements; template instantiation expands template body into the object.  \n- Template types and members: each template defines a type (like a class) whose members include session/saved variables, typed parameters, shared methods, shared hooks, inherited template members, and a templates member for qualified calls; values can be cast between template types.  \n- Shared methods: declared with shared to compile one implementation per template type (reduces duplication); shared methods may only access global symbols and members of the template type (via this); a separate non-shared implementation can be provided if needed.  \n- Typed parameters: declared as param name : type within templates; they create type members and require the parameter to be defined as a compile-time constant (no side effects, no device-dependent state or independent method calls). Used to let shared methods access parameter values.  \n- Parameter declarations: syntax param name = expr or param name default expr; defaults can be overridden by assignments; unassigned parameters must be provided by users or compilation fails; special form param name auto used in libraries.  \n- Override and resolution rules: multiple declarations/overrides of parameters and methods are resolved using template-instantiation and import hierarchies; only default-declared methods/parameters can be overridden; ambiguous override orders are errors; assignments cannot be overridden.  \n- Data types: C-like type system with integers (int1..int64, uint1..uint64 and aliases), endian integer types (e.g., uint16_be_t) with defined byte order and alignment, double, bool, arrays, pointers, structs, layouts (memory-mapped representations with explicit endianness), bitfields (named bit slices), and typedefs.  \n- Layouts and bitfields: layouts map member declarations to explicit memory representation; layout members translate integer/bitfield members to endian integer access; bitfields define named bit ranges and can be treated as integers.  \n- Serializable types: primitive non-pointer types, structs/layouts/arrays of serializable types, template types and hook references are serializable for checkpointing; pointer and extern struct types are not serializable.  \n- Methods: C-like functions with an implicit device instance parameter; support multiple return values, throws/try for exceptions, and inline arguments; methods must be uniquely named per scope.  \n- Method specifics: multiple return values allowed; throw must be declared with throws; default(...) calls the overridden implementation; templates-qualified calls allow selecting a specific template implementation when default is ambiguous.  \n- Calling conventions and helpers: compound initializers for struct-like arguments ({...}), rules for variadic/inline argument usage; inline methods are re-evaluated at each invocation and allow propagation of constant inline arguments."
            },
            {
              "title": "Ports",
              "start_index": 36,
              "end_index": 37,
              "node_id": "0036",
              "summary": "Summary of main points in the partial document:\n\n- Overridable built-in methods: an overridable built-in method is defined by a template named after the object type; to make a template implementation overridable you must explicitly instantiate the object template (e.g., use \u201cis register;\u201d).\n\n- Method call syntax: calls resemble C (e.g., (a, b) = access(...); assigns multiple return values). The identifier default can be used inside an overriding method to invoke the overridden implementation. The templates member of objects lets you call a specific template\u2019s implementation (useful when default is ambiguous or from outside the overriding method).\n\n- Compound initializer syntax: struct-like arguments can be constructed inline with {...}, including designated and partial designated initializers (e.g., {1,4}, {.y=1,.x=4}, {.y=1,...}). This syntax is not allowed for variadic or inline arguments.\n\n- Inline methods: methods may declare inline arguments; the body is re-evaluated on each call and constant arguments are propagated. Inline methods are largely retained for compatibility; DML 1.4 offers better code-size reduction mechanisms.\n\n- Exported methods and function pointers: methods can be exported via export, and method references can be converted to function pointers using &.\n\n- Independent methods: methods that do not depend on a device instance may be declared independent. Exported independent methods omit the device instance parameter. Independent methods may not access device-dependent state (no session or saved variables, no after or log, and cannot call non-independent methods). Shared independent methods may be declared inside templates.\n\n- Independent methods and callbacks: to safely mutate device state from callbacks, have the independent method call a non-independent method via a function pointer (&) rather than mutate state directly.\n\n- Independent startup methods: independent startup methods run when the model loads (before device creation). They may not return values or be declared throws and cannot be declared overridable (workaround: call an overridable independent method). Abstract shared independent startup methods are allowed. The implicit call order is undefined, except non-memoized independent startup methods are called before memoized ones.\n\n- Independent startup memoized methods: memoized startup methods are allowed (and required) to have return values and/or throws. Their results (or thrown exceptions) are cached after the first call for the simulation session so subsequent calls return the same result or rethrow without re-executing the body."
            },
            {
              "title": "Subdevices",
              "start_index": 37,
              "end_index": 26,
              "node_id": "0037",
              "summary": "The partial document text is missing or empty, so there are no main points to summarize."
            }
          ],
          "node_id": "0019",
          "summary": "- COVERITY pragma: explains how to manually suppress or classify Synopsys Coverity defects for specific DML lines.  \n- Pragma syntax: /*% COVERITY event classification %*/ (classification optional). When DMLC is run with --coverity, the pragma produces a C annotation /* coverity[event : classification] */ or /* coverity[event] */.  \n- Scope/behavior: every COVERITY pragma on consecutive lines before a DML line applies to that DML line; a blank line breaks the sequence. Example demonstrates multiple pragmas and how a blank line stops propagation.  \n\n- DML object model overview: each DML model describes a single device object containing nested member objects, methods (behavior), and parameters (static properties). Objects have fixed object types (e.g., bank, register); user-defined types are not allowed, but members/methods/parameters can be locally added or overridden per object (local one-shot subtyping).  \n- Instantiation: a DML model (the whole hierarchy) is instantiated atomically; individual objects cannot be instantiated standalone. Templates provide reusable code blocks that can be expanded into objects.  \n- Mapping to Simics: much of the DML object model maps to the Simics configuration object model\u2014device maps to a Simics configuration class; attributes and interfaces map to Simics attributes/interfaces.\n\n- Device structure rules: exactly one top-level device object. Context restrictions for object types:\n  - bank, port, subdevice: only under device or subdevice.\n  - implement: only under device, port, bank, or subdevice.\n  - register: only under a bank.\n  - field: only under a register.\n  - connect: only under device, subdevice, bank, or port.\n  - interface: only directly below a connect.\n  - attribute: only under device, bank, port, subdevice, or implement.\n  - event: may appear almost anywhere except under field, interface, implement, or another event.\n  - group: can appear under any object and contain any object its parent may contain, except it cannot contain interface or implement.\n\n- Parameters (param): describe expressions and are expanded at compile time (like macros). Key properties:\n  - No type declarations required; each usage re-evaluates the expression.\n  - Definitions must be syntactically valid expressions.\n  - Unfolded parameter expressions are evaluated in the scope where the parameter was defined (not where referenced).\n  - Parameters are not dynamically changeable at run-time but may be declared to allow later overrides (see Parameter Declarations)."
        },
        {
          "title": "Templates",
          "start_index": 26,
          "end_index": 27,
          "nodes": [
            {
              "title": "Templates as types",
              "start_index": 27,
              "end_index": 28,
              "node_id": "0039",
              "summary": "Summary of main points in the partial document:\n\n- Example of template method overriding: template A defines a default hello() method; template B inherits A and overrides hello(), calling default() to invoke the ancestor implementation and then logging additional output. A pointer to a formal \u201cResolution of Overrides\u201d spec is given.\n\n- Templates as types: each template defines a type (like a class) whose instances can be referenced and stored in variables. Not all top-level declarations become type members; the document lists which declarations do:\n  - session and saved variables declared in the template\n  - typed parameters\n  - methods declared with the shared keyword\n  - shared hooks\n  - all type members inherited from ancestor templates\n  - a special templates member to invoke ancestor template shared method implementations\n\n- Member access and naming: template members are accessed with the dot operator; the template name is the type name. Objects can be cast to template types with the cast operator; examples show creating a register reference and setting its fields.\n\n- Equality and casting: two values of the same template type compare equal when they reference the same object. Values can be upcast to ancestor template types, and any template value can be cast to the universal template type object (even if not an ancestor).\n\n- Shared methods: shared methods are compiled once for the template type and shared across instances to avoid code duplication. This improves code size and compilation cost but imposes access restrictions:\n  - A shared method may only access global symbols and members of the template\u2019s type (not other template-defined symbols).\n  - Members may be accessed directly or via the automatic this variable; inside the shared method, this has the template\u2019s type.\n\n- Examples and nuances: an example shows an abstract shared method and an overridden implementation that uses this.n(). The document also explains a pattern to bypass shared-method access restrictions by separating declaration (shared method) from a non-shared implementation method so the implementation can access additional symbols (at the cost of code duplication)."
            },
            {
              "title": "Shared methods",
              "start_index": 28,
              "end_index": 28,
              "node_id": "0040",
              "summary": "This excerpt covers two main topics:\n\n- Casting rules for template-related types: shows examples of casting an attribute to a specific uint64_attr and back, and states that any value of a template type can be cast to the template type object even when that object is not an ancestor of the template.\n\n- Shared methods in templates (section 3.7.2): explains that regular template methods are instantiated into each object using the template (causing code duplication and slower compilation), whereas declaring a method shared makes a single implementation shared across all instances. It outlines the restrictions on shared methods \u2014 they may only access global symbols and members of the template\u2019s type (by name or via this), and accessing other template-defined symbols is an error \u2014 and notes that inside a shared method this has the template type. Examples illustrate overriding a shared method and a pattern to avoid the restrictions by declaring a shared method but providing its implementation separately so it can access otherwise-restricted members (e.g., get_qname)."
            },
            {
              "title": "Typed Parameters",
              "start_index": 29,
              "end_index": 29,
              "node_id": "0041",
              "summary": "- Introduces typed parameter declarations for templates using the form: param name : type;\n- Explains that a typed parameter adds a member to the template type with the same name and type, and that the parameter\u2019s definition becomes the value of that template member.\n- Lists requirements for the named parameter:\n  - It must be defined via a regular parameter declaration (inside the template, sub-templates, or objects instantiating the template).\n  - Its definition must be a valid expression of the declared type.\n  - Its definition must be free of side effects and independent of the specific device instance (i.e., essentially a constant expression).\n- Clarifies allowed constant-like expressions: index parameters, each-in expressions, object references cast to template types, and references to other parameters that also meet the constancy rule.\n- Prohibits certain expressions: method calls, references to session/saved variables, and calls to independent methods in the parameter definition.\n- Notes the common use case: enabling shared methods inside a template to access template parameters.\n- Provides an example template (max_val_reg) showing a typed parameter max_val : uint64 used inside a shared write method, and an instantiation that assigns a compile-time expression (128*(i+1)-1) to the parameter."
            }
          ],
          "node_id": "0038",
          "summary": "- Subdevices: when a subdevice is present it is exposed as a separate configuration object; if the subdevice contains attribute, connect, or saved declarations, the corresponding configuration attributes become members of the subdevice object instead of the parent device.\n\n- Templates overview: a template (template name { ... }) defines reusable declarations that get expanded into any object that uses the template. Templates are applied with is statements (e.g., is A; or field F is (name1, name2);). Using is inside object declarations is common; standalone is statements are useful for top-level device instantiation and with in each blocks.\n\n- Examples and usage patterns: shows idiomatic uses such as\n  - in each field { is A; } inside a register declaration\n  - applying multiple templates when declaring an object\n\n- Override semantics: when two templates define the same method/parameter name, the template instantiation hierarchy resolves which overrides which (a template B that instantiates A overrides A). Overrides only apply to methods and parameters declared default. A sample (A/B) demonstrates calling default() and extending behavior. A formal \u201cResolution of Overrides\u201d is referenced.\n\n- Templates as types: each template also defines a type (analogous to a class). Type members include:\n  - session and saved variables declared in the template\n  - typed parameters\n  - methods declared with shared\n  - shared hooks\n  - type members inherited from ancestor templates\n  - a templates member for invoking ancestor template implementations\n\n- Member access, casting, and comparisons: template members are accessed with dot notation. An object reference can be converted to a template type value using cast (example: local register x = cast(regs.r0, register); x.val = 14). Two values of the same template type compare equal if they reference the same object. Values can be upcast to ancestor template types."
        },
        {
          "title": "Parameter Declarations",
          "start_index": 30,
          "end_index": 31,
          "node_id": "0042",
          "summary": "Summary of main points in the partial document:\n\n- Parameter declarations\n  - Syntax: \"param name specification;\" where specification is either \"= expr\" (assignment) or \"default expr\".\n  - Examples: param offset = 8; param byte_order default \"little-endian\";\n  - Rules:\n    - A default value is overridden by an assignment; at most one assignment per parameter.\n    - The specification is optional; omitting it declares the parameter must be given a value when the template is used (or the model will not compile).\n    - A bare declaration without a definition is redundant if a typed parameter declaration already exists.\n  - Use in templates: declaring parameters in templates forces users of the template to supply values (example shown with a template constant using param value).\n  - Special form: \"param name auto;\" (e.g. param parent auto;) is used in standard libraries to declare built-in automatic parameters and should not be used outside libraries.\n  - Warning about leaving out parameter declarations: can cause obscure errors or unintended name resolution due to scoping.\n\n- Data types (beginning of section)\n  - DML type system builds on C with modifications; eight kinds of data types exist and typedefs are supported.\n  - Integers:\n    - Named uint1..uint64 (unsigned) and int1..int64 (signed). Sizes guarantee a minimum bit width; exceeding the type\u2019s capacity is undefined (no implicit truncation).\n    - Aliases: char -> int8, int -> int32. C keywords short, signed, unsigned are reserved and not allowed in type declarations.\n    - Types like size_t, uintptr_t, long, uint64_t, int64_t are provided for compatibility with C/third-party libraries.\n  - Endian integers:\n    - Typed to exact byte size without padding, have defined byte order, and natural alignment of 1 byte.\n    - Named with _be_t (big-endian) or _le_t (little-endian) suffixes (list of supported endian types provided).\n    - Endian types interoperate with regular integer types (coercion as needed); arithmetic operations yield regular integer types.\n\n- The next subsection heading \"Floating-point numbers\" appears but its content is not included in the partial document."
        },
        {
          "title": "Data types",
          "start_index": 31,
          "end_index": 44,
          "nodes": [
            {
              "title": "Serializable types",
              "start_index": 44,
              "end_index": 32,
              "node_id": "0044",
              "summary": "The provided partial document is empty or missing; no content or main points are available to summarize."
            }
          ],
          "node_id": "0043",
          "summary": "- Introduces DML type system (section 3.9): builds on C with eight kinds of types and typedefs.\n- Integer types: named int1..int64 and uint1..uint64, guaranteed minimum bit widths (no implicit truncation); aliases char->int8 and int->int32; some C compatibility types (size_t, uintptr_t, long, uint64_t, int64_t).\n- Endian integer types: fixed byte-width storage, explicit byte order and 1-byte alignment; names use _be_t/_le_t suffixes (list of supported sizes); interoperable with regular integers but operations yield regular integer types.\n- Floating point and booleans: single floating type double; bool with true/false.\n- Arrays and pointers: C-like arrays; pointers as in C; pointer to non-standard integer widths is undefined.\n- Structs: composite types with unnamed labels allowed; no assumed in-memory layout (use layouts for exact mapping).\n- Layouts: layout types map precisely to memory with mandatory byte-order (\"big-endian\" or \"little-endian\"); allowed members are integers, endian integers, other layouts, bitfields, and arrays; integer and bitfield members are translated into endian integers matching layout endianness.\n- Bitfields: named bit slices with explicit ranges and configurable bitorder; can be used as whole integers; example syntax and usage shown.\n- Serializable types (3.9.1): compiler-serializable types used for checkpointing \u2014 all primitive non-pointer types, structs/layouts/arrays composed entirely of serializable types, templates and hook references; pointers and extern structs are not serializable.\n- Methods (3.10): C-like functions with implicit device-instance parameter, support try/throw exceptions; methods may have multiple return values and must use return when returning; throws declared with throws.\n- Default/override rules: parameters and methods can be overridden following template and import precedence; ambiguous multiple declarations cause errors; assignment (=) of a parameter cannot be overridden; methods must be declared default to be overridable; note about overridable built-ins via template instantiation.\n- Calling methods: tuple assignment from calls, use of default to call overridden method, templates member to call a method implementation from a specific template, compound initializers for struct-like arguments (including designated and partial initializers).\n- Inline methods: method bodies re-evaluated at each call when using inline args; mainly kept for compatibility.\n- Exported methods and function pointers: methods can be exported; method references convertible to function pointers with &.\n- Independent methods: methods declared independent do not receive device instance, cannot access device-dependent features; can be shared within templates; guidance for mutating device state safely; supported startup independent methods with restrictions.\n- Independent startup memoized methods: memoization caches results across simulation session (or per-template-instance for shared memoized); first-call semantics; cannot be (indirectly) recursive.\n- Session variables (3.11): global runtime-named storage with optional initializers; C99-style designated initializers supported for structs/layouts/bitfields but partial initialization must be explicit via ...; designator lists and array designated initializers not supported.\n- Saved variables (3.12): checkpointed runtime storage (attributes auto-created); declared like session variables but types limited to serializable types; intended for checkpoint state (use attributes for configuration).\n- Hook declarations (3.13): hook(msgtypes) name defines FIFO queues of suspended computations (currently after statements); hooks have typed message components; operations: send (asynchronous, equivalent to after/send_now with different semantics), send_now (synchronous, returns number resumed), and suspended property; hook references are first-class, comparable, and serializable; guidance for checked send_now wrappers.\n- Object declarations (3.14): general syntax type name extras is (templates) desc { ... } or terminated with ; ; body may include parameters, methods, session/saved vars, in/each declarations, nested objects; is (template...) may be written inside body; desc maps to desc parameter; same-name same-type object declarations concatenate bodies.\n- Object arrays: support indexed array declarations type name[var < size]... with index parameters available in scope; size may be compile-time constant or ... to reuse previously declared sizes.\n- Register declarations (3.14.1): form supports optional size n, @ offset, and is (templates); size and offset may be provided as parameters via shorthand.\n- Field declarations (3.14.2): fields specify bit ranges with @ [high:low] or @ [bit]; bit numbering is defined by file bitorder; register bits numbered 0..n-1 and notation for msb/lsb clarified."
        },
        {
          "title": "Methods",
          "start_index": 32,
          "end_index": 45,
          "nodes": [
            {
              "title": "Input Parameters and Return Values",
              "start_index": 45,
              "end_index": 34,
              "node_id": "0046",
              "summary": "The partial document contains only a single instruction directing the reader to directly return a description and to include no other text, with no substantive content or additional sections."
            },
            {
              "title": "Default Methods",
              "start_index": 34,
              "end_index": 35,
              "node_id": "0047",
              "summary": "- Syntax and examples for defining methods: no-arg/no-return, methods with parameters, methods with single or multiple return values, requirement that methods with return values must end with a return statement.\n- Example of multi-return: method returning a tuple (int, int).\n- Exception handling syntax: methods that can throw must use the throws keyword; example showing throwing and returning.\n- Rules for \u201cdefault\u201d (overridable) parameters and methods: multiple declarations are resolved using template instantiation and file import hierarchies.\n  - A declaration in a block that instantiates a template overrides a declaration in that template.\n  - A declaration in a file that imports another file overrides the declaration in the imported file.\n  - If multiple declarations exist and no single declaration overrides all others, the result is an ambiguity error.\n- Examples illustrating precedence and conflicts: overriding a parameter from an imported file; a compile error when two templates declare the same parameter with no precedence; resolving conflicts by adding a local overriding declaration.\n- Additional rules:\n  - An assignment-style parameter declaration (=) cannot be overridden.\n  - Method override resolution follows the same template/import hierarchy rules as parameters.\n  - A method may only be overridden by another method if it is declared default."
            },
            {
              "title": "Calling Methods",
              "start_index": 35,
              "end_index": 36,
              "node_id": "0048",
              "summary": "- Rules for declaration precedence across files and templates: imports and template instantiations determine which parameter or method declaration overrides another (example: my-dev.dml overrides common.dml).\n- Parameters: conflicts (multiple declarations) cause errors unless a new declaration is added in a location that overrides all conflicting ones; an assignment (=) of a parameter cannot be overridden.\n- Methods: override order is deduced from template and import hierarchies (a declaration in a block that instantiates a template overrides the template\u2019s declaration; a declaration in a file that imports another overrides that file\u2019s declaration). All declarations of a method must be ordered so one clearly overrides the others, otherwise it\u2019s ambiguous and erroring.\n- Only methods declared default can be overridden.\n- Built-in overridable methods are provided via templates named as the object type (e.g., to make a register\u2019s read method overridable, instantiate the register template with \u201cis register;\u201d).\n- Calling methods: C-like syntax with support for tuple assignment of return values (e.g., (a, b) = access(...)); use default(...) inside an overriding method to call the overridden implementation.\n- Use of the templates member of objects to invoke a method implementation provided by a specific template (useful when default is ambiguous or outside the overriding method body).\n- Compound initializer syntax for method arguments of struct-like types ({...}), including designated and partial designated initializers; not allowed for variadic or inline arguments.\n- Inline methods: methods may declare one or more inline arguments; the method body is re-evaluated at each call and constant inline arguments are propagated as constants into the method."
            },
            {
              "title": "Inline Methods",
              "start_index": 36,
              "end_index": 36,
              "node_id": "0049",
              "summary": "- Overridable built-in methods are defined by a template named after the object type; to make a template-provided method overridable you must explicitly instantiate the object template (e.g., using \"is register;\").\n- Method call syntax is C-like with differences: functions can return multiple values assigned via tuple syntax (a, b) = access(...);.\n- Within an overriding method you can call the overridden implementation using the identifier default(...).\n- Objects expose a templates member to invoke a specific template\u2019s implementation of a method, useful when multiple unrelated templates override the same method and default is ambiguous; templates can be used outside overriding method bodies as well.\n- DML supports compound (aggregate) initializers for struct-like method arguments using {...}, including designated and partial designated initializers; this syntax cannot be used for variadic or inline arguments.\n- Inline methods are declared by marking at least one input argument as inline (instead of a concrete type); the method body is re-evaluated on each invocation, and constant inline arguments are propagated as constants into the method."
            },
            {
              "title": "Exported Methods",
              "start_index": 36,
              "end_index": 36,
              "node_id": "0050",
              "summary": "Summary of main points in the partial document:\n\n- Overridable built-in methods are defined by a template named after the object type; to make a template\u2019s implementation overridable you must explicitly instantiate the object\u2019s template (example: use a statement like \"is register;\").\n- Method call syntax in DML resembles C; multiple return values can be assigned with tuple-style syntax, e.g. (a, b) = access(...).\n- An overriding method can invoke the overridden implementation using the special identifier default, e.g. x = default(...).\n- Objects expose a templates member that lets code call the implementation of a method provided by a specified template. This is useful when default is ambiguous (e.g., multiple unrelated template overrides) and can be used even outside an overriding method body.\n- DML supports compound and designated initializers for struct-typed method arguments using {...} and {.field = value} forms, including partial designated initializers with ..., but this initializer syntax cannot be used for variadic or inline arguments. (Example calls: copy_struct(&s, {1,4}); copy_struct(&s, {.y=1, .x=4}); copy_struct(&s, {.y=1, ...});)\n- Inline methods: a method can declare at least one input argument as inline (instead of a type), causing the method body to be re-evaluated at each invocation; when a constant is passed for an inline argument, that constant is propagated into the method body."
            },
            {
              "title": "Retrieving Function Pointers to Methods",
              "start_index": 36,
              "end_index": 36,
              "node_id": "0051",
              "summary": "Summary of main points in the partial document:\n\n- Overridable built-in methods:\n  - An overridable built-in method is implemented by a template named after the object type.\n  - To provide an overridable implementation for a built-in (e.g., a register's read method), the template must explicitly instantiate the object template using a statement like: is register;.\n\n- Calling methods:\n  - Method-call syntax resembles C; multiple return values can be assigned via tuple form, e.g., (a, b) = access(...);\n  - The identifier default can be used inside an overriding method to invoke the overridden implementation: x = default(...);\n  - Objects expose a templates member that allows calling a particular template\u2019s implementation of a method. This is useful when multiple, unrelated templates override a method and default would be ambiguous; templates can also be used outside the overriding method body.\n  - DML supports compound initializer syntax for struct-like argument values using {...}, including designated and partial designated initializers (examples shown). This initializer form cannot be used for variadic or inline arguments.\n\n- Inline methods:\n  - A method may declare at least one input argument as inline (instead of a type).\n  - The method body is re-evaluated on each invocation, and when a constant is passed for an inline argument, that constant is propagated into the method."
            },
            {
              "title": "Independent Methods",
              "start_index": 36,
              "end_index": 37,
              "nodes": [
                {
                  "title": "Independent Startup Methods",
                  "start_index": 37,
                  "end_index": 37,
                  "node_id": "0053",
                  "summary": "- Inline methods: historically used for cross-method constant folding to reduce compiled model size; in DML 1.4 they remain mainly for compatibility since better code-size reductions exist.\n- Exported methods: DML 1.4 supports exporting methods via an export declaration.\n- Method references: methods can be converted to function pointers using the & operator.\n- Independent methods:\n  - Syntax: declared with the independent keyword (independent method m(...) -> (...) {...}).\n  - Exported independent methods omit the device-instance input parameter, making them callable in more contexts.\n  - Restrictions: cannot access the device instance (no session or saved variables), cannot use after or log statements, and cannot call non-independent methods.\n  - Templates may declare shared independent methods.\n  - Callbacks and mutation: to safely mutate device state from code invoked via an independent method, mutation should occur in a non-independent method that independent code calls through a function pointer (&); independent methods must not directly mutate device state (e.g., via pointers to session variables) to avoid breaking breakpoints.\n- Independent startup methods:\n  - Declared startup to be run when the model is loaded (before any device is created).\n  - Restrictions: may not have return values, may not be declared throws, and may not have overridable definitions (workaround: call an overridable independent method from a non-overridable startup method). Abstract shared independent startup methods are allowed.\n  - Call order is undefined except that non-memoized independent startup methods are invoked before memoized ones.\n- Independent startup memoized methods:\n  - May and typically must have return values and/or throws.\n  - Memoization semantics: the first call executes the body; subsequent calls in the same simulation session return the first call\u2019s result (or rethrow if the first call threw) without re-executing the body."
                },
                {
                  "title": "Independent Startup Memoized Methods",
                  "start_index": 37,
                  "end_index": 38,
                  "node_id": "0054",
                  "summary": "- Inline methods: historical note that they were used to enable constant folding across methods and reduce model size; in DML 1.4 they remain mainly for compatibility because there are better ways to reduce code size.\n\n- Exported methods: DML 1.4 supports exporting methods via an export declaration.\n\n- Function-pointer conversion: method references can be converted to function pointers using the & operator.\n\n- Independent methods:\n  - Declaration syntax: independent method m(...) -> (...) {...}\n  - Semantics: independent methods do not receive or rely on the specific device instance; their body may not reference session or saved variables, use after or log statements, or call non-independent methods.\n  - Templates: shared independent methods may be declared inside templates.\n  - Callbacks and state mutation: to mutate device state safely from a context tied to independent methods, mutation should occur in a non-independent method that independent methods call via a function pointer (&). Independent methods must not directly mutate device state (e.g., through pointers to session variables) because that can break Simics breakpoints.\n\n- Independent startup methods:\n  - Declaration: independent methods may be declared startup to run when the model loads (before any device creation).\n  - Restrictions: startup independent methods may not have return values or be declared throws, and may not have overridable definitions (workaround: call an overridable independent method). Abstract shared independent startup methods are allowed.\n  - Invocation order: not defined in general; exception\u2014non-memoized independent startup methods are called before memoized ones.\n\n- Independent startup memoized methods:\n  - Memoized startup methods must have return values and/or be declared throws.\n  - Caching behavior: the first call executes the body; subsequent calls return the cached result (or rethrow if the first call threw). The first call is typically the implicit model-load call but could occur earlier.\n  - Sharing: result caching is shared across all instances of the device model; for shared memoized methods the cache is per template instance (not shared across objects instantiating the template).\n  - Recursion: (Indirect) recursive memoized calls are forbidden and produce a run-time critical error.\n\n- Session variables:\n  - Purpose: named storage locations for arbitrary run-time values; names share the namespace with objects and methods.\n  - Syntax: session declarations = initializer; (initializer optional). Declarations follow C-like variable declaration syntax. Examples given (scalars, arrays, tuples, pointers).\n  - Default initialization: absence of explicit initializer uses an all-zero default initializer.\n  - Initializer rules: number and structure of initializers must match declared variables and compound types; nested compound initializers must be enclosed in braces.\n  - Designated initializers: C99-style designated initializers are supported for struct, layout, and bitfield types (example shown).\n  - Differences from C:\n    - Implicit partial initialization is not allowed; every member must have a designated initializer unless explicit trailing ... syntax is used to allow partial init.\n    - Designator lists and designated initializers for arrays are not supported."
                }
              ],
              "node_id": "0052",
              "summary": "- Overriding built-ins: an overridable built-in method is defined by a template named after the object type; to override a register method (e.g., read) the overriding template must explicitly instantiate the register template using an \u201cis register;\u201d statement.\n\n- Calling methods: method calls look C\u2011like; multiple return values can be assigned via tuple syntax ((a, b) = access(...)); overridden methods can be referenced from an overriding method using default(...); when multiple unrelated templates provide overrides and default is ambiguous, the templates member of an object can be used to call a particular template\u2019s implementation (and templates can be used outside overriding bodies).\n\n- Compound initializers: DML supports struct-like argument construction with {...}, including designated (.y = 1) and partial designated initializers ({.y = 1, ...}); this syntax cannot be used for variadic or inline arguments.\n\n- Inline methods: methods may declare at least one argument inline so the body is re-evaluated on each call and constant arguments are propagated; inline methods are retained mainly for compatibility (older code-size optimization).\n\n- Exported methods and function pointers: methods may be exported with export, and method references can be converted to function pointers using &.\n\n- Independent methods: methods that do not depend on a device instance can be declared independent, omitting the device instance parameter for exported independent methods; independent method bodies may not access session/saved variables, use after/log, or call non-independent methods. Templates may declare shared independent methods. When independent methods need to mutate device state (e.g., as callbacks), they should call non-independent methods (via &) to perform mutations safely.\n\n- Independent startup methods: independent methods may be marked startup to run when the model is loaded (before any device exists). Such startup methods may not return values nor be throws and cannot be declared overridable; abstract shared independent startup methods are allowed. Call order is undefined except that non-memoized independent startup methods are called before memoized ones.\n\n- Independent startup memoized methods: memoized startup methods are allowed and expected to have return values and/or be throws; they execute once on first call and subsequent calls return the cached result (or rethrow the cached throw) without re-executing the body."
            }
          ],
          "node_id": "0045",
          "summary": "- Primitive and composite types\n  - Single floating-point type: double (maps to C double).\n  - Boolean type: bool (true/false).\n  - Arrays and pointers behave like C; string literals are const char *; pointers to integer types with nonstandard bit-widths have undefined meaning.\n  - Structs define named-member composite types; DML does not assume layout (see layouts). Structs may refer to types declared later; typedef struct { ... } name; is supported.\n\n- Layouts and bit-level types\n  - Layouts define a precise memory mapping with mandatory byte order (\"big-endian\" or \"little-endian\") and allow integer, endian-integer, other layouts, bitfields, and arrays as members.\n  - Accessing layout members maps integer/bitfield members to endian-aware integer accesses.\n  - Bitfields: named bit ranges within a fixed-size container (example syntax shown). Bit numbering depends on file bitorder. Bitfields can be used as structs or as whole unsigned integers.\n\n- Serializable types\n  - Compiler-serializable types: all primitive non-pointer types, structs/layouts/arrays composed entirely of serializable types, templates, and hook reference types.\n  - Non-serializable: pointer types and extern struct types (and anything not meeting the above).\n\n- Methods\n  - Methods resemble C functions but have an implicit device-instance parameter and support try/throw exception handling.\n  - Multiple return values allowed; absence of parameters or returns uses empty parentheses. Methods with return values must use return.\n  - throws declares a method may throw.\n  - Override resolution: templates and import hierarchy determine which parameter or method declaration takes precedence; ambiguity is an error. Only methods declared default may be overridden.\n  - Calling methods: multiple-return assignment syntax (a, b) = m(...); use default(...) to call overridden implementation; templates member lets you call a template's implementation.\n  - Compound initializers for struct-like arguments and designated/partial initializers supported (with limitations).\n  - Inline methods: bodies re-evaluated at each call; inline args propagate constants; mainly for compatibility.\n  - Exported methods and obtaining function pointers (&method) are supported.\n  - Independent methods: do not rely on device instance and can be exported without device parameter; restricted from accessing device-specific features. Shared independent methods in templates allowed.\n  - Independent startup methods: called at model load; must have no returns or throws and cannot be overridable. Memoized independent startup methods are allowed to return/throw and cache first-call results across the session (shared across device instances or per-template instance for shared memoized methods). Recursive memoized calls are runtime errors.\n\n- Session and saved variables\n  - Session variables: globally-scoped run-time named storage (same namespace as objects/methods) with optional initializers; default zero initialization if omitted. C99-style designated initializers supported for struct/layout/bitfields; partial initialization requires trailing ...; arrays and designator lists have limitations.\n  - Saved variables: like session variables but automatically checkpointed (serializable-only types). Intended for checkpointable state; configuration should use attributes instead.\n\n- Hooks\n  - hook(msgtypes...) name; declares a FIFO synchronization point where computations (currently method calls via after) can suspend and later be resumed by sending a message.\n  - Operations: h.send(...) (asynchronous, delayed until current device stack unwinds), h.send_now(...) (synchronous, resumes suspended computations and returns count resumed), and h.suspended (number suspended).\n  - Hook references are first-class, serializable, and comparable. Guidance provided for checked send_now wrappers and limitations on passing pointers to stack data.\n\n- Object declarations and arrays\n  - General syntax: type name [extras] is (templates) desc { ... } (or semicolon form for empty body). is (template...) may be written inside body as is template; desc maps to a desc parameter.\n  - Bodies may contain parameters, methods, session/saved declarations, in each declarations and nested objects.\n  - Object arrays: type name[indexvar < size]... declares index parameters available in object scope; sizes must be compile-time constants; ... can repeat previously defined sizes.\n\n- Register and field specifics\n  - register declarations may include size n, @ offset, and templates. size and @ map to param size and param offset respectively.\n  - field declarations use @ [high:low] (or @ [bit]) to define bit ranges within the containing register; the left number is always the most significant bit irrespective of file bit numbering. Bit numbering scheme (default little-endian or big-endian) affects how ranges map to significance.\n\n- Conditional object inclusion\n  - #if (conditional) { object declarations } with required braces; supports else and else-if chains to include/exclude object declarations based on boolean expressions."
        },
        {
          "title": "Session variables",
          "start_index": 38,
          "end_index": 39,
          "node_id": "0055",
          "summary": "- Memoized methods\n  - The initial call to an independent startup memoized method is usually made implicitly at model load (but can occur earlier if invoked by another independent startup method).\n  - Result caching can be used to compute device-independent data that is shared across device model instances.\n  - Results of shared memoized methods are cached per template instance and are not shared across all objects instantiating that template.\n  - (Indirectly) recursive memoized method calls are forbidden and cause a run-time critical error.\n\n- Session variables (section 3.11)\n  - Declared with the keyword session and follow a C-like declaration form; optional initializer allowed.\n  - Default initializer is \"all zero\" when no explicit initializer is provided.\n  - Tuple-style initializers must match the number of declared variables; compound sub-elements must be enclosed in braces.\n  - C99-style designated initializers are supported for struct, layout, and bitfield types.\n  - Differences from C: implicit partial initialization is not allowed (but explicit partial init is possible using trailing ...); designator lists and array-designated initializers are not supported.\n  - Note: formerly called data variables.\n\n- Saved variables (section 3.12)\n  - Declared with saved; create a named storage location and automatically create a checkpointable attribute for that variable.\n  - Can be declared in object or statement scope; follow the same initializer and default-zero rules as session variables.\n  - Support C99-style designated initializers for structs/layout/bitfields and the same differences from C (no implicit partial init; explicit partial via ...; no designator lists or array designated initializers).\n  - Types are currently restricted to serializable types (primitives or structs/arrays composed only of savable types).\n  - Intended primarily for checkpointable state; use attribute objects for configuration. More saved-data types are planned.\n\n- Upcoming: section 3.13 Hook Declarations (heading present but content not included in the excerpt)."
        },
        {
          "title": "Saved variables",
          "start_index": 39,
          "end_index": 57,
          "node_id": "0056",
          "summary": "Summary of main points in the partial document:\n\n- Saved variables (Section 3.12)\n  - saved declarations create named, checkpointed storage per object or statement scope: syntax \"saved declaration = initializer;\".\n  - Default initializer is all-zero. Initializer element counts must match type; nested compound elements require braces.\n  - Supports C99-style designated initializers for structs/layouts/bitfields, but unlike C requires explicit initialization of all members unless trailing \"...\" is used; no designator lists or array designated initializers.\n  - Only \"serializable\" types are allowed (primitives, structs/arrays composed of serializable types). Intended for checkpointable state (not for configuration).\n\n- Hook declarations (Section 3.13)\n  - hook(msgtype1,...,msgtypeN) name; defines a hook to which suspended computations (currently single method calls via after) may attach. Hooks use FIFO order.\n  - Hooks have typed message components; zero or more types allowed.\n  - Operations:\n    - h.send(...) \u2014 asynchronous send: message is sent after current device entries complete; equivalent to after: h.send_now(...) but cannot be cancelled with cancel_after(). Avoid passing pointers to stack data; use send_now or wrapper patterns when needed.\n    - h.send_now(...) \u2014 synchronous send: resumes suspended computations before returning; returns number of resumed computations.\n    - h.suspended \u2014 returns number suspended on the hook.\n  - Hook references are runtime values, typed as hook(...), serializable, comparable for equality.\n  - Current lack of hook configurability (e.g., detecting unhandled messages) \u2014 suggested wrapper methods to log errors when send_now resumes zero computations.\n\n- Object declarations (Section 3.14)\n  - General syntax: type name extras is (template, ...) desc { ... } or with semicolon for empty body. Bodies can include params, methods, session/saved vars, in each, and nested object declarations.\n  - Templates can be inherited via is (template,...). Using is in header is equivalent to is statements inside body.\n  - Multiple declarations of same-named object in same scope and same type are concatenated (body merged); error if types differ.\n  - Object arrays supported for most object types: syntax type name[var < size]... with index parameters accessible as params in object scope. Size must be compile-time constant; \"...\" can be used to reuse previously defined dimension sizes across declarations.\n\n- Register and field declarations (Sections 3.14.1\u20133.14.2)\n  - Register syntax: register name size n @ d is (templates) { ... } (each piece optional; order matters). size and @ map to params size and offset.\n  - Field syntax: field name @ [high:low] (or @ [bit]) denotes bit ranges; [bit] is short for [bit:bit]. Left number is most significant in the range regardless of file bit numbering.\n  - Bit numbering schemes: default little-endian (le) bit 0 = LSB; big-endian (be) bit 0 = MSB. Examples show differing bit indices for same visual layout.\n\n- Conditional objects (#if) (Section 3.15)\n  - Object declarations can be conditionally included with #if (conditional) { ... } similar to method-level #if, braces required. Supports #else #if chains.\n  - Conditional expression must be constant boolean and can reference parameters in current or parent scopes.\n  - Allowed contents: objects, session/saved vars, methods, other #if, but not params, is, or in each statements.\n  - When condition true, contained declarations are treated as if written normally.\n\n- In each declarations (Section 3.16)\n  - in each (template-name, ...) { body } expands body into any subobjects that instantiate the listed templates (used to apply common properties across many objects).\n  - Declarations in in each override declarations in the template; enclosing scope declarations override in each.\n  - in each is not applied to the object containing the in each statement, only to subobjects.\n  - Multiple template names create context-dependent behavior (examples provided).\n\n- Global declarations (Section 3.17)\n  - import filename; \u2014 imports another file (string literal); -I flags control search paths; relative paths (./, ../) are resolved relative to importing file and bypass -I. Imported files parsed separately with their own language version and bitorder.\n  - Template declarations must be top-level and share namespace with types.\n  - bitorder order; \u2014 file-level bit numbering default (le) or be; must appear before other globals; does not affect imported files.\n  - constant name = expr; \u2014 compile-time constant (less powerful than parameter; useful for typedefs).\n  - loggroup name; \u2014 defines a log group value as distinct power-of-two; max 63 log groups per device (61 excluding built-ins).\n  - typedef / extern typedef \u2014 define types; extern typedef assumes the type exists in C (no C code generated); extern structs permit member access but may be incomplete/opaque.\n  - extern declarations \u2014 declare external C identifiers (variables/functions); multiple externs allowed if types match.\n  - header %{ ... %} / footer %{ ... %} \u2014 verbatim C included in generated header or at end of generated code; DMLC defines a macro pointing to a companion .h for including relative headers; use sparingly and must also declare those symbols in DML.\n  - export method as name; \u2014 expose a DML method as a C function (conf_object_t *obj, ...) with restrictions (no inline/shared/throwing/multiple-return/methods inside arrays). Generally discouraged; use Simics interfaces when possible.\n\n- Resolution of overrides (Section 3.18)\n  - Every declaration is assigned a rank; ranks form a partial order determined by file/top-level/template/in-each/import relationships and instantiation order.\n  - Dominance: within a set of declarations for the same parameter or method, exactly one declaration must dominate (have higher rank than) all others; abstract declarations cannot dominate. Rules govern counts of abstract declarations allowed.\n  - Specific rules for shared methods, default/abstract declarations, and how \"default\" refers to implementations in dominated declarations.\n  - Cyclic imports and self-higher-rank constructs are forbidden. Two top-level declarations of the same object in the same file have equal rank (can cause conflicts).\n\n- Comparison to C/C++ (Section 3.19)\n  - DML method bodies use a C-like language with extensions. Key differences:\n    - Fixed-width integer types int1..int64, uint1..uint64; all integer arithmetic is performed on 64-bit (int64/uint64) before truncation on assignment; floating arithmetic in double.\n    - Promotion rules: if any operand is uint64 \u2192 both promoted to uint64; otherwise promoted to int64; floating types promote to double.\n    - Comparisons do not promote signed to unsigned as in C; e.g., comparing uint64 0 > int32 -1 yields true in DML.\n    - Shift semantics defined for large shifts; shifting by >63 bits yields 0 (or -1 for negative left operand); negative shift is error.\n    - Division by zero is an error. Signed overflow is well-defined using two's complement modulo 2^64.\n    - Local variables must be declared with local/session/saved; session/saved behave like per-object static storage.\n    - Tuple syntax for simultaneous declarations and assignments; assignment is a statement (not expression).\n    - Calling C functions requires extern decl in DML, declaration in header block, and C definition/linking. Example workflow shown.\n    - cast(expr, type) syntax for casts; sizeof only on lvalues, use sizeoftype for types. Boolean operators produce bool type, conditions must be bool, delete/throw only as statements, no unions except via extern typedef trick.\n\n- Method statements (start of Section 3.20)\n  - All ISO C statements available. DML adds:\n    - Assignment statements supporting chaining and tuple/multiple simultaneous assignment, including method-return tuple assignment and swapping.\n    - (document continues into local statements, but cut off here)\n\nOverall, the partial document defines DML language constructs for saved/session state, hooks and their semantics, object/register/field declaration syntax and array/indexing rules, conditional and in-each constructs for modular object composition, top-level/global declarations and C interop facilities, the rules for resolving overrides and declaration dominance, and key semantic differences between DML and C/C++ including new statement forms for assignments and tuple handling."
        },
        {
          "title": "Hook Declarations",
          "start_index": 57,
          "end_index": 41,
          "node_id": "0057",
          "summary": "The partial document only contains an instruction to directly return a description without additional text and provides no substantive content to summarize."
        },
        {
          "title": "Object Declarations",
          "start_index": 41,
          "end_index": 59,
          "nodes": [
            {
              "title": "Register Declarations",
              "start_index": 59,
              "end_index": 44,
              "node_id": "0059",
              "summary": "The partial document is empty or missing, so no main points are available to summarize."
            },
            {
              "title": "Field Declarations",
              "start_index": 44,
              "end_index": 44,
              "node_id": "0060",
              "summary": "- Shows the syntax and semantics for register declarations:\n  - General form: register name size n @ d is (templates) { ... }\n  - The sections \"size n\", \"@ d\", and \"is (templates)\" are optional but must appear in that order when present.\n  - Equivalences: \"register name size n { ... }\" is equivalent to adding \"param size = n;\" inside the block; \"register name @ d { ... }\" is equivalent to adding \"param offset = d;\".\n\n- Describes field object declarations and bit-range notation:\n  - General forms: field name @ [highbit:lowbit] is (templates) { ... } or field name @ [bit] ... { ... } (where [bit] is shorthand for [bit:bit]).\n  - The \"@ [...]\" and \"is (templates)\" parts are optional; the bracket form conveniently sets the required field parameters lsb and msb.\n\n- Clarifies bit-range semantics and numbering:\n  - For multi-bit ranges, the first (leftmost) number denotes the most significant bit regardless of the file's bit-numbering scheme (matches usual visual representation).\n  - Register bits are numbered 0..n-1 where n is the register width.\n  - Default little-endian numbering: least significant bit = index 0, most significant bit = index n-1.\n\n- Mentions an illustrative example (truncated) of declaring a 32-bit register with high and low half-word fields."
            }
          ],
          "node_id": "0058",
          "summary": "- Hook messaging: semantics of send_now (synchronous, returns number of resumed computations, future coroutine behavior), h.suspended, hook reference types (hook(msgtypes...), equality, serializability) and suggested wrapper patterns for error logging when no consumer is suspended.\n\n- Object declaration syntax: general form/type/name/extras, optional templates (is (\u2026)), desc shorthand, concatenation of multiple declarations with same name/type, allowed contents (params, methods, sessions, saved vars, in-each, nested objects).\n\n- Object arrays: syntax type name[var < size]..., index parameters as scoped params, compile-time size requirement, ellipsis (...) to reuse previously defined sizes.\n\n- Register and field specifics: register declaration order (size, @offset, is), field declarations using @ [high:low] or single bit, bit indexing conventions under little-endian vs big-endian bitorder, and how ranges map to msb/lsb.\n\n- Conditional objects: #if/#else #if/#else structure for including/excluding declarations based on constant boolean expressions; allowed contents and scoping rules.\n\n- in each declarations: pattern application to objects instantiating templates, override precedence (in each < containing scope < direct declarations), multi-template guards, and examples of contextual behavior.\n\n- Global/top-level declarations: import (file search rules, independent parsing and language/version/bitorder), template declarations and namespace rules, bitorder declaration (le/be) and file scope implications, constants vs parameters, loggroup allocation and limits.\n\n- Type and linkage declarations: typedef/extern typedef semantics (including extern struct/member access rules), extern declarations for external C symbols, header/footer blocks inserting verbatim C into generated code (DMLDIR_... macro for companion headers), and export method as name for emitting C-callable functions (restrictions noted).\n\n- Resolution of overrides: ranking system for declarations (ranks for top-level, templates, in-each blocks, import ordering, is T boosting rank), dominance rules for params/methods, constraints on abstract declarations, default resolution semantics and prohibition of cycles/cyclic imports.\n\n- Comparison to C/C++: DML\u2019s extended-subset model, additional fixed-width integer types (int1..int64, uint1..uint64), bool type, arithmetic promotion rules (generally to int64 or uint64), floating-point as double, comparison and logical operators yield bool, well-defined signed overflow semantics, shift semantics, division-by-zero as error, typeof support, tuple syntax for multi-declaration/assignment, local/session/saved storage semantics (per-device), sizeof vs sizeoftype, restrictions on unions (use extern typedef workaround), and calling C functions via extern/header/footer.\n\n- Method-language extensions and statements: new statement forms and rules \u2014 assignment (chained and tuple simultaneous assignment), local/session/saved declarations and initialization rules, return with initializer/tuples, delete as statement, try/catch and throw (single exception kind, throw is statement, throws propagation), and method call syntax requiring assignment targets for return values."
        },
        {
          "title": "Conditional Objects",
          "start_index": 44,
          "end_index": 46,
          "node_id": "0061",
          "summary": "Summary of main points in the partial document:\n\n- Register declarations\n  - General form: register name size n @ d is (templates) { ... } with the three sections optional but required in that order if present.\n  - Shorthand: \"register name size n { ... }\" is equivalent to declaring a size parameter (param size = n); similarly \"@ d\" is equivalent to param offset = d.\n\n- Field declarations\n  - General forms: field name @ [highbit:lowbit] is (templates) { ... } or field name @ [bit] { ... } (the latter is short for [bit:bit]).\n  - The bracket syntax conveniently defines required field parameters lsb and msb.\n  - For multi-bit ranges, the leftmost number is always the most significant bit regardless of file bit-numbering convention.\n  - Bit indices run 0..n-1 where n is register width. In little-endian numbering LSB = 0; in big-endian numbering MSB = 0. Examples show how to declare high/low half-words under each convention.\n\n- Conditional objects (#if / #else / #else #if)\n  - #if (conditional) { object declarations ... } with braces required; else and else-if branches are supported.\n  - Conditionals must evaluate to a constant boolean and may reference parameters at the same or parent levels.\n  - Allowed contents inside #if are object declarations, session/saved variables, methods, or nested #if statements. Parameters, is statements, and in each statements are not allowed.\n  - When a branch is taken, its declarations are treated as if they appeared normally (examples shown).\n\n- In each declarations\n  - Syntax: in each (template-name, ...) { body } where body is a list of object statements expanded into any subobjects that instantiate the named template(s).\n  - Useful for applying a common pattern/property to many objects (example: setting default register size).\n  - Declarations in an in each block override declarations from the extended template; declarations in the containing scope override declarations from the in each block, enabling exceptions."
        },
        {
          "title": "In Each Declarations",
          "start_index": 46,
          "end_index": 47,
          "node_id": "0062",
          "summary": "This partial document covers DML language features including:\n- Conditional (#if) expressions with constant boolean values: what declarations are permitted inside them (objects, session/saved variables, methods, nested #if but not parameters/is/in each), and that when true the enclosed declarations behave as if written without the #if (example showing equivalence).\n- The \"in each\" declaration: syntax (in each (template-name, ...) { body }), semantics (expands body into subobjects that instantiate the listed template(s)), support for multiple template names (expansion only in objects that instantiate all listed templates), and that the expansion applies only to subobjects, not the object containing the in each.\n- Override rules for in each: declarations in an in each override the extended template, but declarations in the surrounding scope override the in each\u2014illustrated with a bank/register size default and per-register exceptions.\n- Use of multiple-template in each to change template behavior by context, shown with greeting/field/register examples that select different behaviors for objects depending on instantiation.\n- Global declarations: they must appear at top level (not inside objects or methods) and default to model-wide scope.\n- Import declarations: syntax (import \"filename\";), use of -I compiler flag to set search directories, special handling of relative paths (./ or ../ ignore -I and are relative to the importing file), imported files parsed as separate units with their own language version and bit-order declarations, and version compatibility rules (e.g., DML 1.4 cannot import 1.2, but 1.2 may import 1.4).\n- The document ends as it begins the section on template declarations (3.17.2) but content for that section is not included."
        },
        {
          "title": "Global Declarations",
          "start_index": 47,
          "end_index": 64,
          "nodes": [
            {
              "title": "Import Declarations",
              "start_index": 64,
              "end_index": 48,
              "node_id": "0064",
              "summary": "No partial document text was provided, so no main points can be identified or summarized."
            },
            {
              "title": "Template Declarations",
              "start_index": 48,
              "end_index": 65,
              "node_id": "0065",
              "summary": "Summary of main points in the partial document:\n\n- Templates and namespace: templates must be declared at top level; each template defines a template type sharing the type namespace and name conflicts with other types are illegal.\n\n- Bit order declarations: syntax \"bitorder le|be;\" sets default bit numbering for bit-slices/bit-fields per file (le default). Must appear early in file, does not apply to imported files.\n\n- Constant and parameter declarations: \"constant name = expr;\" defines compile-time constants (parameters are more powerful); constants can be used in typedefs.\n\n- Log groups: \"loggroup name;\" assigns distinct power-of-two values usable in logging and C contexts; at most 63 per device (61 excluding built-ins).\n\n- Typedef and extern typedef: \"typedef\" and \"extern typedef\" define type names; extern typedef assumes corresponding C type exists (no C code generated). Extern structs permit member access but have limited type completeness; nested extern structs can expose members but inner types are not standalone.\n\n- Extern declarations: \"extern declaration;\" declares external C identifiers (variables, arrays, functions) for use from DML; repeated externs must agree on type.\n\n- Header/footer blocks: header %{ ... %} and footer %{ ... %} include verbatim C code into generated header/source; dmlc does not parse contents. DMLC defines a macro for including a companion .h for the DML file. Use sparingly.\n\n- Export declarations: \"export method as name;\" exports a DML method as a C function (external linkage) subject to restrictions (no inline/shared/throwing/multi-return/methods in object arrays). Prefer Simics interfaces over exports when possible.\n\n- Resolution of overrides (ranks and dominance): detailed ranking rules for declarations (file top levels, templates, in-each blocks, imports). Dominance rules determine which declaration wins for parameters and methods; exactly one dominating declaration must exist per set (abstract declarations excluded). Rules about shared/abstract declarations, #if-conditional and unused templates, prohibition of cyclic imports and some illegal self-rank constructs.\n\n- Template conflict resolution and default semantics: how default and overridden implementations interrelate; rules for referring to default implementations and error cases.\n\n- Comparison to C/C++ (DML language model):\n  - Additional built-in types: sized signed/unsigned int types int1..int64, uint1..uint64, and bool (not an integer).\n  - Arithmetic promotions: arithmetic done on 64-bit int (int64) or uint64 if any operand uint64; floating to double. Comparison operators do not convert signed to unsigned like C.\n  - Well-defined behaviors: shifts by >63 bits, shifting negative counts (error), division by zero (error), signed overflow defined modulo 2^64.\n  - Local/session/saved variable storage: local, session, saved keywords; session/saved are per-device persistent-like variables. Tuple syntax for multiple declarations/initializations.\n  - Assignments: assignments are statements (not expressions); chained and tuple simultaneous assignments supported but not chainable; return values use initializer/tuple syntax.\n  - Type and sizeof differences: sizeoftype operator for types; typeof(expr) supported; no unions in DML types (use extern typedef to expose C unions).\n  - Calling C functions from DML requires extern declaration, header inclusion in header block, and a C definition (possibly in footer).\n\n- Method statements and DML-specific statements:\n  - Assignment and tuple assignment semantics, simultaneous target updates.\n  - local/session/saved statements and initializer rules (session/saved initializers must be compile-time constants).\n  - return accepts initializer(s) and supports multiple return values.\n  - delete statement (statement-only) mirrors C++ delete.\n  - try/catch and throw (single, argument-less exception kind); throwing requires method declared throws if not caught.\n  - Method calls: syntax requires destinations for return values; single-return methods may be used in expressions unless inline/throwing; method calls usable as initializers.\n  - Template-qualified method implementation calls: this.templates.<template>.method() invokes particular template-provided implementations; used to resolve conflicts between orthogonal templates and to call overridden implementations even when default cannot be used. Rules for resolution, ambiguities, and shared-method semantics described with examples.\n  - after statements: scheduling future method calls in three forms:\n    - delay form: after <scalar> <unit>: method(...); supports units s, ps, cycles; arguments evaluated and must be serializable for checkpoints.\n    - hook-bound form: after hookref[->(msg components)]: method(...); binds callback to next message sent on hook, allows message component parameters to be passed and relaxes serializability requirement for those components.\n    - general behavior: suspended calls executed at most once, associated with containing object, can be canceled via cancel_after().\n\n- Examples and idioms: multiple examples illustrating header/footer usage, extern typedef for C unions, template composition/resolution patterns (gated/aleter_write/write_1_clears, very_complex_gated_register), and in-each refinements to resolve template conflicts."
            },
            {
              "title": "Bitorder Declarations",
              "start_index": 65,
              "end_index": 48,
              "node_id": "0066",
              "summary": "No partial document text was provided, so no main points can be identified or summarized."
            },
            {
              "title": "Constant Declarations",
              "start_index": 48,
              "end_index": 48,
              "node_id": "0067",
              "summary": "- Templates: may only be declared at top level; each template declaration defines a corresponding template type in the same namespace as other types, so template names must not conflict with existing type names (syntax/semantics described elsewhere).\n\n- Bitorder declarations (bitorder le; or bitorder be;): select default bit numbering for bit-slicing and bit-field declarations. le = little-endian (bit 0 = least significant bit), be = big-endian (bit 0 = most significant bit). A bitorder should appear before other global declarations in a file (immediately after a device declaration if present); its scope is the entire file. Default is le if omitted. Bitorder does not propagate into imported files.\n\n- Constant declarations (constant name = expr;): define named constants where expr must be constant-valued. Parameters are more powerful and typically preferred; the main advantage of constants is that they may be used in typedef declarations.\n\n- Loggroup declarations (loggroup name;): define log groups for use in logging; the identifier is bound to a distinct power-of-two unsigned integer so groups can be combined with bitwise OR. At most 63 log groups per device (61 if excluding built-in Register_Read and Register_Write).\n\n- Typedef declarations (typedef ...; and extern typedef ...;): define type names. The extern form indicates the type exists in the C environment\u2014no C definition is emitted and generated code assumes the type is provided externally."
            },
            {
              "title": "Loggroup Declarations",
              "start_index": 48,
              "end_index": 48,
              "node_id": "0068",
              "summary": "- Templates: only allowed at top level; each template declaration defines a template type in the same namespace as other types, so template names must not conflict with existing type names; full syntax/semantics are referenced as described earlier.\n\n- bitorder declarations (bitorder le; or bitorder be;): choose default bit-numbering for bit-slicing and bit-field declarations \u2014 le means bit 0 is least-significant, be means bit 0 is most-significant; should appear before other global declarations in a file (and immediately after a device declaration if present); scope is the whole file; default is le if absent; bitorder does not propagate into imported files.\n\n- constant declarations (constant name = expr;): define named constants where expr must be constant-valued; parameters are more powerful and usually preferred, but constants can be used in typedef declarations (an advantage over parameters).\n\n- loggroup declarations (loggroup name;): bind an identifier to an unsigned integer that is a distinct power of two for use in logging and C contexts; values are auto-allocated so groups can be combined with bitwise OR; a device may declare up to 63 log groups (61 excluding built-in Register_Read and Register_Write).\n\n- typedef declarations (typedef declaration; and extern typedef declaration;): introduce type names; the extern form indicates the type exists in the C environment so no definition is emitted into generated C code and the code will assume the type is provided externally."
            },
            {
              "title": "Typedef Declarations",
              "start_index": 48,
              "end_index": 49,
              "node_id": "0069",
              "summary": "- Templates: may only be declared at top level; each template defines a template type that shares the same namespace as other types, so template names must not conflict with existing type names.\n\n- bitorder declarations: syntax \"bitorder le;\" or \"bitorder be;\". Selects bit-numbering used for bit-slicing and bit-field declarations (le: bit 0 = least significant; be: bit 0 = most significant). Must appear before other global declarations in a file (but immediately after a device declaration if present). Scope is the whole file; default is le if absent. Bitorder does not apply to imported files.\n\n- Constant declarations: \"constant name = expr;\" defines a named constant where expr must be a constant expression. Parameters are more powerful and usually preferred; constants\u2019 main advantage is that they can be used in typedefs.\n\n- loggroup declarations: \"loggroup name;\" assigns the identifier a distinct power-of-two unsigned value usable in C contexts and combinable with bitwise OR. Limits: at most 63 log groups per device (61 excluding two built-in groups).\n\n- typedef declarations: \"typedef ...\" and \"extern typedef ...\" define type names. Extern typedefs assume the type exists in the C environment and do not generate a C definition; the generated code assumes the given layout. Extern typedefs may not contain a layout or endian-int type.\n\n- Extern struct behaviour: if an extern typedef declares a struct, DMLC assumes a corresponding C type with accessible members via the . operator but makes no assumptions about completeness or size (C type may have extra fields or be a union). Unknown C struct members are initialized to 0. Nested struct definitions in extern typedefs are allowed, but inner struct types cannot be used as standalone types\u2014only their members can be accessed (example given).\n\n- extern declarations: \"extern declaration;\" declares external identifiers like C externs (variables, arrays, functions). Multiple externs for the same identifier are allowed provided they declare the same type.\n\n- header declarations: \"header %{ ... %}\" embeds verbatim C code into the generated C header file. Markers must be \"%{\" and \"%}\" with no whitespace between % and brace. The compiler does not parse the section; any C declarations used must also be declared in DML. This feature is intended for cases (e.g., including C headers) that cannot be handled directly in DML."
            },
            {
              "title": "Extern Declarations",
              "start_index": 49,
              "end_index": 71,
              "node_id": "0070",
              "summary": "- Rules for extern typedefs and extern declarations: how external struct/typedefs map to C (opaque structs allowed), restrictions (no layout/endian int types), and examples of extern identi\ufb01ers and multiple compatible externs.\n- Header and footer blocks: inclusion of verbatim C code into generated headers/source, macro DMLDIR_* for companion headers, placement, and cautions about include paths and usage.\n- export declarations: exporting DML methods as C functions (limitations, signature format, use cases, and suggestion to use Simics interfaces instead).\n- Resolution of overrides: detailed rank system for declarations (file/top-level, templates, in each, imports), dominance rules for params/methods, restrictions on abstract declarations, conflict rules, and how default and default(...) are resolved.\n- Comparison to C/C++: DML-specific types (int1..int64, uint1..uint64, bool), arithmetic and promotion differences (64-bit promotion rules, floating-point as double), defined behavior for shifts/division/overflow, typeof support, and differences in sizeof/casts and boolean conditions.\n- Variable storage classes and declaration syntax: local/session/saved semantics (per-object static-like storage), tuple syntax for multi-declarations/initialization, and compile-time constraints for session/saved initializers.\n- Interoperability with C functions: three-step process (extern declaration, header declaration, definition in C/header/footer), example Makefile layout.\n- Method semantics and statements: assignment forms (chained and tuple simultaneous), local/session/saved declarations, return semantics (tuple returns and propagation), delete, try/catch/throw (single exception type), and restrictions on expressions that call throwing or multi-return methods.\n- Template-qualified method implementation calls: this.templates usage to invoke specific template-provided implementations, resolution rules, ambiguity handling, and examples for composing or choosing implementations to reconcile template conflicts.\n- after statements (callbacks): three forms\u2014delay (time units), hook-bound (bound to next hook message with message-component parameters), and immediate (execute after current execution returns to simulator); argument evaluation, serialization requirements, semantics, and use-cases (avoiding synchronous reentrancy).\n- Logging, assertions, and diagnostics: log statement syntax, log-types/levels/groups and grouping via loggroup, assert and compile-time/error statements, and error message formation.\n- Control-flow and compile-time constructs: foreach/#foreach, select/#select (note #select-only in current version), and #if/#else compile-time conditional processing.\n- Expressions: the undefined compile-time constant, member/reference semantics in the DML object hierarchy, and which object references are proper runtime values versus compile-time-only constructs."
            },
            {
              "title": "Header Declarations",
              "start_index": 71,
              "end_index": 50,
              "node_id": "0071",
              "summary": "The partial document contains no text (only blank/whitespace), so no main points or topics can be identified."
            },
            {
              "title": "Footer Declarations",
              "start_index": 50,
              "end_index": 73,
              "node_id": "0072",
              "summary": "- Header/footer blocks: header %{...%} is verbatim C included in generated C files; DMLC defines a companion-header macro (DMLDIR_<NAME>_H) to allow including a .h next to the .dml without -I; only one such macro per header block and it is undefined after the header. footer %{...%} inserts verbatim C at the end of generated code. Use these sparingly.\n\n- Export declarations: export method as \"name\"; exposes a DML method as a C function (external linkage) with signature void name(conf_object_t *obj, ...). Many methods (inline, shared, throwing, multi-return, in arrays) cannot be exported.\n\n- Resolution of overrides (ranks and dominance): each declaration has a rank (file top level, templates, in/each blocks, imports, etc.), forming a partial order. For a set of param/method declarations there must be exactly one dominating declaration (highest rank). Abstract declarations cannot dominate. Rules restrict number of abstract typed declarations and shared declarations. Cyclic constructs (self-higher-rank, cyclic imports) are forbidden. If a dominating decl exists, default within an overriding method refers to the next-highest implementation as specified.\n\n- Comparison to C/C++: DML uses a C-like algorithmic language with extensions and differences:\n  - Built-in types: fixed-width ints int1..int64, uint1..uint64, and bool (not an integer).\n  - Arithmetic promotions: arithmetic uses 64-bit signed (int64) unless uint64 present; floating ops use double. No unsigned-promotion surprises; comparisons use signed semantics unless uint64 involved.\n  - Well-defined behavior for shifts (large shifts yield 0 or -1), division by zero is an error, and signed overflow is defined as modulo 2^64.\n  - Local variables require local/session/saved keywords; session/saved act like per-object statics. Tuple syntax supports multi-declarations and initializers.\n  - C interop: extern declarations in DML, plus header/footer content to let generated C compile/link with external functions.\n  - Casts use cast(expr, type); sizeof on types uses sizeoftype; logical/comparison results are bool; throw/delete are statements only; unions must be exposed via header typedefs and extern typedefs.\n\n- Statements added/specialized in DML:\n  - Assignment: chained (a = b = init;) and tuple simultaneous assignment ( (a,b) = (..); ) with simultaneous update semantics.\n  - local/session/saved declarations with initializer rules (session/saved initializers must be compile-time constants).\n  - return uses initializers and supports tuple returns and return propagation.\n  - delete (statement only), try/catch (single exception kind), throw (no value), and method-call restrictions for throwing/multi-return methods.\n  - template-qualified method implementation calls via this.templates.T.m() to invoke a specific template\u2019s implementation; resolution rules and examples show how to combine or select implementations and how in each can be used to resolve conflicts.\n  - after statements (scheduling callbacks) with three forms:\n    - after delay (after scalar unit: ...): schedule at simulated time; arguments must be serializable.\n    - after hook-bound (after hookref -> (...): ...): run when hook message sent; message components can be bound to arguments.\n    - immediate after (after: ...): execute when control returns to simulator (FIFO per-object); arguments evaluated and non-serializable pointers allowed (but must not be stack pointers).\n  - log statements: log-type (info/warning/error/critical/spec_viol/unimpl), optional level (1\u20134) and subsequent-level, groups bitmask; format string semantics.\n  - assert, error statements.\n\n- Control-flow and compile-time constructs:\n  - foreach and #foreach (compile-time unrolled) and select/#select (compile-time selective form only currently).\n  - #if/#else are compile-time conditional blocks.\n\n- Expressions and extras:\n  - undefined constant (compile-time only) and defined expr test.\n  - References: many DML object references are not proper runtime values; only certain contexts allow them. Arrays and object references have special rules regarding proper values and unknown indices.\n  - Method references via &method produce C-like function pointers (restricted set of methods).\n  - new type[/count] allocates memory (non-null), delete frees it.\n  - cast(expr, type) for casts; sizeoftype type for sizeof on types.\n  - each-in expressions to iterate over all objects implementing a template (useful for generic hooks like global resets)."
            },
            {
              "title": "Export Declarations",
              "start_index": 73,
              "end_index": 51,
              "node_id": "0073",
              "summary": "The provided partial document is empty or contains no visible text, so no main points or topics can be identified."
            }
          ],
          "node_id": "0063",
          "summary": "- Template and \"in each\" behavior: how in each blocks expand only in subobjects and can map multiple template names to different implementations; examples showing template composition and using in each to resolve orthogonal-template conflicts.\n- Import rules: import \"file\"; search paths (-I), relative path handling, and that imported files are parsed separately with their own language version and bitorder (no cyclic imports).\n- Top-level global declarations (scope = whole model unless noted): templates, bitorder, constants, parameters vs constants, loggroup, typedef/extern typedef (including extern struct and nested structs), extern declarations, header/footer verbatim C inclusion (with companion-header macro mechanism), footer, and export method as name (C linkage and signature rules; limitations on what can be exported).\n- bitorder declaration: le/be semantics, placement rules, file-local scope, and interaction with imported files.\n- loggroup semantics: allocated as distinct powers of two, limit per device.\n- Extern typedef details: assumptions about corresponding C types, accessing members, opaque structs, and limitations on inner struct usage.\n- Resolution of overrides: ranking system for declarations (top level, templates, in each blocks, object/subobject ranks) and dominance rules; constraints on abstract declarations, shared method rules, requirement of exactly one dominating declaration for a set, examples of illegal/ambiguous declarations, and how default refers to lower-rank implementations.\n- Template-qualified method implementation calls: syntax (obj.templates.T.m()), resolution rules (searching ancestor templates, ambiguity errors), use cases (calling specific template implementations to combine or pick behaviors), and examples for combining gated/altering writes and complex register gating.\n- Comparison to C/C++: DML as C-like with extensions and deviations:\n  - Built-in fixed-width integer types int1..int64, uint1..uint64, and bool; typeof support.\n  - Arithmetic promotions: integer arithmetic promoted to int64 (or uint64 if any operand is uint64), floating to double; defined signed overflow (two's complement), shift semantics, division-by-zero error.\n  - Comparison and logical operators produce bool; no implicit int-to-bool conversions.\n  - sizeof vs sizeoftype usage.\n  - Tuple syntax for multiple declarations/assignments and simultaneous updates; local/session/saved storage classes (session/saved act like per-device statics).\n  - C interop process: declare extern in DML, provide declaration in header block, provide definition in C or footer.\n  - Limitations: unions not allowed in DML types (workaround via extern typedef/header); delete and throw only statements.\n- Method statements and language constructs added to C:\n  - Assignment forms: chaining and tuple multiple-assignment; initializers allowed.\n  - local, session, saved declarations: initializer rules (session/saved initializers must be compile-time constants).\n  - return with initializer(s) including tuple returns and propagating method returns.\n  - delete statement, try-catch (single exception type), throw statement, and rules about throws propagating over calls.\n  - Method call syntax: required assignment destinations for multi-return methods; single-return methods usable in expressions (with exceptions); method calls as initializers.\n  - Template-qualified calls and semantics inside shared methods and on template-type values (rules about shared implementations).\n  - after statements for scheduling deferred method calls (associated with object, cancellable via cancel_after()); three forms distinguished by prefix\u2014detailed after delay form supporting time units s, ps, cycles and types."
        },
        {
          "title": "Resolution of overrides",
          "start_index": 51,
          "end_index": 53,
          "node_id": "0074",
          "summary": "- Exporting DML methods to C: shows how a DML method can be exported as a C function (example: method my_method(int x) exported as \"my_c_function\" yields signature void my_c_function(conf_object_t *obj, int x);), and notes that the conf_object_t *obj parameter represents the device instance and is omitted for independent methods.\n\n- Resolution of overrides (ranks and dominance): defines a partial order of ranks assigned to every declaration (top-level file, template definitions, blocks inside declarations, in-each blocks, etc.), explains how ranks propagate (subobjects inherit the rank of their containing object, templates used in declarations give higher rank, imports give higher rank to importing file), and states transitivity and non-self dominance.\n\n- Dominance rules for params and methods: explains that among declarations of the same parameter or method there must be exactly one dominating declaration (higher rank than all others), and abstract declarations (untyped params, typed abstract params, abstract methods) cannot dominate.\n\n- Limits on abstract declarations and shared methods: allows any number of untyped abstract params, at most one typed abstract param, and at most one abstract shared method; non-shared definitions may appear at any rank but shared definitions must obey rank rules. Examples illustrate legal and error cases.\n\n- Rules about default and default resolution: if a non-default method/param exists it must dominate the set; when a dominating declaration Dn implements a method, the keyword default inside Dn refers to the implementation of the next-dominating declaration Dk (if present), otherwise default is illegal.\n\n- Special cases and exclusions: declarations disabled by #if or templates that are never instantiated are excluded from the set of declarations for dominance checks, but shared method declarations in templates are always considered (even if templates are unused). Cyclic imports and constructs giving an object higher rank than itself are forbidden. Duplicate top-level object declarations in the same file have equal rank and can conflict.\n\n- Comparison to C/C++: DML method bodies use an algorithmic language based on an extended subset of ISO C with some C++ features (new/delete); DML adds fixed-width integer types int1..int64 and uint1..uint64, a bool type (not an integer), and supports typeof(expr). DML semantics differ from C in that integer arithmetic is performed on 64-bit values (with truncation on assignment), floating-point on double, and int is an alias of int32."
        },
        {
          "title": "Comparison to C/C++",
          "start_index": 53,
          "end_index": 56,
          "node_id": "0075",
          "summary": "- Small DML code fragment showing a template with a conditional group declaration (template T { #if (p) { group g is T { param p = false; } } } ).\n- Rule: cyclic imports are prohibited.\n- Top-level duplicate declarations in the same file get the same rank and thus conflict if neither dominates the other; example with two bank/register/p declarations (param p default 3 vs param p = 4) illustrating a conflict.\n- Section 3.19 compares DML\u2019s algorithmic language to C/C++: it is an extended subset of ISO C with some C++ features (e.g., new/delete) and DML-specific statements/expressions defined elsewhere.\n- Additional built-in types in DML: fixed-width signed/unsigned integers int1..int64, uint1..uint64, and bool; typeof(expr) is supported (GCC-style).\n- Key semantic deviations from C:\n  - Integer arithmetic is performed on 64-bit integers and truncated on assignment; floating arithmetic uses double.\n  - Promotion rules: if either operand is uint64 \u2192 both promoted to uint64; otherwise both promoted to int64; floating operand \u2192 double.\n  - Comparisons do not promote signed to unsigned (example: val > x with uint64 and negative int32 behaves differently than in C).\n  - Shifts: shifting by >63 bits yields zero (or -1 for negative left operand); shifting by a negative count is an error.\n  - Division by zero is an error.\n  - Signed overflow is well-defined modulo 2^64 (two\u2019s complement semantics).\n- Variable storage qualifiers: local, session, saved required for local variables; session/saved behave like static but are per-device-instance.\n- Tuple syntax for multiple declarations/initializations (e.g., local (int n, bool b) = (0, true);).\n- Interfacing with C:\n  - To call a C function from DML: declare it extern in DML, provide a C header declaration in the header section, and ensure a function definition exists in C source or footer.\n  - Example showing foo.c, foo.h, and bar.dml with header/footer usage.\n- Assignment rules:\n  - Assignments are separate statements; chained assignment disallowed except simple i = j = 0; tuple assignments allowed (e.g., (i, j) = (j, i)) but cannot be chained.\n  - Calls to methods that throw or have multiple return values must be standalone statements; multiple return values must be captured (method divmod example).\n- Syntax/semantic differences vs C:\n  - Type casts use cast(expr, type).\n  - Comparison/logical operators return bool; conditionals require booleans (no implicit int-to-bool).\n  - sizeof only on lvalue expressions; sizeoftype used for types.\n  - Comma-expressions only permitted in for-loop heads.\n  - delete and throw are statements only; throw takes no argument; catch cannot discriminate by exception type/value.\n- Type-system note: union is not allowed in DML type declarations, but extern typedef can be used to expose C unions to DML (example alluded to)."
        },
        {
          "title": "Method Statements",
          "start_index": 56,
          "end_index": 57,
          "nodes": [
            {
              "title": "Assignment Statements",
              "start_index": 57,
              "end_index": 57,
              "node_id": "0077",
              "summary": "The partial document covers:\n- An example of interoperable type declarations: showing a header using a union typedef and an extern typedef using a struct with the same name (u_t). It explains that presenting u_t as a struct to DML is acceptable because C union and struct syntax are identical for generated C code, so code using u_t remains compatible.\n- Section 3.20 (Method Statements) overview: states that all ISO C statements are supported in DML with the same semantics, and DML expressions can be used as expression-statements.\n- DML-specific additions, in particular 3.20.1 Assignment Statements:\n  - Two syntaxes: chained assignment (target1 [= target2 = ...] = initializer;) and multiple simultaneous assignment ((target1, target2, ...) = initializer;).\n  - Assignments are not expressions in DML; the right-hand side may be any initializer, including compound initializers for struct-like types.\n  - Behavior: chained assignments execute the initializer once and assign that single value to each target; simultaneous assignment takes an initializer describing one value per target, either via tuple syntax (e.g., (a, i) = (false, 4);) or via a method call returning multiple values (e.g., (a, i) = m(); where m() -> (bool, int)).\n  - Targets in simultaneous assignment are updated simultaneously, enabling patterns like swapping: (a, b) = (b, a).\n- The document begins 3.20.2 Local Statements but the content of that subsection is not included in the partial text."
            },
            {
              "title": "Local Statements",
              "start_index": 57,
              "end_index": 58,
              "node_id": "0078",
              "summary": "- Header/type note\n  - Shows a trick: declaring a union in a header with one name and an extern typedef struct with the same name so DML treats the type like a struct while generated C code (where union/struct syntax can be identical) still inter-operates correctly.\n\n- General statement semantics\n  - All ISO C statements are available in DML with the same semantics.\n  - DML expressions can be used as expression-statements.\n\n- New/extended DML statements (overview)\n  - Assignment statements\n    - Two forms: chained assignment (target1 [= target2 = ...] = initializer) and multiple simultaneous assignment ((target1, target2, ...) = initializer).\n    - Right-hand side can be any initializer (including compound initializers for struct-like types).\n    - Assignments are not expressions (unlike C).\n    - Chained form evaluates the initializer once and assigns that value to each target.\n    - Tuple form provides one value per target (via tuple initializer or a method call returning multiple values); targets are updated simultaneously (enables swaps like (a, b) = (b, a)).\n  - Local declarations\n    - Syntax: local type identifier [= initializer] or local (type1 id1, type2 id2, ...) [= initializer].\n    - Initializers may be tuple forms or method-call return values; if omitted, objects get a default all-zero initializer.\n    - Compound initializers are allowed.\n  - Session declarations\n    - session type identifier [= initializer] or session (type1 id1, ...) [= (init1, ...)].\n    - Session variable initializers are evaluated once when initializing the device and therefore must be compile-time constants.\n  - Saved declarations\n    - saved type identifier [= initializer] or saved (type1 id1, ...) [= (init1, ...)].\n    - Like session variables, saved-variable initializers are evaluated once at device initialization and must be compile-time constants.\n  - Return statements\n    - return [initializer];\n    - The return argument is an initializer (not a general expression), so return values of struct-like types can be constructed with compound initializers."
            },
            {
              "title": "Session Statements",
              "start_index": 58,
              "end_index": 58,
              "node_id": "0079",
              "summary": "Summary of main points in the partial document:\n\n- Variable declaration forms:\n  - local declarations: \"local type identifier [= initializer];\" and tuple form \"local (type1 id1, type2 id2, ...) [= initializer];\" to declare one or multiple local variables in the current scope.\n  - tuple initializers and compound initializers ({...}) are allowed.\n  - The initializer must supply the exact number of values required and the values must be type-compatible.\n  - If no initializer is provided, a default \"all zero\" initializer is applied.\n\n- Multiple-value initialization:\n  - Provide an initializer tuple for each variable, e.g. \"local (bool a, int i) = (false, 4);\"\n  - Or initialize multiple locals from a method call that returns multiple values, e.g. \"local (bool a, int i) = m();\" where m() -> (bool, int).\n\n- Session variables:\n  - session declarations: \"session type identifier [= initializer];\" and tuple form for multiple session variables.\n  - Initializers for session variables are evaluated once at device initialization and therefore must be compile-time constants.\n\n- Saved variables:\n  - saved declarations: \"saved type identifier [= initializer];\" and tuple form for multiple saved variables.\n  - Like session initializers, saved initializers are evaluated once at device initialization and must be compile-time constants.\n\n- Return statements:\n  - return [initializer]; returns from a method using an initializer as the argument.\n  - Return arguments are initializers (not arbitrary expressions), so compound/struct-like return values can be constructed with {...}."
            },
            {
              "title": "Saved Statements",
              "start_index": 58,
              "end_index": 80,
              "node_id": "0080",
              "summary": "Summary of main points in the partial document:\n\n- Variable declarations\n  - local, session, saved: syntax for single or multiple declarations with optional initializers; initializer rules (exact number, compatible types); default zero initializer for locals; session/saved initializers must be compile-time constants.\n\n- Control-flow and resource statements\n  - return: initializer-based return values (tuples or propagated method returns).\n  - delete: deallocate memory allocated with new (statement-only).\n  - try / catch and throw: single-exception model; throw is a statement with no value; uncaught exceptions must be declared with throws.\n  - assert: runtime boolean assertion.\n  - error: compile-time error statement with optional message.\n\n- Method calls and references\n  - Method call syntax requires destinations matching return arity; single-return methods usable in expressions (with exceptions); method calls usable as initializers.\n  - Method references: &method yields a C-style function pointer (limitations apply).\n  - Template-qualified method-implementation calls: this.templates.T.m() invokes the implementation provided by a named template; used to reference overridden implementations, resolve conflicts when multiple templates apply, and combine or wrap implementations. Resolution rules for missing or ambiguous implementations and special behavior for value/template-type calls are described.\n\n- After (deferred callback) statements\n  - after ...: method(...) schedules a one-shot callback associated with the current object; callbacks can be cancelled via cancel_after().\n  - Forms:\n    - after <delay> <unit>: schedule after simulated time (units s, ps, cycles); arguments must be serializable.\n    - after <hookref>[->(msg...)] : bind callback to next message on a hook; message components can be forwarded to callback; non-bound args must be serializable.\n    - after: immediate callback when control returns to the simulation engine (FIFO per device); arguments evaluated and not required to be serializable (but must not be pointers to stack-allocated data).\n  - Use-cases and cautions (e.g., avoiding synchronous reentrancy bugs).\n\n- Logging\n  - log statements: syntax includes log-type (info/warning/error/critical/spec_viol/unimpl), optional level (1\u20134) and groups (bitmask); format-string and args like printf; groups defined by loggroup declarations; semantics of levels and subsequent-level.\n\n- Iteration and conditional compile-time constructs\n  - foreach: runtime iteration over sequences (Each-In expressions), continue/break supported.\n  - #foreach: compile-time unrolled loop over compile-time list constants.\n  - select / #select: select first element matching a condition (note: runtime select currently removed; only #select available).\n  - #if / #else: compile-time conditional processing.\n\n- Expressions (extensions and restrictions beyond C)\n  - undefined: compile-time abstract value used for optional parameters and defined tests.\n  - References: member selection with . and ->; distinction between proper values and compile-time-only references; rules for object-array indices and contexts where non-values are allowed.\n  - new: dynamic allocation (new type or new type[count]); paired with delete.\n  - cast(expr, type) and sizeoftype type (instead of C-style sizeof on types).\n  - defined expr: compile-time test for undefined.\n  - each-in expr: iterate over objects implementing a template (sequence(template-name)); recursion and ordering notes.\n  - List expressions: compile-time lists [e1,...] and allowed contexts.\n  - .len expressions: length of list/sequence/object-array/value-array (constant except for sequence).\n  - Bit-slicing: expr[e1:e2] or expr[e1] with optional bitorder (be/le); semantics of indices and endianness rules; usable as L-value.\n  - stringify(expr): turn a compile-time constant into a string.\n  - String concatenation at compile time with + when both operands are compile-time string constants.\n  - Compile-time conditional expression condition #? expr1 #: expr2.\n\n- Libraries and built-ins / templates overview\n  - Most functionality implemented as templates; templates can (1) be instantiated for object types, (2) provide standard behavior, or (3) define interfaces (abstract/overrideable members).\n  - Guidance on overriding methods/parameters: instantiate/override the appropriate template (prefer more specific templates for efficiency and flexibility).\n  - Examples illustrating combining template behaviors and conflict resolution patterns.\n\n- Universal (common) templates and the object base\n  - name, desc, shown_desc, documentation, shown_documentation, limitations, shown_limitations: standard descriptive parameters and visibility controls.\n  - init, post_init, destroy: lifecycle methods automatically called for objects that implement these templates (ordering guarantees and usage caveats, esp. in destroy()).\n  - object template: base for all objects; provides this, objtype, parent, qname, dev, templates, indices, index parameters, and the cancel_after() method; notes on which parameters are non-overridable and how object-scoped methods behave."
            },
            {
              "title": "Return Statements",
              "start_index": 80,
              "end_index": 58,
              "node_id": "0081",
              "summary": "The provided partial document contains no text or substantive content, so no main points or topics can be identified."
            },
            {
              "title": "Delete Statements",
              "start_index": 58,
              "end_index": 83,
              "node_id": "0082",
              "summary": "This partial document is a reference guide for DML (Device Modeling Language) covering language constructs, semantics, and built-in templates. Main points:\n\n- Variable and declaration statements\n  - local, session, saved declarations with initializer rules (tuple and multi-return initializers; default zero-initializer; session/saved initializers must be compile-time constants).\n\n- Control-flow and housekeeping statements\n  - return (initializer-based, supports tuple and propagated returns), delete (C++-like deallocation, statement-only), try/catch and throw (single exception kind; throw is statement-only; methods that propagate exceptions must be declared throws).\n\n- Method calls and return-value handling\n  - Calling methods with multiple return values requires L-value destinations; single-return methods may be used in expressions except when inline or throwing; method calls usable as initializers.\n\n- Template-qualified method implementation calls\n  - Using .templates.name.method to invoke a specific template-provided implementation; resolution rules, ambiguity handling, behavior differences for template-typed values and shared methods; examples showing strategies for combining or choosing implementations and resolving conflicts with in each declarations.\n\n- After statements (deferred callbacks)\n  - General semantics (one-shot, associated with object, cancellable via cancel_after()) and three forms:\n    - Delay form: after <scalar> <unit>: method(...); (time units s/ps/cycles; arguments must be serializable).\n    - Hook-bound form: after hookref[->(...)] : method(...); (binds to next hook message; message component parameters pass through).\n    - Immediate form: after: method(...); (executes when control returns to simulator; FIFO per device; allows non-serializable args but warns about pointers to stack-allocated data).\n  - Usage notes and examples illustrating race/ordering avoidance.\n\n- Logging and diagnostics\n  - log statement syntax, log-type categories (info, warning, error, critical, spec_viol, unimpl), verbosity levels (1\u20134), optional subsequent-level, device-specific log groups and bitmasking, format-string rules.\n\n- Assertions and compile-time errors\n  - assert expr; and error [string]; for runtime checks and compile-time forced errors.\n\n- Iteration and selection constructs\n  - foreach (runtime) and #foreach (compile-time unrolled) over sequences/lists; continue and break.\n  - select and #select for selecting the first matching element (note: select temporarily removed; only #select supported).\n  - #if/#else compile-time conditional processing.\n\n- Expressions and special operators\n  - Overview: most ISO C operators available (with some limitations).\n  - Added/unique expressions:\n    - undefined constant and defined expr compile-time test.\n    - References (. and ->) and rules about \"proper values\" vs. object references.\n    - Method references as function pointers using &method and calling conventions (conf_object_t *).\n    - new expressions and memory allocation; delete usage.\n    - cast(expr, type) and sizeoftype type (sizeof-for-types).\n    - each-in expressions to iterate objects implementing a template (sequence(template-name)), deterministic order but not defined ordering semantics.\n    - Lists and list.len, sequence/object/value-array length expressions.\n    - Bit-slicing syntax expr[e1:e2[, bitorder]] and rules for bit numbering (be/le), allowed operands, and undefined behavior on invalid ranges.\n    - stringify(expr), string concatenation via + for compile-time strings, and compile-time conditional expression condition #? a #: b.\n\n- Libraries, built-ins, and standard templates\n  - Description of template categories: per-object-type templates, behavior-providing templates, and interface templates that expose methods/parameters.\n  - Universal templates and common facilities:\n    - name, desc/shown_desc, documentation/shown_documentation, limitations/shown_limitations.\n    - init, post_init, destroy lifecycle methods and ordering notes (and cautions about not interacting with simulator while destroying).\n    - object base template (this, objtype, parent, qname, dev, templates, indices) and cancel_after() method.\n  - Device template: device-level parameters (classname, register_size, byte_order, be_bitorder, use_io_memory, obj pointer, simics_api_version) and lifecycle methods.\n  - Group objects: container semantics and naming caveats (avoid group names \"bank\"/\"port\").\n  - Attribute objects and attribute templates:\n    - attribute methods (get/set and related Simics entry points), parameters (type, configuration, persistent, readable/writable, internal) and behaviors.\n    - Standard attribute templates (bool_attr, int64_attr, uint64_attr, double_attr) and pseudo/readonly/writeonly attribute templates.\n  - Connect template: validate and set methods for connection assignment, and configuration parameter behavior.\n\n- Practical constraints and examples\n  - Numerous illustrative examples throughout (method-call returns, template resolution patterns, after usage, FSM race avoidance, bit-slicing, #foreach/#if usage) and explicit rules about serializability, shared/inline/throwing method limitations, and compile-time vs runtime evaluation.\n\nOverall, the fragment documents DML statement syntax and semantics, expression extensions, deferred-callback mechanisms, logging and diagnostics, compile-time constructs, and a set of built-in templates and object types with their methods and parameters."
            },
            {
              "title": "Try Statements",
              "start_index": 83,
              "end_index": 59,
              "node_id": "0083",
              "summary": "No partial document text was provided, so the main points cannot be identified."
            },
            {
              "title": "Throw Statements",
              "start_index": 59,
              "end_index": 59,
              "node_id": "0084",
              "summary": "- Return-value initializers must supply exactly the number of values the method returns and each must be type-compatible.\n- Multiple return values can be provided by tuple syntax (e.g., return (false, 4);) or by propagating a called method\u2019s returns (e.g., return m();).\n- Delete statements: syntax \"delete expr;\". Deallocates memory previously allocated with new, must not be double-deallocated, equivalent to C++ delete but usable only as a statement (not an expression).\n- Try statements: syntax \"try protected-stmt catch handle-stmt\". Execute the protected block; on exception execute the handler. DML has a single exception kind; Simics C-exceptions are not handled.\n- Throw statements: syntax \"throw;\". Raises an exception (no throwable value can be specified) and is a statement, not an expression. \n- If an exception is not caught inside a method, the method must be declared as throws and the exception propagates across the method call boundary.\n- Method calls: syntax \"(d1, ... dM) = method(e1, ... eN);\". Calls resemble C functions but require assignment destinations matching the method\u2019s number of return values; inputs are e1...eN and outputs are assigned to d1...dM."
            },
            {
              "title": "Method Calls",
              "start_index": 59,
              "end_index": 60,
              "node_id": "0085",
              "summary": "- Rules for initializing multiple return values: initializer must supply the exact number and compatible types; you can use tuple syntax (e.g., return (false, 4)) or propagate a method call\u2019s returns (return m()).\n- delete statement: syntax delete expr; deallocates memory allocated by new, must not be double-freed; equivalent to C++ delete but only a statement (not an expression) in DML.\n- try/catch: try protected-stmt catch handle-stmt executes protected-stmt and runs handle-stmt on exceptional completion; DML has a single exception kind (Simics C-exceptions not handled).\n- throw statement: throw; raises an exception (no throwable value can be specified) and is a statement, not an expression; uncaught exceptions require the method to be declared throws to propagate across calls.\n- Method call forms:\n  - Assignment of multiple returns: (d1, ... dM) = method(e1, ... eN); destinations must be L-values with matching types (variables, bit slices allowed).\n  - No-return methods: call as p(...);\n  - Single-return methods: can be used inside expressions unless the method is inline or can throw.\n  - Method calls (even throwing or multi-return) can be used as initializers in assignments, local declarations, and return statements (e.g., local (int i, uint8 j) = m(e1); return m(e1)).\n- Template-qualified method implementation calls: every object and template type exposes a templates member that lets you invoke a specific template\u2019s implementation of an object\u2019s method (i.e., call particular implementations rather than only the final overriding one)."
            },
            {
              "title": "Template-Qualified Method Implementation Calls",
              "start_index": 60,
              "end_index": 60,
              "node_id": "0086",
              "summary": "- Method call destinations can be any L-values (typically variables, even bit slices) as long as their types match the method signature.\n- A method with no return value is called as a standalone statement, e.g. p(...);\n- A method with exactly one return value may be used in any expression, except when the method is inline or can throw exceptions (example: method m() -> (int) used in an arithmetic or conditional expression).\n- A method call (including throwing methods or methods with multiple return values) may be used as an initializer wherever non-constant initializers are allowed: assignment statements, local variable declarations, and return statements (examples: local (int i, uint8 j) = m(e1); and return m(e1) to propagate all return values).\n- Template-qualified method implementation calls: every object and template type exposes a templates member that lets code invoke a particular implementation of an object's method as provided by a specified template instantiation (i.e., call a specific implementation rather than only the final overriding implementation). The document begins to describe how such template-qualified calls are made."
            },
            {
              "title": "After Statements",
              "start_index": 60,
              "end_index": 87,
              "nodes": [
                {
                  "title": "After Delay Statements",
                  "start_index": 87,
                  "end_index": 89,
                  "node_id": "0088",
                  "summary": "- Bank parameters and constraints\n  - A parameter must have the same value for all elements of a bank array (must not depend on the bank index).\n  - be_bitorder [bool]: presentation hint controlling preferred bit ordering for registers in the bank (false = bit0 is LSB; true = bit0 is MSB). It does not affect model behavior and is independent of top-level bitorder (though they normally match).\n  - use_io_memory [bool]: selects the exposure/interface for the bank:\n    - true \u2192 legacy io_memory interface (io_memory_access can be overridden; transaction_access cannot).\n    - false \u2192 transaction interface (transaction_access can be overridden; io_memory_access cannot).\n    - default inherited from dev.use_io_memory.\n  - obj [conf_object_t *]: resolves to dev.obj under Simics API 5 or earlier, or to the bank\u2019s port object under API 6+.\n\n- Register objects (template inheritance and parameters)\n  - Inherits templates: object, get, set, shown_desc, read_register, write_register, init_val.\n  - Key parameters:\n    - val [integer]: register contents (direct writes can be unsafe if value exceeds capacity; preferred to use get_val/set_val).\n    - size [integer]: register width in bytes (default from containing bank.register_size). Short-hand \"size n\" allowed.\n    - bitsize [integer]: width in bits (size * 8; cannot be overridden).\n    - offset [integer]: byte offset within the containing bank; can use \"@ n\" shorthand; no default; must be same across bank array elements; if inheriting unmapped template then register is not mapped.\n    - fields [list of references]: references to all field objects of the register.\n    - init_val [integer]: default init value for device instantiation and resets (default 0).\n    - configuration: \"required\" | \"optional\" | \"pseudo\" | \"none\" (controls how Simics treats the auto-created attribute; default \"optional\").\n    - persistent [bool], internal [bool] (internal defaults to true).\n  - Overridable methods for handling bits not covered by fields:\n    - read_unmapped_bits(uint64 unmapped_enabled_bits, void *aux) -> uint64: default masks register by unmapped_enabled_bits and returns; used by default read_register.\n    - write_unmapped_bits(uint64 val, uint64 enabled_bits, void *aux): called by default write_register when some bytes are not fully covered by fields; default compares unmapped enabled bits between value and register and logs spec-viol messages for mismatches without modifying val.\n\n- Field objects\n  - Inherits: object, init_val, shown_desc; methods get, set, init and parameter init_val.\n  - Parameters:\n    - val [integer]: bitslice of the parent register corresponding to the field (manipulating val is safe but val is not a template member).\n    - reg [reference]: reference to containing register.\n    - lsb [integer], msb [integer]: required; bit indices in the containing register expressed in little-endian bit numbering (lsb = least significant bit index). Preferred to use \"[highbit:lowbit]\" shorthand, note caution when mixing with big-endian bit numbering\u2014put such code in a file that uses little-endian interpretation.\n    - bitsize [integer]: derived from lsb and msb; cannot be overridden.\n    - init_val [integer]: default 0 for init and reset.\n  \n- Templates for registers and fields\n  - Many templates apply to both registers and fields (except read_register and write_register). When writing templates for both, normally inherit read, write, get, and set methods.\n  - Methods may accept void *aux (default NULL) to carry extra access information; aux can be set by overriding the parent bank\u2019s io_memory_access.\n  - get_val: non-overrideable method returning the raw value (.val in registers or the corresponding bits in parent register for fields). It is similar to get but unaffected by get overrides (slightly more efficient, less flexible); generally prefer get.\n  - set_val: non-overrideable method that sets the .val in registers or the covered bits in the parent register for fields."
                },
                {
                  "title": "Hook-Bound After Statements",
                  "start_index": 89,
                  "end_index": 66,
                  "node_id": "0089",
                  "summary": "A single-line instruction telling the reader to produce a description of the partial document and to output that description only, with no additional text."
                },
                {
                  "title": "Immediate After Statements",
                  "start_index": 66,
                  "end_index": 68,
                  "node_id": "0090",
                  "summary": "- Hook/message binding syntax: shorthand forms (-> msg for single component, omission for none) and rules that message component parameters can be reused any number of times but only as direct arguments; shows a valid and an invalid example illustrating that parameters cannot be used in non-direct ways.\n\n- after statement variants: introduces an immediate after form (after: method(e1,...,eN);) and explains when the callback is scheduled \u2014 when control returns to the simulation engine and current device call-stack entries are completed.\n\n- Purpose and semantics of immediate after: used to avoid ordering bugs by delaying method calls until the device is in a consistent state; compares immediate after to after 0 cycles: ... and explains advantages (not bound to device clock, avoids callbacks being starved when processor progresses, registers work when simulation is stopped).\n\n- Execution ordering: within a device instance, immediate-after-suspended calls use FIFO (least-recently-suspended first); ordering across device instances is undefined.\n\n- Argument evaluation and safety: immediate after evaluates and stores all method arguments at scheduling time; arguments need not be serializable (pointers are allowed) but pointers to stack-allocated data must never be passed because the stack is not preserved. DML compiler gives some warnings but cannot catch all cases; modeller responsibility.\n\n- Practical example: a device FSM that requests permission from a manager and the subtle bug when the manager responds synchronously; shows how using immediate after to call the acknowledgement handler ensures correct sequencing without changing FSM state-update order.\n\n- log statements syntax and behavior: form (log log-type[, level [ then subsequent-level ] [, groups] ]: format-string, e1, ..., eN;), printf-like formatting, and automatic prefixing of device/name/type.\n\n- Log configuration and properties: three main match properties (log-type, level, groups); allowed log-type identifiers (info, warning, error, critical, spec_viol, unimpl).\n\n- Log levels meaning and constraints: levels 1\u20134 described (importance/verbosity), default level 1, later subsequent-level option to change level for following logs (can be 5 to suppress further logging); restrictions on level and subsequent-level when log-type is warning/error/critical.\n\n- Log groups: integer bitmask selecting device-specific groups (declared via loggroup); default groups value 0."
                }
              ],
              "node_id": "0087",
              "summary": "This partial Device Modeling Language (DML v1.4) reference covers language constructs, runtime behavior, and standard templates. Main points:\n\n- Method calls and return-value rules: calling methods in expressions, use as initializers/assignments, restrictions for inline/throwing/multi-return methods, and function-pointer conversion for methods.\n- Template-qualified method implementation calls: using object.templates to invoke specific template implementations, resolution rules, examples for resolving conflicts (combining implementations or wrapping a chosen implementation), and rules for shared methods and value-of-template-type calls.\n- The after statement (deferred callbacks): three forms explained\u2014\n  - After delay: schedule by simulated time unit; arguments must be serializable.\n  - Hook-bound after: bind callback to next hook message, with message component parameters.\n  - Immediate after: schedule when control returns to the simulator (FIFO per device), allows non-serializable args (but not stack pointers), and example use to avoid synchronous reentrancy bugs.\n- Logging and diagnostics: log statement syntax, log types (info, warning, error, etc.), verbosity levels, subsequent-level, log groups, and string formatting rules.\n- Basic control and error constructs: assert, compile-time error statement, foreach (runtime and #foreach compile-time unrolled), select/#select (compile-time only in this version), and #if/#else compile-time conditionals.\n- Expressions and operators: standard C operators plus DML additions\u2014\n  - undefined constant and defined test;\n  - references (. and ->), proper-value rules and contexts where non-proper references are allowed;\n  - method-to-function-pointer (&method) and calling conventions;\n  - new/delete allocation, explicit cast(expr,type), sizeoftype operator;\n  - each-in expressions for iterating objects implementing a template;\n  - compile-time lists, .len forms for lengths;\n  - bit-slicing syntax (expr[e1:e2], endianness rules, L-value use);\n  - stringify, string concatenation, and compile-time conditional (condition #? #:).\n- Libraries and built-ins overview: categorization of built-in templates (object-type templates, behavior implementations, and interface templates), guidance on overriding templates and template inheritance for efficiency and flexibility.\n- Standard templates and common object types:\n  - Universal templates: name, desc/shown_desc, documentation/shown_documentation, limitations/shown_limitations, init/post_init/destroy (lifecycle hooks), and object (common parameters like this, objtype, parent, qname, dev, templates, indices), plus cancel_after().\n  - Device template: device-level parameters (classname, register_size, byte_order, be_bitorder, use_io_memory, obj pointer, simics_api_version) and lifecycle methods.\n  - Group, attribute, attribute-type templates (bool_attr, int64_attr, uint64_attr, double_attr) and pseudo/read-only/write-only attribute variants.\n  - Connect and connect-templates (validate/set, init_as_subobj helper).\n  - Interface, port, subdevice, implement objects and related templates.\n  - Bank template: access methods (io_memory_access, transaction_access, write/read/unmapped_*), parameters controlling mapping behavior (mappable, overlapping, partial, register_size, byte_order, be_bitorder, use_io_memory, obj).\n  - Register template: inherited templates (get, set, shown_desc, read_register, write_register, init_val) and parameters (val, size, bitsize, offset). (Document fragment ends mid-description.)"
            },
            {
              "title": "Log Statements",
              "start_index": 68,
              "end_index": 69,
              "node_id": "0091",
              "summary": "- Bug-fix pattern: postpone calling on_acknowledgement by using an \"after:\" call in a signal implementation so the FSM can complete its current execution and transition before handling manager responses (works even for synchronous responses).\n- log statement syntax and behavior: log log-type[, level [ then subsequent-level ] [, groups] ]: format-string, e1, ..., eN;\n  - log-types: info, warning, error, critical, spec_viol, unimpl.\n  - level: integer 1\u20134 (default 1) with meanings (1 important, 2 high-level info, 3 medium, 4 debug). If log-type is warning/error/critical, level may only be 1.\n  - subsequent-level: if given, later logs use this level; value 5 means no further logging. For warning/error/critical subsequent-level allowed only 1 or 5.\n  - groups: integer bitmask selecting device-specific log groups (default 0); if groups is specified, level must also be specified.\n  - format-string: C printf style, should not include device/type prefix (automatically added); string literals may be concatenated with '+' and parenthesized.\n  - example and use: loggroup declarations, combining groups with '|' (bitwise-or); Register_Read and Register_Write are predefined groups.\n  - reference to Simics Model Builder User's Guide for more logging details.\n- assert statements: syntax assert expr; expr must be bool; false produces a runtime error.\n- error statements: syntax error [string]; causes a compiler error at compile time with the given (concatenated-literal) message or a default message.\n- foreach statements: syntax foreach identifier in (expr) statement; iterates over sequence-type values (Each-In expressions only); supports continue and break."
            },
            {
              "title": "Assert Statements",
              "start_index": 69,
              "end_index": 69,
              "node_id": "0092",
              "summary": "- Logging: defines log groups (e.g., loggroup good; bad; ugly;) and shows a log statement example (log info, 2, (bad | ugly): \"...\";) using the bitwise-or to combine groups. Explains that groups let users classify messages (by state, device part, etc.), mentions predefined groups Register_Read and Register_Write, and notes that format strings must be string literals concatenated with '+' and may be parenthesized. References Simics Model Builder User's Guide \"Logging\" for more details.\n\n- Assert statements: syntax \"assert expr;\". expr must be bool; the statement does nothing if true, otherwise it raises a runtime error.\n\n- Error statements: syntax \"error [string];\". Compilation produces an error with the provided message (optional); the string may be built from string literals concatenated with '+' and optionally parenthesized.\n\n- Foreach statements: syntax \"foreach identifier in (expr) statement\". Iterates the body for each element of expr, with identifier bound to the current element. Currently supported for sequence types produced by Each-In expressions. continue and break can be used inside the loop."
            },
            {
              "title": "Error Statements",
              "start_index": 69,
              "end_index": 69,
              "node_id": "0093",
              "summary": "- Logging: defines log groups (e.g., loggroup good; bad; ugly;) and log statements that can specify one or more groups (example: log info, 2, (bad | ugly): \"...\" using the bitwise-or to combine groups). Groups let users classify messages (by state, device part, etc.); DML predefines Register_Read and Register_Write. Format strings must be one or more string literals concatenated with '+' and may be wrapped in parentheses. References Simics Model Builder User's Guide \"Logging\" for more details.\n\n- Assert statements (3.20.13): syntax assert expr; \u2014 evaluates expr, does nothing if true, otherwise raises a runtime error. expr must be of type bool.\n\n- Error statements (3.20.14): syntax error [string]; \u2014 causes the compiler to generate an error with the given message (string may be omitted to use a default message). The string, if present, follows the same concatenation rules as logging format-strings (string literals joined with '+' and optionally parenthesized).\n\n- Foreach statements (3.20.15): syntax foreach identifier in (expr) statement \u2014 iterates the statement body over each element of expr. Currently iteration is supported only over sequence types (obtained via Each-In expressions). The loop body can use continue to skip to the next element and break to exit the loop; the identifier refers to the current element."
            },
            {
              "title": "Foreach Statements",
              "start_index": 69,
              "end_index": 70,
              "node_id": "0094",
              "summary": "- Logging: describes loggroup declarations and log statements (e.g., log info, 2, (bad | ugly): \"...\"); groups are used to classify messages (examples: good, bad, ugly, and predefined Register_Read/Register_Write); the format string must be one or more string literals concatenated with '+' and may be parenthesized; refers to Simics Model Builder User's Guide \"Logging\" for details.\n\n- Assert statements: syntax \"assert expr;\"; expr must be bool; raises a runtime error if false.\n\n- Error statements: syntax \"error [string];\"; causes a compile-time error with the given message (string may be omitted); string literals may be concatenated with '+' and parenthesized.\n\n- Foreach statements: runtime form \"foreach identifier in (expr) statement\" iterates over sequence-type values (created via Each-In expressions); supports continue and break. Compile-time unrolling form \"#foreach identifier in (expr) statement\" requires expr to be a compile-time list constant and is fully unrolled by the compiler; compile-time body can use #if (only #if allowed for compile-time selection); example demonstrates unrolling; break is allowed in #foreach.\n\n- Select statements: runtime form \"select identifier in (expr) where (cond-expr) statement else default-statement\" executes the statement for the first element matching the condition or the default if none match. A compile-time \"#select\" form exists (expr must be a compile-time list constant), but the runtime select was temporarily removed in DML 1.4 due to semantic issues and only the #select form may currently be used."
            },
            {
              "title": "Select Statements",
              "start_index": 70,
              "end_index": 70,
              "node_id": "0095",
              "summary": "Summary of partial document:\n\n- Describes DML\u2019s compile-time unrolled #foreach form: \"#foreach identifier in (expr) statement\" requires expr to be a DML compile-time constant (currently only compile-time list constants are supported). The loop is unrolled by the compiler and compile-time tests on the loop identifier using #if may be used to select code per element. Example demonstrates using nested #if branches and an error directive to catch compile-time mistakes. The break statement can be used inside a #foreach to exit early.\n\n- Describes the \"select\" statement: \"select identifier in (expr) where (cond-expr) statement else default-statement\" behaves like a switch but executes the statement exactly once for the first element matching cond-expr, or the default if none match. The alternative \"#select\" form requires expr to be a compile-time constant and limits cond-expr to depend only on compile-time constants (aside from the identifier), so the compiler performs selection at compile time and emits code only for the chosen case. DML currently only supports #select over compile-time list constants.\n\n- Notes: general switch/if statements are not evaluated at compile time (only #if may be used for compile-time selection), and the select statement itself was temporarily removed in DML 1.4 due to semantic issues\u2014only the #select form is available for now."
            },
            {
              "title": "#if and #else Statements",
              "start_index": 70,
              "end_index": 98,
              "node_id": "0096",
              "summary": "- Describes DML compile-time control constructs: #foreach (including compile-time unrolling and #if selection), #select/#select (compile-time #select only in 1.4), and #if/#else evaluated at compile time.\n- Details expression language extensions and compile-time concepts: undefined, defined test, compile-time lists, stringify, compile-time conditional, string concatenation, and each-in for template-based iteration.\n- Explains references and object-value semantics (proper vs. non-proper values), member selection (. and ->), indexing and unknown indices, and method-to-function-pointer conversion with &.\n- Covers memory and type operations: new/delete allocation, cast(expr,type), sizeoftype for type sizes, and limitations on sizeof and casts relative to C.\n- Defines bit-slicing syntax and semantics, including bitorder (be/le), index interpretation, and l-value use for bitfields.\n- Describes length expressions for lists, sequences, object- and value-arrays, and list expression usage and restrictions.\n- Introduces DML built-in object hierarchy and standard templates: universal templates (name, desc, documentation, limitations), object base template (this, objtype, parent, qname, dev, indices), and lifecycle methods (init, post_init, destroy) and their invocation rules.\n- Documents device-level template and parameters (classname, register_size, byte_order, be_bitorder, use_io_memory, obj, simics_api_version) and group/subdevice/port semantics.\n- Details attribute and connect objects: attribute get/set APIs, attribute parameters (type, configuration, persistence, readable/writable/internal), attribute helper templates (bool/int/uint/double_attr, pseudo/read_only/write_only), and connect validation/set behavior and init_as_subobj helper.\n- Covers interface objects, port/subdevice object parameters, and implement/bank_io_memory for IO redirection.\n- Describes bank semantics and methods (io_memory_access, transaction_access, write/read/unmapped handling), bank parameters (mappable, overlapping, partial, register_size, byte_order, be_bitorder, use_io_memory, obj) and mapping rules.\n- Specifies register and field templates, parameters and methods (val, size, bitsize, offset, fields, init_val, get/set/read/write variants), unmapped bit handlers, and interactions between registers and fields.\n- Enumerates register/field access templates and interfaces: get_val/set_val, get/set, read_register/write_register, read_field/write_field, read/write, init_val and their default behaviors and override rules.\n- Explains event objects and event templates (simple/uint64/custom, time vs cycle variants), their methods (event, post, remove, posted, next, get_event_info, set_event_info, destroy) and checkpointing considerations.\n- Presents standard templates for common register/field behaviors and reset handling: reset types (power-on, hard, soft), reset templates/ports (POW ER/HRESET/SRESET), soft_reset_val, sticky/no_reset, and common read/write behavior templates (ignore_write, read_zero, read_only, write_only, write_1_clears, clear_on_read, write_1_only, write_0_only, read_constant) and logging/semantics."
            }
          ],
          "node_id": "0076",
          "summary": "- Shows a small file snippet (Makefile with SRC_FILES=foo.c bar.dml) and then documents language rules for DML (a C-like language).\n- Assignment rules:\n  - Assignments are statements, not expressions; multiple variables may be assigned in one statement.\n  - Chained assignment syntax: i = j = 0; executes initializer once and assigns to each target.\n  - Multiple simultaneous assignment via tuple syntax: (i, j) = (j, i); targets are updated simultaneously (enables swap).\n  - Multiple-return methods can be assigned with tuple targets: (quotient, remainder) = divmod(17, 5); such calls must be separate statements and all return values must be assigned.\n  - General assignment grammar shown: target1 [= target2 = ...] = initializer; and (target1, target2, ...) = initializer;\n- Method and return rules:\n  - If a method can throw or has more than one return argument, the call must be a separate statement.\n  - Methods with multiple return arguments use parenthesized return types: method m() -> (bool, int) { ... }\n- Expression and type rules:\n  - Type casts use the form cast(expr, type).\n  - Comparison and logical operators yield bool (not integers); conditions in if/for/while must be booleans (e.g., if (i) is invalid for integers).\n  - sizeof applies only to lvalue expressions; use sizeoftype to get the size of a type.\n  - Comma-expressions are restricted to the head of for-statements (example: for (i = 10, k = 0; i > 0; --i, ++k) ...).\n- Exception and object lifetime rules:\n  - delete and throw are statements only (cannot be used as expressions).\n  - throw takes no argument; catch cannot switch on exception type or value.\n- Type-declaration restrictions and workaround:\n  - union is not allowed in DML type declarations.\n  - extern typedef with a C header block can be used to expose a C union to DML as a struct-like type so generated C code interops correctly (example showing header %{ typedef union { ... } u_t; %} extern typedef struct { ... } u_t;).\n- Notes that all ISO C statements are available in DML with C semantics, and introduces DML-specific statements (assignment statements, with a following section on local statements indicated but not included in the excerpt)."
        },
        {
          "title": "Expressions",
          "start_index": 98,
          "end_index": 71,
          "nodes": [
            {
              "title": "The Undeclared Constant",
              "start_index": 71,
              "end_index": 99,
              "node_id": "0098",
              "summary": "- #if/#else compile-time conditional processing: conditions must be constant; true_body processed only if condition true; else processed otherwise; dead-code eliminated.\n\n- Expressions overview: most ISO C operators supported with C-like precedence; some restrictions (comma, sizeof, casts) and several DML-specific expressions added.\n\n- Compile-time-only value undefined and defined expr test: undefined used for optional parameters; defined expr checks for undefined.\n\n- References and proper-value rules: member selection with . and ->; many DML object references are compile-time constructs and not usable as standalone values except in specific contexts (e.g., as . operand, param definitions, list elements, defined operand, method calls, index expressions). Notes on object arrays, unknown indices, and when params are proper values.\n\n- Method-to-function-pointer references: &method yields a C-style function pointer with implicit conf_object_t * device parameter; restrictions on which methods are addressable and precedence/parentheses rules when calling.\n\n- Dynamic allocation and deletion: new type and new type[count] allocate memory (non-null), to be freed with delete.\n\n- cast(expr, type) and sizeoftype type: explicit cast syntax and sizeof-for-types via sizeoftype; DML delegates many size computations to C compiler; integer/layout/const arrays sizes evaluated as constants.\n\n- each-in expressions and foreach iteration: traverse objects implementing a template (sequence(template-name)); recursive search semantics, deterministic but unspecified order, intended for hooks like custom resets.\n\n- Lists and length expressions: compile-time lists [e1,...,eN] with restricted contexts; .len for lists, sequences, object/value arrays (value-array requires known size).\n\n- Bit-slicing syntax: expr[e1:e2] (and single-index shorthand), optional bitorder (be/le), semantics of index meaning, endianness handling, restrictions on big-endian slicing expressions, undefined behavior for zero/negative ranges; bit-slicing can be an L-value.\n\n- Stringify and compile-time string concatenation: stringify(expr) converts compile-time constant to string; expr1 + expr2 concatenates compile-time string constants.\n\n- Compile-time conditional expression: condition #? expr1 #: expr2 \u2014 condition must be constant and only the selected branch is processed.\n\n- Overview of templates and built-ins: templates implement most standard DML functionality; object-type templates auto-instantiated; interface templates define method/parameter interfaces and must often be instantiated to have overrides take effect.\n\n- Universal templates and object base: name, desc/shown_desc, documentation/shown_documentation, limitations/shown_limitations, init, post_init, destroy (lifecycle callbacks), and object template (this, objtype, parent, qname, dev, templates, indices, per-array index names, cancel_after).\n\n- Device template: top-level device object with init/post_init/destroy, parameters like classname, register_size, byte_order, be_bitorder, use_io_memory, obj pointer, simics_api_version.\n\n- Group, attribute, and attribute-template support: attribute interface (get/set/get_attribute/set_attribute), parameters for attribute typing, configuration (required/optional/pseudo/none), persistence, readable/writable/internal; standard attribute templates (bool_attr, int64_attr, uint64_attr, double_attr) and pseudo/read-only/write-only variants.\n\n- Connect/interface/port/subdevice templates: connect validation/set methods and configuration; init_as_subobj helper for auto-created subobjects; interface template required flag and session val pointer; port and subdevice obj parameter semantics across API versions.\n\n- Implement/bank/register/field model: implement templates (e.g., bank_io_memory), bank methods (io_memory_access, transaction_access, write/read, unmapped_read/write), bank parameters (mappable, overlapping, partial, register_size, byte_order, be_bitorder, use_io_memory, obj) and access decomposition rules.\n\n- Register objects: parameters val, size, bitsize, offset, fields, init_val, configuration/persistent/internal; overridable read_unmapped_bits and write_unmapped_bits for handling bits not covered by fields.\n\n- Field objects: val, reg reference, lsb/msb (bit numbering in little-endian), bitsize auto-derived, init_val; field behaviors and interactions with parent register.\n\n- Register/field access interface templates: get_val/set_val, get/set, read_register/write_register (register-only), read_field/write_field, read/write (overrideable, applies to registers and fields), init_val semantics for resets and precedence between register and field overrides.\n\n- Event objects and templates: event base plus six event templates (simple/uint64/custom \u00d7 time/cycle), event/post/remove/posted/next methods, custom event serialization hooks (get_event_info/set_event_info/destroy), time units differences (seconds vs cycles).\n\n- Standard templates and reset support in utility.dml: reset types (power-on, hard, soft) and templates (poreset/hreset/sreset, power_on_reset/hard_reset/soft_reset) with default behavior restoring init_val, options to override or suppress resets (sticky, no_reset), recommended POWER port semantics for power vs reset modeling.\n\n- Common register/field behavior templates: soft_reset_val, ignore_write, read_zero, read_only, write_only, write_1_clears, clear_on_read, write_1_only, write_0_only, read_constant/constant/silent_constant, zeros, ones \u2014 including intended use, read/write effects, and logging/side-effect notes."
            },
            {
              "title": "References",
              "start_index": 99,
              "end_index": 100,
              "node_id": "0099",
              "summary": "- Scope: excerpts from a register/template specification describing several access-behaviour templates and their logging/parameter conventions.\n\n- Templates and key behaviors:\n  - constant: Writes forbidden/no effect on the intended constant semantics, but backing storage exists (so end-users can tweak via attribute writes that survive reset). Template signals model not to update the register or override the read method. Parameter: init_val. Logs: first differing write \u2192 spec_violation at level 1, subsequent writes at level 2. Related templates: read_constant, silent_constant, read_only.\n  - silent_constant: Value remains constant; software writes are ignored and do not change the value. End-user tweaks survive reset. Parameter: init_val. Related: constant, read_constant.\n  - zeroes / ones: Fixed constant values (all 0s or all 1s). Software writes do not update the value. Logs: first differing write \u2192 spec_violation at level 1, remaining writes at level 2.\n  - ignore: Object is unimportant; reads return 0 and writes are ignored.\n  - reserved: Marked reserved (should not be used by software). Writes update storage, reads return the stored value. Logging: first software write (if differing) \u2192 spec_violation at level 2; no logs for subsequent writes.\n  - unimpl: Functionality unimplemented; warn on use. Reads/writes use default implementations. Logging: first register read/write \u2192 unimplemented at level 1, remaining reads/writes at level 3. Field reads do not log; field writes log only if value differs (same level rules). Related: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n  - read_unimpl: Read-related functionality unimplemented (writes use default). Logging: first register read \u2192 unimplemented at level 1, subsequent reads at level 3; field reads do not log. Related: unimpl, write_unimpl, silent_unimpl, design_limitation.\n  - write_unimpl: Write-related functionality unimplemented (reads use default). Logging: first register write \u2192 unimplemented at level 1, subsequent writes at level 3; first differing field write similarly logged. Related: unimpl, read_unimpl, silent_unimpl, design_limitation.\n\n- Recurrent conventions: many templates include an init_val parameter for initial constant values; several templates specify differing log levels for first vs. subsequent accesses and distinguish register vs. field access logging; related-template lists indicate alternative or complementary behaviors."
            },
            {
              "title": "Method References as Function Pointers",
              "start_index": 100,
              "end_index": 101,
              "node_id": "0100",
              "summary": "This partial document lists and explains register/field \"templates\" that define object behavior and logging policy in a hardware model. It describes templates for ignored or reserved objects, various unimplemented variants (unimpl, read_unimpl, write_unimpl, silent_unimpl) including their default read/write behavior, detailed log-output rules (first-occurrence vs subsequent messages and log levels), and related-template links. It also covers templates for undocumented or unmapped registers, persistence across resets (sticky, no_reset), and design decisions leaving functionality out of scope (design_limitation), and begins a section on bank-related templates."
            },
            {
              "title": "New Expressions",
              "start_index": 101,
              "end_index": 73,
              "node_id": "0101",
              "summary": "A single instruction directing the reader to return the description directly and to include no additional text."
            },
            {
              "title": "Cast Expressions",
              "start_index": 73,
              "end_index": 73,
              "node_id": "0102",
              "summary": "- Small callback function example showing an independent method signature and invocation: callback(int i, void *aux) { local conf_object_t *obj = aux; (&my_method)(obj, i); }.\n- new expressions:\n  - Syntax: new type or new type[count].\n  - Allocates memory for one or count values, returns a non-null pointer (Simics will terminate the application on allocation failure).\n  - Memory must be freed with delete.\n- cast expressions:\n  - Syntax: cast(expr, type).\n  - Explicit DML cast operator; semantically equivalent to C\u2019s (type)expr.\n- sizeoftype expressions:\n  - Syntax: sizeoftype type (sizeof in DML applies only to expressions, so sizeoftype is used for types).\n  - Semantically equivalent to C\u2019s sizeof(type).\n  - DML often treats sizeoftype as non-constant and delegates size computation to the C compiler; however, it evaluates sizes of integer types, layout types, and constant-sized arrays as constants.\n- defined expressions:\n  - Syntax: defined expr.\n  - Compile-time test that is false if expr is undefined, true otherwise.\n- each-in expressions:\n  - Used to traverse all objects implementing a specific template (a generic hook mechanism).\n  - Example use: iterate over and reset all registers in a register bank (regs)."
            },
            {
              "title": "Sizeof type Expressions",
              "start_index": 73,
              "end_index": 74,
              "node_id": "0103",
              "summary": "- Starts with a short code example of an independent callback method that obtains a conf_object_t from aux and invokes my_method on it.\n- new expressions: syntax new type and new type[count]; allocate non-null memory (failure aborts Simics); arrays supported; memory must be freed with delete.\n- cast expressions: explicit form cast(expr, type) required in DML; semantically equivalent to C\u2019s (type)expr.\n- sizeof/type-size expressions: DML uses sizeoftype type to get sizeof(type) (since sizeof on types is syntactically disallowed); DML treats many sizeoftype results as non-constant and may defer to the C compiler; sizes of integer types, layout types, and constant-sized arrays are evaluated as constants.\n- defined expressions: defined expr is a compile-time test that is false if expr is undefined, true otherwise.\n- each-in expressions: each template-in (object) returns a sequence(template-name) used to iterate over objects implementing a template (primarily in foreach); searches object hierarchy recursively but does not descend into a found subobject; iteration order is deterministic but otherwise unspecified; intended for hooks like bulk reset.\n- list expressions: compile-time ordered lists [e1,...,eN]; usable only in specific contexts (foreach/select iteration, param/constant values, nested lists, index expressions, operand of defined).\n- length expressions: forms list.len, sequence.len, object-array.len, value-array.len to obtain lengths; constant for all forms except sequence.len; value-array.len requires arrays of known constant size.\n- Bit slicing expressions: section begins but content is not included in the partial document."
            },
            {
              "title": "Defined Expressions",
              "start_index": 74,
              "end_index": 73,
              "node_id": "0104",
              "summary": "The provided partial document contains no text, so its main points cannot be determined."
            },
            {
              "title": "Each-In Expressions",
              "start_index": 73,
              "end_index": 74,
              "node_id": "0105",
              "summary": "- Short callback example showing a wrapper that calls a method pointer with an auxiliary object.\n- new expressions: syntax new type and new type[count]; allocates memory (pointer never null; Simics will terminate on failure); must be freed with delete.\n- cast expressions: explicit cast(expr, type) syntax in DML, semantically equivalent to C\u2019s (type)expr.\n- sizeoftype expressions: use sizeoftype type to get sizeof(type) in DML; sizeof only works on expressions. DML treats many sizeoftype results as non-constant and defers to the C compiler, but evaluates sizes of integer types, layout types, and constant-sized arrays as constants.\n- defined expressions: defined expr is a compile-time test that is false if expr is undefined, true otherwise.\n- each-in expressions: each hard_reset_t in (regs) can be used to iterate objects implementing a template (usable only in foreach); returns sequence(template-name); searches object hierarchy recursively but stops descending once a matching object is found; iteration order is undefined but deterministic; recursive traversal can be implemented via template methods.\n- list expressions: [e1,...,eN] are compile-time ordered sequences; allowed only in specific contexts (foreach/select iteration, param/constant values, nested compile-time lists, index operands, and operand of defined).\n- length expressions: .len on list, sequence, object-array, and value-array yields length; constant for all forms except sequence; value-array.len only for arrays with known constant size (not pointers, unknown-size arrays, or VLAs).\n- Begins section on bit slicing expressions (header present but content not included)."
            },
            {
              "title": "List Expressions",
              "start_index": 74,
              "end_index": 74,
              "node_id": "0106",
              "summary": "- each-in expressions\n  - Example: foreach obj in (each hard_reset_t in (regs)) { obj.hard_reset(); }\n  - Each-in can only be used as the iteration source in a foreach statement.\n  - The type of an each-in expression is sequence(template-name).\n  - It searches recursively in the object hierarchy for objects implementing the template, but stops descending once it finds a matching subobject. To achieve full recursive traversal, the template can include a method that explicitly descends into subobjects (the document references hard_reset in utility.dml as an example).\n  - The iteration order produced by a given each-in expression is not defined, except that it is deterministic for a particular template, object, device-model iteration, and DMLC build.\n\n- List expressions\n  - Syntax: [e1, ..., eN]; lists are compile-time only ordered sequences.\n  - Primarily used with foreach and select.\n  - Allowed contexts:\n    - As the list to iterate over in a #foreach or #select statement\n    - As the value in a param or constant declaration\n    - As a list element in another compile-time list\n    - In an index expression (list[index])\n    - As the operand of the defined operator\n\n- Length expressions\n  - Forms: list.len, sequence.len, object-array.len, value-array.len\n  - Used to obtain the length of the corresponding aggregate expression.\n  - The length is a constant for all forms except sequence expressions.\n  - The value-array form is restricted to arrays of known constant size (not allowed for pointers, arrays of unknown size, or variable-length arrays).\n\n- The document continues with a section on Bit Slicing Expressions (heading present but content not included in the partial text)."
            },
            {
              "title": "Length Expressions",
              "start_index": 74,
              "end_index": 74,
              "node_id": "0107",
              "summary": "- each-in expressions: can only be used as the iteration source in a foreach; their type is sequence(template-name). They search recursively in an object hierarchy for objects implementing the given template, but stop descending once a matching subobject is found. To perform deeper recursion, put a descent method in the template itself (example: hard_reset in utility.dml). The order of objects returned by a given each-in expression is not defined but is deterministic for a fixed template, object, device-model iteration, and build.\n\n- List expressions ([e1, ..., eN]): compile-time only ordered sequences used primarily with foreach and select. Allowed contexts: as the list to iterate in #foreach/#select, as a param or constant value, as an element in another compile-time list, in an index expression (list[index]), and as the operand of the defined operator.\n\n- Length expressions (list.len, sequence.len, object-array.len, value-array.len): yield the length of the respective collection. These lengths are constant for all forms except sequence.len. The value-array.len form only works for arrays with known constant size (not pointers, unknown-size arrays, or variable-length arrays).\n\n- Bit Slicing Expressions: section heading appears but content is not included in the provided excerpt."
            },
            {
              "title": "Bit Slicing Expressions",
              "start_index": 74,
              "end_index": 75,
              "node_id": "0108",
              "summary": "- Each-in / foreach:\n  - Syntax example: foreach obj in (each hard_reset_t in (regs)) { obj.hard_reset(); }\n  - each-in expressions are used only in foreach statements and have type sequence(template-name).\n  - They search the object hierarchy for objects implementing a template; once a matching subobject is found, traversal does not continue inside that subobject.\n  - Recursive traversal must be implemented by the template itself (e.g., a method that descends into subobjects).\n  - The order of results is not defined except that it is deterministic for a given template, object, device-model iteration, and build.\n\n- List expressions:\n  - Syntax: [e1, ..., eN]\n  - Lists are compile-time only, ordered sequences, used with foreach/select, as param/constant values, as elements of other compile-time lists, in index expressions, and as operand of the defined operator.\n\n- Length expressions:\n  - Forms: list.len, sequence.len, object-array.len, value-array.len\n  - Return length of the respective compile-time collection; constant except for sequence.len.\n  - value-array.len only valid for arrays of known constant size (not pointers, unknown-size, or VLAs).\n\n- Bit-slicing expressions:\n  - Syntax variants: expr[e1:e2], expr[e1:e2, bitorder], expr[e1], expr[e1, bitorder].\n  - Operate on integer-typed expr; can be r-values or l-values.\n  - expr[e1] is shorthand for expr[e1:e1] (e1 evaluated once).\n  - Optional bitorder be/le selects bit-numbering; if omitted global bitorder applies.\n  - e1 denotes the most-significant-bit of the field; indexing conventions differ between little-endian and big-endian numbering (definitions given).\n  - Big-endian numbering restricted to expressions with a well-defined bit width (locals, params, device variables, explicit casts); little-endian allows any expression.\n  - Zero- or negative-sized ranges yield undefined behavior.\n\n- Stringify:\n  - stringify(expr) converts a compile-time-constant expr to a string constant (compile-time operation, similar to C preprocessor # but on values).\n\n- String concatenation:\n  - expr1 + expr2 concatenates compile-time string constants at compile time (useful with stringify/# or for source formatting).\n\n- Compile-time conditional expressions:\n  - Mentioned at end of excerpt but not detailed in the provided fragment."
            },
            {
              "title": "Stringify Expressions",
              "start_index": 75,
              "end_index": 75,
              "node_id": "0109",
              "summary": "Summary of main points in the partial document:\n\n- Bit-slicing syntax for integer expressions in DML: expr[e1:e2], expr[e1:e2, bitorder], expr[e1], expr[e1, bitorder]. Can be used as an expression or as an L-value (assignment target).\n- Requirements and semantics:\n  - e1 and e2 must be integers; expr[e1] is shorthand for expr[e1:e1] and evaluates e1 only once.\n  - Optional bitorder selects bit-numbering/endian interpretation; allowed identifiers are be or le. If omitted, global bit numbering applies.\n  - The first index e1 always denotes the most significant bit of the selected field (regardless of numbering).\n  - Little-endian numbering: bit 0 = least significant bit, MSB = n-1 for an n-bit integer; any expression is allowed.\n  - Big-endian numbering: indexes are reversed (LE bit n-1 becomes index 0); big-endian is only legal when expr has a well-defined bit width (simple expressions like locals, method params, device vars, or explicit casts).\n  - Zero or negative sized bit ranges yield undefined behavior.\n- stringify(expr): compile-time-only operation that converts a compile-time constant expression into a string constant (analogous to C preprocessor # but applied to compile-time values); commonly used with the string concatenation operator.\n- String concatenation: expr1 + expr2 concatenates two compile-time string constants at compile time (used for combining # results or breaking long source lines).\n- The document then begins a section on compile-time conditional expressions (heading present, content not included)."
            },
            {
              "title": "String Concatenation Expressions",
              "start_index": 75,
              "end_index": 75,
              "node_id": "0110",
              "summary": "- Bit-slicing syntax for integers: expr[e1:e2], expr[e1:e2, bitorder], expr[e1], expr[e1, bitorder]; can be used as an r-value or as an L-value (left-hand side of assignment).\n- e1 and e2 must be integers; expr[e1] is shorthand for expr[e1:e1] (e1 evaluated once).\n- Optional bitorder (be or le) selects local bit-numbering; if omitted the global bit numbering applies.\n- The first index e1 always denotes the most-significant bit of the selected field.\n- Little-endian (default): least-significant bit = index 0, most-significant = n-1 (n = bit width); any expression allowed.\n- Big-endian: indexing is reversed (bit corresponding to LE n-1 has index 0); big-endian is only legal for simple expressions with a well-defined bit width (local variables, method parameters, device variables, explicit casts).\n- Zero- or negative-sized bit ranges yield undefined behavior.\n- stringify(expr): compile-time conversion of a compile-time-constant expr into a string constant (analogous to C preprocessor # but at value level); commonly used with the + string operator.\n- String concatenation: expr1 + expr2 concatenates two compile-time string constants at compile time (useful with # or for source formatting).\n- The document then begins a section titled \"3.21.14 Compile-Time Conditional Expressions\" (content not included in the excerpt)."
            },
            {
              "title": "Compile-Time Conditional Expressions",
              "start_index": 75,
              "end_index": 76,
              "node_id": "0111",
              "summary": "- Bit-slicing syntax for integer expressions: expr[e1:e2], expr[e1:e2, bitorder], expr[e1], expr[e1, bitorder]. Can be used as an r-value (produces a value) or as an l-value (target of assignment).\n- expr[e1] is shorthand for expr[e1:e1], with e1 evaluated only once.\n- e1 and e2 must be integers.\n- Optional bitorder qualifier (be or le) selects bit-numbering/endianness; if omitted, the global bitorder applies.\n- The first index e1 always denotes the most-significant bit of the selected field; interpretation of indices depends on bit numbering:\n  - Little-endian (default): least-significant bit = index 0, most-significant bit = n-1 (n = bit width).\n  - Big-endian: the bit that is little-endian index n-1 has index 0, least-significant bit = index n-1.\n- Big-endian indexing is only allowed when expr has a well-defined bit width and is a simple expression (local variables, method parameters, device variables, explicit casts); little-endian allows any expression.\n- Zero- or negative-sized bit ranges produce undefined behavior.\n- stringify(expr): compile-time conversion of a compile-time-constant expr into a string constant (akin to C\u2019s # but works on compile-time values).\n- String concatenation: expr1 + expr2 concatenates compile-time string constants at compile time (useful with stringify/# and for formatting).\n- Compile-time conditional: condition #? expr1 #: expr2 \u2014 like C\u2019s ?: but requires a constant condition and is evaluated at compile time; only the taken branch is processed (example: false #? 1/0 #: 0 yields 0)."
            }
          ],
          "node_id": "0097",
          "summary": "The partial document contains only a meta-instruction directing the recipient to \"directly return the description\" with no additional text; it lacks substantive content, topics, or main points to summarize."
        }
      ],
      "node_id": "0010",
      "summary": "The partial document contains no visible text or content, so no main points can be identified or described."
    },
    {
      "title": "Libraries and Built-ins",
      "start_index": 77,
      "end_index": 78,
      "nodes": [
        {
          "title": "Universal templates",
          "start_index": 78,
          "end_index": 78,
          "nodes": [
            {
              "title": "name",
              "start_index": 78,
              "end_index": 78,
              "node_id": "0114",
              "summary": "Discusses template usage and inheritance in a DML-like language, showing examples (init_to_ten with a default parameter and log_on_change that inherits write, get, and name to log changes on write). Notes that inheriting finer-grained templates (get and name) is more flexible and efficient than inheriting a larger aggregate (register). Introduces \"universal templates\" applicable to all object kinds and documents four: name (string parameter for the object name, overridable), desc (short plain-text description and a shown_desc string exposed to users, with shorthand syntax referenced), shown_desc (a subtemplate making shown_desc a typed parameter for shared-method access), and documentation (longer descriptive string used for extracted docs)."
            },
            {
              "title": "desc",
              "start_index": 78,
              "end_index": 78,
              "node_id": "0115",
              "summary": "- Explains template definitions and use in the DML-like language, with an example template (init_to_ten) that sets a default parameter (init_val = 10) and can be applied to fields for efficiency.\n- States that a template that needs to access object members must inherit a template that provides those members; gives log_on_change as an example (inheriting write, get, name) that logs when a value changes and calls default().\n- Notes design trade-offs (e.g., inheriting register could replace get and name but reduces flexibility and efficiency).\n- Introduces \"Universal templates\" applicable to all object kinds and summarizes each:\n  - name: provides a string parameter name exposed to end users (used in logs/config), which can be overridden to hide confidential info.\n  - desc: provides a short text description (desc) and a shown_desc parameter (defaults to desc) used in simulation, device inspection, and as a docstring; desc has a shorthand syntax.\n  - shown_desc: a subtemplate of desc that makes shown_desc a typed parameter for use in shared methods.\n  - documentation: provides a longer documentation string for extraction into external docs."
            },
            {
              "title": "shown_desc",
              "start_index": 78,
              "end_index": 78,
              "node_id": "0116",
              "summary": "Describes DML template usage and inheritance with examples: a simple template init_to_ten that sets a default parameter and can be used on fields, and a log_on_change template that shows how a template must inherit another template to access object members (illustrating a flexibility/efficiency trade-off when inheriting broader templates like register versus specific members like get and name). It then documents a set of universal templates applicable to all object kinds: name (provides an overridable string name for user-visible identifiers), desc (provides a short plain-text description plus a shown_desc parameter that defaults to desc and can hide sensitive info, with a shorthand syntax referenced), shown_desc (a subtemplate making shown_desc typed for use in shared methods), and documentation (provides a longer descriptive string for extracted docs)."
            },
            {
              "title": "documentation",
              "start_index": 78,
              "end_index": 79,
              "node_id": "0117",
              "summary": "Summary of main points in the partial document:\n\n- Examples: shows small template examples (init_to_ten with a default param, and log_on_change that inherits members like write, get, name) illustrating template inheritance, efficiency concerns, and tradeoffs (e.g., inheriting register vs. explicit members affects flexibility and efficiency).\n- Universal templates: introduces a set of templates applicable to all object kinds and describes their provided parameters or methods.\n- name: provides a string parameter name exposed to end users (used in logs and config); can be overridden to hide confidential info.\n- desc / shown_desc: desc supplies a short plain-text description (used in simulation and as docstring); shown_desc is the string exposed during simulation and defaults to desc. A subtemplate shown_desc makes shown_desc a typed parameter for shared-method contexts.\n- documentation / shown_documentation: provides a longer documentation string; shown_documentation defaults to documentation and can be used to suppress documentation. If generating Simics reference docs, the strings must follow Simics documentation XML format.\n- limitations / shown_limitations: provides a limitations string (and shown_limitations defaulting to it); same XML-format requirement for reference documentation builds.\n- init: provides an abstract init method called when an object is created before attributes are initialized; init is automatically invoked for all implementations. Call order is not fully defined, but init of an object is guaranteed to run before init of any of its parent objects (device init runs only after other inits).\n- post_init: provides an abstract post_init method called after attributes are initialized, used for establishing connections or setups depending on configured values; automatically called for all implementations.\n- destroy: provides an abstract destroy method called when the device is deleted to clean up non-DMLC-managed resources; automatically called for all implementations with the same child-before-parent guarantee as init. Usage note: while being deleted, an object must not communicate with other Simics objects or the Simics API."
            },
            {
              "title": "limitations",
              "start_index": 79,
              "end_index": 79,
              "node_id": "0118",
              "summary": "Summary of main points in the excerpt:\n\n- Documentation and packaging: If using the Documentation and Packaging package to generate Simics reference documentation, the documentation string must follow the Simics documentation XML format or the documentation build will produce a syntax error; see the Writing Documentation note.\n- shown_documentation: A string parameter (defaulting to \"documentation\") analogous to shown_desc, provided mainly to allow suppression of the documentation.\n- Limitations: A string parameter \"limitations\" to describe implementation limitations; this may be extracted into device documentation. If generating reference docs, the limitations string must also follow the Simics documentation XML format.\n- shown_limitations: A string parameter (defaulting to \"limitations\") similar to shown_desc, provided mainly to allow suppression of the limitations text.\n- init method: An abstract init method called when the device is created, before attributes are initialized; used to set defaults or prepare data structures. init is automatically invoked for all objects that implement it. Call order is not globally defined, but an object's init is guaranteed to run before the init of any of its parent objects (the device object's init runs only after other implementations' init).\n- post_init method: An abstract post_init method called after attributes are initialized; used to establish connections or set up structures that depend on configured attribute values. post_init is automatically called for all implementing objects.\n- destroy method: An abstract destroy method called when the device is deleted to clean up resources not managed by DMLC (e.g., delete dynamically allocated state). destroy is automatically called for all implementing objects; its call-order guarantees mirror init (an object\u2019s destroy runs before its parents\u2019; the device object's destroy runs after others).\n- Usage note during deletion: While a device is being deleted, it must not communicate with any other Simics object (no accessing connected devices or using the Simics API)."
            },
            {
              "title": "init",
              "start_index": 79,
              "end_index": 79,
              "node_id": "0119",
              "summary": "Summary of main points in the partial document:\n\n- Documentation strings: If using the Documentation and Packaging package to generate Simics reference docs, documentation and limitations strings must follow the Simics documentation XML format (see the Writing Documentation application note), otherwise the documentation build will error.\n- shown_documentation and shown_limitations: Provides string parameters shown_documentation (defaulting to documentation) and shown_limitations (defaulting to limitations) analogous to shown_desc, to conveniently suppress or control shown documentation.\n- limitations: A string parameter describing implementation limitations; this text may be extracted into device documentation and must follow the XML format when generating reference docs.\n- init method: An abstract init method is called automatically when the device is created, before attributes are initialized; typically used to set default values or initialize data structures. The call order among objects is not globally defined except that an object's init is guaranteed to be called before init of its parent objects.\n- post_init method: An abstract post_init method is called automatically when the device is created, after attributes are initialized; typically used to establish connections or set up structures that depend on configured attributes.\n- destroy method: An abstract destroy method is called automatically when the device is deleted to clean up resources not managed by DMLC (e.g., delete dynamically allocated state). destroy should not be used for other purposes. Call order is not globally defined except that an object's destroy is guaranteed to be called before destroy of its parent objects. While a device is being deleted, it must not communicate with other Simics objects or use the Simics API."
            },
            {
              "title": "post_init",
              "start_index": 79,
              "end_index": 79,
              "node_id": "0120",
              "summary": "- Describes documentation strings and parameters for devices: documentation must follow the Simics documentation XML format when using the Documentation and Packaging package (see Writing Documentation); shown_documentation is provided (defaults to documentation) as a convenience to suppress displayed docs and behaves like shown_desc.\n- Describes limitations parameter and shown_limitations (defaults to limitations); limitations text may appear in extracted docs and must follow the Simics XML format for reference documentation.\n- Defines abstract lifecycle methods/templates:\n  - init: called when the device is created before any attributes are initialized; typically used to set defaults or initialize data structures. init is auto-invoked for all implementations; call order is undefined except an object's init runs before its parents\u2019, and the device object's init runs only after other implementations.\n  - post_init: called after attributes are initialized; typically used to establish connections or set up structures depending on configured attributes; auto-invoked for all implementations.\n  - destroy: called when the device is deleted to clean up resources not managed by DMLC (e.g., delete dynamically allocated state); auto-invoked for all implementations with unspecified order except an object\u2019s destroy runs before its parents\u2019, and the device object\u2019s destroy runs only after other implementations.\n- Usage restriction: while a device is being deleted, it must not communicate with any other Simics object (neither via connected devices nor the Simics API)."
            },
            {
              "title": "destroy",
              "start_index": 79,
              "end_index": 79,
              "node_id": "0121",
              "summary": "Summary of main points:\n\n- Documentation and limitations strings: If using the Documentation and Packaging package to generate Simics reference documentation, the documentation and limitations strings must follow the Simics documentation XML format (see Writing Documentation); otherwise documentation build will error. Each also has a corresponding shown_* string parameter (shown_documentation, shown_limitations) that defaults to the original name and can be used to suppress output (behaves like shown_desc).\n\n- limitations parameter: A string parameter to describe implementation limitations; may appear in extracted device documentation.\n\n- init method: An abstract init method is called when a device is created before any attributes are initialized. It is typically used to set default values or allocate/setup data structures. init is automatically invoked for all objects implementing the template; calls are ordered such that an object's init runs before its parent objects\u2019 inits (so the device object's init runs after other implementations).\n\n- post_init method: An abstract post_init method is called after device attributes have been initialized. It is typically used to establish connections to other devices or set up structures that depend on configured attribute values. post_init is automatically called for all implementing objects.\n\n- destroy method: An abstract destroy method is called when the device is being deleted to clean up resources not managed by DMLC (e.g., delete dynamically allocated state). destroy is automatically called for all implementing objects and follows the same child-before-parent ordering as init. Usage note: while a device is being deleted it must not communicate with other Simics objects or use the Simics API."
            },
            {
              "title": "object",
              "start_index": 79,
              "end_index": 80,
              "node_id": "0122",
              "summary": "- Documentation strings: must follow Simics documentation XML format when using the Documentation and Packaging package (see Writing Documentation application note); a shown_documentation string parameter (defaults to documentation) mirrors shown_desc to allow suppressing documentation.\n\n- limitations: string parameter for implementation limitations; when generating Simics reference docs it must follow the Simics documentation XML format; a shown_limitations parameter (defaults to limitations) mirrors shown_desc for suppression.\n\n- init method: abstract init is called on object creation before attribute initialization; typically used to set defaults or data structures; init is auto-invoked for all implementations, with the guarantee that an object's init is called before its parent\u2019s init (device init runs only after all other inits).\n\n- post_init method: abstract post_init is called after attributes are initialized; typically used to establish connections or set up data dependent on configured attributes; auto-invoked for all implementations.\n\n- destroy method: abstract destroy is called when a device is deleted to clean up resources not managed by DMLC (e.g., delete dynamically allocated state); destroy is auto-invoked for all implementations, with an object's destroy called before its parent\u2019s (device destroy runs last). Usage notes: during destroy, objects must not communicate with other Simics objects or post/cancel time/cycle events (cancellations are handled automatically); .cancel_after() is tolerated; exiting Simics does not invoke destroy; destroy cannot be instantiated for event objects (workaround: declare a group inside the event object to instantiate destroy).\n\n- object base template: implemented by all objects and inherits name, desc, documentation, limitations; provides non-overridable parameters and references: this, objtype, parent, qname, dev, templates, indices. Array index parameters are exposed individually (e.g., i, j). The object template supplies cancel_after() to cancel pending after-posted events associated with the object. init, post_init, and destroy are automatically called where implemented."
            }
          ],
          "node_id": "0113",
          "summary": "Describes DML template usage and inheritance: shows a small template example (init_to_ten with param init_val = 10) and explains that inheriting templates allows access to object fields and improves efficiency. Explains that templates needing object members must inherit a template that provides those members, illustrated by a log_on_change template that inherits write, get, and name and logs when a value changes. Introduces Universal templates applicable to all object kinds, including name (provides an overridable string name for user-facing labels), desc (provides desc and shown_desc strings for short descriptions and user-visible text, with shorthand syntax and overrideability), shown_desc (a subtemplate making shown_desc typed for use in shared methods), and documentation (provides a longer documentation string for extraction)."
        },
        {
          "title": "Device objects",
          "start_index": 81,
          "end_index": 81,
          "node_id": "0123",
          "summary": "Describes DML object types: the top-level device template (inheriting init, post_init, destroy) and its lifecycle methods (init, post_init, destroy), plus key parameters such as classname, register_size, byte_order, be_bitorder, use_io_memory, the obj pointer to conf_object_t, and simics_api_version. Explains group objects as generic containers that inherit the object template, have no extra methods or parameters, and may not contain banks, ports or subdevices under groups named \"bank\" or \"port\" to avoid namespace clashes. Defines the attribute template's abstract get() method, which returns an attr_value_t."
        },
        {
          "title": "Group objects",
          "start_index": 81,
          "end_index": 81,
          "node_id": "0124",
          "summary": "- Describes the device template (top-level scope of a DML file): inherits init, post_init, destroy; explains init(), post_init(), destroy() timing; lists device parameters (classname, register_size, byte_order, be_bitorder, use_io_memory, obj pointer, simics_api_version) and their meanings/defaults.  \n- Defines group objects as generic containers for grouping other objects, notes they inherit only from object template, restrictions on parents for some types, and prohibition on declaring bank/port/subdevice under groups named \"bank\" or \"port\" to avoid namespace clashes.  \n- Defines the attribute template\u2019s get() method as an abstract function returning the attribute value (attr_value_t)."
        },
        {
          "title": "Attribute objects",
          "start_index": 81,
          "end_index": 82,
          "node_id": "0125",
          "summary": "- Defines the device object (template device): its role as the top-level scope in a DML file, the inherited templates (init, post_init, destroy), the three lifecycle methods (init(), post_init(), destroy()), and the device template parameters: classname, register_size, byte_order, be_bitorder, use_io_memory, obj (conf_object_t pointer), and simics_api_version (with defaults and meanings for each).\n\n- Describes group objects: generic container objects used to group other objects, placement rules in the object hierarchy (with some types not allowed to have a group as parent), that the group template adds no special methods or parameters beyond object inheritance, and the prohibition on declaring banks, ports, or subdevices under groups named \"bank\" or \"port\" to avoid namespace clashes.\n\n- Details attribute objects: abstract get() and set() methods, and get_attribute / set_attribute wrappers called by Simics; the expected behavior on errors (throw from set). Lists attribute template parameters and semantics: type (Simics attribute type string), configuration (required/optional/pseudo/none) and its effects on initialization and checkpointing, persistent (controls save-persistent-state), readable and writable flags (and their interaction with pseudo configuration and read_only/write_only templates), and internal (controls inclusion in documentation with default behavior).\n\n- Introduces attribute templates for simple checkpointable attributes: there are four templates that store the value in a member val, provide default type-specific get/set implementations, and a default init that initializes val from an init_val parameter (defaulting to zero-initialization)."
        },
        {
          "title": "Attribute templates",
          "start_index": 82,
          "end_index": 82,
          "node_id": "0126",
          "summary": "Summary of main points:\n- Defines an abstract set(attr_value_t value) method that must signal errors via throw if a value is not allowed.\n- Describes get_attribute and set_attribute (returning/accepting attr_value_t / set_error_t) as Simics-invoked wrappers that call the object\u2019s get and set methods and are not intended for direct use.\n- Specifies attribute template parameters:\n  - type: Simics type-description string (e.g., \"i\", \"[s*]\") or undefined.\n  - configuration: \"required\" | \"optional\" | \"pseudo\" | \"none\" and effects on initialization and checkpointing.\n  - persistent: boolean controlling inclusion in save-persistent-state.\n  - readable/writable: booleans controlling read/write access; interactions with pseudo/config and read_only_attr/write_only_attr templates.\n  - internal: boolean controlling exclusion from documentation, with default behavior based on presence of documentation/desc.\n- Introduces Attribute templates (section 4.5): four standard templates for simple checkpointable attributes that store the value in a member val, provide default get and set implementations according to type, and supply an init implementation using an init_val parameter (defaulting to zero-initialization)."
        },
        {
          "title": "Connect objects",
          "start_index": 82,
          "end_index": 83,
          "node_id": "0127",
          "summary": "Summary of main points in the partial document:\n\n- Attribute get/set behavior:\n  - Abstract set(attr_value_t value) throws to signal invalid values.\n  - Internal wrappers get_attribute -> (attr_value_t) and set_attribute(attr_value_t) -> (set_error_t) are called by Simics and not intended for direct use.\n\n- Attribute template parameters and meanings:\n  - type: string describing the attribute type (e.g., \"i\", \"[s*]\") per SIM_register_typed_attribute.\n  - configuration: \"required\" | \"optional\" | \"pseudo\" | \"none\" \u2014 controls initialization and checkpointing behavior.\n  - persistent (bool): if true, value saved by save-persistent-state (default false).\n  - readable (bool): if false, attribute cannot be read (only allowed for pseudo config).\n  - writable (bool): if false, attribute cannot be written (requires pseudo config).\n  - internal (bool): if true, excluded from documentation; default true if documentation/desc undefined, otherwise false.\n\n- Attribute templates (section 4.5):\n  - Four checkpointable templates that store value in member val, provide default get/set and init using init_val (zero-initialized by default):\n    - bool_attr (val: bool)\n    - int64_attr (val: int64)\n    - uint64_attr (val: uint64)\n    - double_attr (val: double)\n  - Three pseudo-attribute templates (not checkpointed; not compatible with the above):\n    - pseudo_attr: get and set are abstract\n    - read_only_attr: pseudo, get is abstract (cannot be written)\n    - write_only_attr: pseudo, set is abstract (cannot be read)\n\n- Connect objects (section 4.6):\n  - connect template methods:\n    - validate(conf_object_t *obj) -> bool: called when assigning a new target; return false to reject (default true). If connecting to a port interface, a session variable port (char *) is set during validate.\n    - set(conf_object_t *obj): called after validation to assign the target; can be overridden for side effects.\n    - Internal get_attribute / set_attribute methods used by Simics for attribute access.\n  - connect template parameter: configuration [\"required\" | \"optional\" | \"pseudo\" | \"none\"]."
        },
        {
          "title": "Connect templates",
          "start_index": 83,
          "end_index": 84,
          "node_id": "0128",
          "summary": "Summary of main points in the partial document:\n\n- Attribute templates:\n  - bool_attr: boolean-valued attribute, value type bool.\n  - int64_attr: integer-valued attribute, value type int64.\n  - uint64_attr: integer-valued attribute, value type uint64.\n  - double_attr: floating-point attribute, value type double.\n  - Pseudo attribute templates (cannot be used with the numeric/boolean templates):\n    - pseudo_attr: not checkpointed; abstract get and set.\n    - read_only_attr: write-prohibited; abstract get.\n    - write_only_attr: read-prohibited; abstract set.\n\n- Connect objects and template:\n  - Methods:\n    - validate(conf_object_t *obj) -> bool: called when assigning a new target; returning false cancels the connection. If connecting to a port interface, a temporary session variable port (char *) is set during validate.\n    - set(conf_object_t *obj): called after validation to assign the target; can be overridden for side-effects.\n    - get_attribute -> attr_value_t and set_attribute(attr_value_t) -> set_error_t: internal accessors used by Simics.\n  - Parameters:\n    - configuration: \"required\" | \"optional\" | \"pseudo\" | \"none\" (default \"optional\"); determines how Simics treats the automatically created attribute and whether it may be nil.\n    - internal [bool]: marks the attribute as internal.\n\n- Connect templates / init_as_subobj:\n  - init_as_subobj causes the connect to auto-create and assign a private subobject of class given by classname.\n  - Notes on classname lookup: SIM_get_class is used during module load, so defining the subobject class in the same module before the device class can cause lookup failures; moving the subobject class to a separate module avoids this.\n  - init_as_subobj overrides configuration to \"none\" (making the connect invisible to end-users) and inherits init and connect templates.\n\n- Interface objects:\n  - Parameter required (defaults to true); if false the interface is optional and parent connect can attach to objects not implementing the interface.\n  - Provides a session variable val (const void *) pointing to the Simics interface struct of the connected object; when optional, val can be compared to NULL.\n\n- Port objects:\n  - Expose parameter obj:\n    - With Simics API \u22645: evaluates to dev.obj.\n    - With Simics API \u22656: evaluates to the conf_object_t * of the port's port object.\n\n- Subdevice objects:\n  - Subdevice template exposes parameter obj, which evaluates to the conf_object_t * representing the subdevice."
        },
        {
          "title": "Interface objects",
          "start_index": 84,
          "end_index": 84,
          "nodes": [
            {
              "title": "4.7 Connect templates",
              "start_index": 84,
              "end_index": 84,
              "node_id": "0130",
              "summary": "- Rules for the automatically created attribute that corresponds to a connect object: its default mode is \"optional\"; it may be set to nil only if the parameter is \"optional\" or \"pseudo\"; for arrays of connects the rule applies per element. There is also an internal [bool] flag to mark an attribute internal.\n\n- Connect templates: the init_as_subobj template makes a connect automatically instantiate a subobject (useful for private helper objects). It takes a classname parameter that specifies the subobject class. init_as_subobj overrides the configuration parameter to \"none\" (making the connect invisible) and inherits the init and connect templates.\n\n- Caveat about init_as_subobj: subclass lookup uses SIM_get_class during device-module loading, so if the subobject class is defined in the same module but declared after the device class, the lookup can fail; the recommended workaround is to place the subobject class in a separate module.\n\n- Interface template: has a required parameter (defaults to true). If set false the interface is optional and parents may connect to objects not implementing it. The template provides a session variable val (const void *) pointing to the Simics interface struct of the connected object; when optional, val can be NULL to indicate absence.\n\n- Port template: exposes an obj parameter; under Simics API 5 and earlier it evaluates to dev.obj, while under API 6+ it evaluates to the conf_object_t * of the port's port object.\n\n- Subdevice template: exposes an obj parameter that evaluates to the conf_object_t * of the Simics object representing the subdevice."
            },
            {
              "title": "4.8 Interface objects",
              "start_index": 84,
              "end_index": 84,
              "node_id": "0131",
              "summary": "Summary of main points in the partial document:\n\n- Behavior of the automatically created attribute for a connect object: default mode is \"optional\"; the attribute may be set to nil only when the mode is \"optional\" or \"pseudo\"; for arrays of connects this rule applies per element. An \"internal [bool]\" flag controls whether the attribute is internal.\n\n- Connect template init_as_subobj: makes a connect automatically instantiate an object as a private subobject. It accepts a classname parameter to specify the subobject class, overrides configuration to \"none\" (hides the connect from end-users), and inherits the init and connect templates.\n\n- Module loading caveat: classname lookup uses SIM_get_class during device-class module loading; if the subobject class is defined in the same module but later than the device class, lookup can fail. The recommended fix is to move the subobject class to a separate module.\n\n- Interface template: has a required parameter (defaults to true). If set false the interface is optional and a parent connect may link to an object lacking the interface. Provides a session variable val (const void *) pointing to the currently connected object's Simics interface struct; compare to NULL to detect absence when optional.\n\n- Port template: exposes an obj parameter whose meaning depends on Simics API version \u2014 with API \u22645 it evaluates to dev.obj, with API \u22656 it evaluates to the conf_object_t * of the port's port object.\n\n- Subdevice template: exposes an obj parameter that evaluates to the conf_object_t * for the Simics object representing the subdevice."
            },
            {
              "title": "4.9 Port objects",
              "start_index": 84,
              "end_index": 84,
              "node_id": "0132",
              "summary": "- Rules for the automatically created attribute for a connect object: default is \"optional\"; it may be set to nil only if the parameter is \"optional\" or \"pseudo\"; in connect arrays the rule applies per element.\n- internal [bool] parameter: controls whether the attribute is internal.\n- Connect template init_as_subobj: causes a connect to bind to an automatically created subobject (useful for private helper objects); accepts classname to specify the subobject class; overrides configuration to \"none\" (hidden); inherits init and connect templates.\n- Note on classname lookup: SIM_get_class is used while the device class module is loading, so if the subobject class is defined in the same module but appears later, lookup can fail\u2014move the subobject class to a separate module to avoid this.\n- Interface template: has parameter required (default true); if set false the interface is optional and connections may be to objects that do not implement it; provides a session variable val (const void *) pointing to the connected object\u2019s Simics interface struct (can be NULL when optional).\n- Port template: exposes obj parameter which, on Simics API \u22645, evaluates to dev.obj, and on API \u22656 evaluates to the conf_object_t * of the port\u2019s port object.\n- Subdevice template: exposes obj parameter that evaluates to the conf_object_t * of the Simics object representing the subdevice."
            },
            {
              "title": "4.10 Subdevice objects",
              "start_index": 84,
              "end_index": 87,
              "node_id": "0133",
              "summary": "Summary of main points in the partial document:\n\n- Connect attributes: treatment of automatically created connect attribute (default \"optional\"); nil allowed only for \"optional\" or \"pseudo\"; array semantics; internal [bool] controls whether attribute is internal.\n\n- Connect templates (4.7): init_as_subobj template auto-creates a subobject of class given by classname, hides the connect by default (configuration set to \"none\"), inherits init and connect; warning about SIM_get_class failing if subobject class is defined later in the same module and recommendation to move it to a separate module.\n\n- Interface objects (4.8): interface template has parameter required (defaults to true); when optional, parent connect can attach to objects not implementing the interface; provides a session variable val (const void *) pointing to the connected object's Simics interface struct (NULL if optional and not implemented).\n\n- Port objects (4.9) and Subdevice objects (4.10): both expose an obj parameter that evaluates differently depending on Simics API version \u2014 to dev.obj for API \u22645 and to a conf_object_t * (port/subdevice object) for API 6+.\n\n- Implement objects and templates (4.11\u20134.12): implement template is minimal; one implement template bank_io_memory redirects io_memory interface access to a specified bank (bank objects implement io_memory inheriting this template).\n\n- Bank objects (4.13): inherit shown_desc; key methods:\n  - io_memory_access(memop, offset, aux) -> bool: entry for generic_transaction_t-based accesses; can decode memop and pass aux to lower-level methods.\n  - transaction_access(t, offset, aux) -> exception_type_t: entry for transaction interface, returns Sim_PE_No_Exception or Sim_PE_IO_Not_Taken; large accesses split into chunks.\n  - write(offset, value, enabled_bytes, aux) throws: default forwards to registers; details on hit registers, unmapped_write called for uncovered portions, and ordering of write_register calls.\n  - unmapped_write(offset, value, bits, aux) throws: called for uncovered write portions; default logs and throws.\n  - read(offset, enabled_bytes, aux) -> value throws: decomposed like write, combines read_register results and unmapped_read.\n  - unmapped_read(offset, bits, aux) throws: default unconditionally throws.\n  Bank parameters controlling behavior:\n  - mappable [boolean] (default true): visibility as io_memory port.\n  - overlapping [bool]: allow accesses spanning multiple registers; must be uniform across bank array.\n  - partial [bool]: allow partial-register accesses and how they are handled; must be uniform across bank array.\n  - register_size [integer|undefined]: default register size inherited from device.\n  - byte_order [string]: \"little-endian\" or \"big-endian\"; must be uniform across bank array.\n  - be_bitorder [bool]: presentation hint for bit numbering within registers.\n  - use_io_memory [bool]: choose legacy io_memory vs transaction interface; default from dev.use_io_memory.\n  - obj [conf_object_t *]: API-version-dependent evaluation (dev.obj vs bank's port object).\n\n- Register objects (4.14): inherit many templates (get, set, shown_desc, read_register, write_register, init_val); key parameters:\n  - val [integer]: register contents (unsafe to write values larger than capacity).\n  - size [integer]: width in bytes (default from bank.register_size; can use \"size n\" shorthand).\n  - bitsize [integer]: width in bits (size*8, not overridable).\n  - offset [integer]: byte offset within bank (can use \"@ n\" shorthand); no default; note interrupted sentence about unmapped template inheritance."
            },
            {
              "title": "4.11 Implement objects",
              "start_index": 87,
              "end_index": 89,
              "node_id": "0134",
              "summary": "- Bank-level parameters and rules: certain parameters must be identical across elements of a bank array (must not depend on index).\n- be_bitorder: presentation hint controlling preferred bit numbering for registers (false = LSB=bit0, true = MSB=bit0); does not affect model semantics and is separate from top-level bitorder.\n- use_io_memory: selects legacy io_memory interface (io_memory_access allowed) vs. transaction interface (transaction_access allowed); default inherited from dev.use_io_memory.\n- obj: compatibility alias that evaluates to dev.obj for Simics API \u22645 and to the bank's port object for API \u22656.\n- Register objects: inherit many common templates (get, set, shown_desc, read_register, write_register, init_val). Key parameters include:\n  - val: register contents (direct writes can be unsafe if out-of-range).\n  - size and bitsize: width in bytes and bits; bitsize derived from size.\n  - offset: byte offset in containing bank (must be constant across bank array elements; unmapped if inheriting unmapped).\n  - fields: list of contained field objects.\n  - init_val, configuration, persistent, internal and defaults/meanings.\n- Register methods for unmapped bits:\n  - read_unmapped_bits(unmapped_enabled_bits, aux): default masks and returns bits not covered by fields; can have side effects.\n  - write_unmapped_bits(val, enabled_bits, aux): default compares unmapped bits and logs spec-viol messages for mismatches without modifying val.\n- Field objects: inherit init_val and shown_desc, and implement get/set/init. Key parameters:\n  - val: bitslice value (safer to manipulate than register.val).\n  - reg: reference to containing register.\n  - lsb and msb: required bit indices in little-endian bit numbering; use [high:low] shorthand sensitive to file bitorder; caution when mixing big-endian numbering.\n  - bitsize (derived) and init_val.\n- Templates for registers and fields: shared templates (read, write, get, set) and use of void *aux to carry extra access info (set via bank io_memory_access).\n- get_val and set_val templates:\n  - get_val(): non-overridable; returns register .val or field bits from parent register; unaffected by overrides of get.\n  - set_val(uint64): non-overridable; sets register .val or field bits in parent register."
            },
            {
              "title": "4.12 Implement templates",
              "start_index": 89,
              "end_index": 90,
              "node_id": "0135",
              "summary": "- Parameters and field/register members:\n  - val: bitslice of the parent register corresponding to the field; manipulating val is simpler than using get_val()/set_val() but val is not a member of the field template type and has limited contexts.\n  - reg: reference to the containing register object.\n  - lsb, msb: required integers giving the field\u2019s least and most significant bit positions in the containing register, represented in little-endian bit order; preferred to use [highbit:lowbit] shorthand and be careful with big-endian files.\n  - bitsize: automatically computed width from lsb/msb (cannot be overridden).\n  - init_val: default initialization value for device instantiation and default hard/soft/power-on resets (defaults to 0).\n\n- Templates for registers and fields (section overview):\n  - Most templates apply to both registers and fields (except read_register and write_register which are registers-only).\n  - When authoring shared templates, one typically inherits read, write, get and set methods.\n  - Many access methods accept an optional void *aux parameter (default NULL) for extra access context; banks can override io_memory_access to set this.\n\n- get_val / set_val:\n  - get_val(): non-overrideable; returns .val for registers or the corresponding bits of the parent register for fields. Unaffected by overrides of get.\n  - set_val(uint64): non-overrideable; sets .val for registers or the corresponding field bits in the parent. Unaffected by overrides of set.\n  - Both are slightly more efficient than their overrideable counterparts but less flexible; general advice is to prefer get/set.\n\n- get / set:\n  - get(): overrideable; default implementation calls get_val(); used for checkpointing/inspection and should have no side effects.\n  - set(uint64): overrideable; default implementation calls set_val(); used for checkpointing/inspection without side effects.\n  - For fields, these templates must be explicitly instantiated for overrides to take effect, although a callable default exists.\n\n- read_register (register-only):\n  - Abstract method read_register(uint64 enabled_bytes, void *aux) -> uint64; may have side-effects and returns value in host endianness.\n  - enabled_bytes is a byte-wise bitmask indicating which bytes of the register are accessed; bytes of the return are significant only where enabled_bytes has 0xff. Parts corresponding to other registers are zero if access spans registers.\n  - Default register implementation: invokes read_field on all sub-fields at least partially covered by enabled_bytes in order from least to most significant bit; for bits not covered by fields, calls read_unmapped_bits with unmapped_enabled_bits. If no fields, read_unmapped_bits is not called by default.\n  - If a register inherits read_field or read templates, those take precedence over read_register.\n\n- write_register (register-only):\n  - Abstract method write_register(uint64 value, uint64 enabled_bytes, void *aux); enabled_bytes defined same as for read_register.\n  - Default behavior depends on whether the register has fields (further details follow beyond the partial text)."
            },
            {
              "title": "4.13 Bank objects",
              "start_index": 90,
              "end_index": 86,
              "node_id": "0136",
              "summary": "The partial document contains no substantive content or topics to summarize \u2014 it is empty and presents no main points."
            },
            {
              "title": "4.14 Register objects",
              "start_index": 86,
              "end_index": 88,
              "node_id": "0137",
              "summary": "- Behavior of register access methods: write_register is invoked for each hit register starting at the lowest offset; read decomposes accesses similarly and composes results from read_register and unmapped_read; unmapped_write/unmapped_read are called when accesses include unmapped portions (unmapped_write logs a spec-viol message and throws by default; unmapped_read throws by default). Throwing aborts the access.\n\n- Semantics of access decomposition: bits parameter encodes affected bits/bytes (host endianness); value contains the original written value including mapped parts; partial and overlapping accesses are described (partial reads/writes operate on touched fields or whole register if no fields).\n\n- Bank template parameters and meanings:\n  - mappable: whether bank is visible as an io_memory interface port (defaults to true).\n  - overlapping: whether accesses may cover >1 register (defaults to true); must be uniform across bank array.\n  - partial: whether partial-register accesses are allowed (defaults to true); must be uniform across bank array.\n  - register_size: default size for contained registers (inherited from device).\n  - byte_order: \"little-endian\" or \"big-endian\" for multi-byte register accesses; must be uniform across bank array.\n  - be_bitorder: presentation hint for bitfield ordering (bit 0 = LSB if false, MSB if true); does not affect model semantics.\n  - use_io_memory: selects legacy io_memory vs transaction interface and which access method may be overridden (defaults from dev.use_io_memory).\n  - obj: compatibility mapping to dev.obj or bank port object depending on Simics API version.\n\n- Register template: inherits get/set/shown_desc/read_register/write_register/init_val and defines:\n  - val, size (bytes), bitsize (size*8), offset (byte offset within bank), fields (list of field refs), init_val (used for init/hard/soft/power-on reset, default 0).\n  - configuration (attribute creation policy), persistent, internal flags.\n  - Constraints: offset and some bank parameters must be constant across bank array elements; writing beyond register width via val is undefined behavior (use set_val/get_val instead).\n\n- Register methods for unmapped bits:\n  - read_unmapped_bits(unmapped_enabled_bits): default masks register value by unmapped_enabled_bits and returns it (can have side effects).\n  - write_unmapped_bits(val, enabled_bits): default compares provided bits to register bits and logs spec-viol messages for mismatches but does not modify val.\n\n- Field objects: inherit object, init_val, shown_desc and methods get, set, init; define a val parameter for field storage."
            },
            {
              "title": "4.15 Field objects",
              "start_index": 88,
              "end_index": 88,
              "node_id": "0138",
              "summary": "Describes register and field template parameters and behaviors: specifies that a register\u2019s address mapping parameter must be constant across a bank, lists the fields reference, and details init_val (integer, defaults to 0) used for init and reset methods; configuration (\"required\"|\"optional\"|\"pseudo\"|\"none\") for how Simics treats the auto-created attribute, and persistent/internal boolean flags (internal defaults to true). Documents overridable register methods read_unmapped_bits(uint64 unmapped_enabled_bits, void *aux) and write_unmapped_bits(uint64 val, uint64 enabled_bits, void *aux), their default behaviors (masking unmapped regions on read; comparing unmapped bits on write and logging spec-viol messages for mismatches), and when they are invoked. Begins the field-objects section, noting the field template inherits init_val and shown_desc, inherits methods get, set and init, and includes a val [integer] parameter."
            },
            {
              "title": "4.16 Templates for registers and fields",
              "start_index": 88,
              "end_index": 89,
              "nodes": [
                {
                  "title": "4.16.1 get_val",
                  "start_index": 89,
                  "end_index": 89,
                  "node_id": "0140",
                  "summary": "Summary of main points covered:\n\n- Explanation of the field bitslice and the val convenience (manipulating val as a simpler alternative to get_val()/set_val(), but val is not a member of the field template type and so has usage limitations).\n- reg reference: reg always refers to the containing register object.\n- lsb and msb parameters: required integers giving the least and most significant bit numbers of the field in the containing register; represented in little-endian bit order regardless of file bitorder declarations; recommended to use the \u201c[highbit:lowbit]\u201d shorthand for ranges; caution advised when working in big-endian numbering (prefer separate file using little-endian interpretation).\n- bitsize: automatically computed width of the field from lsb and msb and cannot be overridden.\n- init_val: initialization value used by default init, hard reset, soft reset and power-on reset implementations; defaults to 0.\n- Section 4.16: templates for registers and fields \u2014 templates applicable to both registers and fields (except read_register and write_register); when writing templates for both, normally inherit read/write/get/set methods.\n- io_memory_access aux argument: some template methods accept void *aux (default NULL) which can be set by overriding the parent bank\u2019s io_memory_access to carry extra access information.\n- get_val: non-overridable get_val() -> uint64 method that returns .val for registers or the corresponding parent-register bits for fields; similar to get but unaffected by overrides of get (slightly more efficient but less flexible); general recommendation is to use get.\n- set_val: non-overridable set_val(uint64) method that sets .val for registers or the covered bits in the parent register for fields (partial description in the excerpt)."
                },
                {
                  "title": "4.16.2 set_val",
                  "start_index": 89,
                  "end_index": 89,
                  "node_id": "0141",
                  "summary": "- Describes field/register parameters and semantics: reg (reference to containing register), lsb and msb (required bit positions, represented in little-endian bit order; preferred [high:low] shorthand and caution about big-endian files), bitsize (derived from lsb/msb and not overridable), and init_val (default value used by init, hard/soft reset and power-on reset; defaults to 0).\n- Explains the bitslice concept: val refers to the bitslice of the parent register corresponding to a field; manipulating val is simpler and as safe as get_val()/set_val() for fields, but val is not a member of the field template type and so cannot be used in all contexts.\n- Introduces section 4.16 on templates for registers and fields: most templates apply to both registers and fields (except read_register and write_register); when writing shared templates one should typically inherit read/write/get/set methods.\n- Notes the optional void *aux access argument (default NULL) that can carry extra access information and can be set by overriding a parent bank's io_memory_access method.\n- Documents get_val(): a non-overrideable method returning the register .val or the field\u2019s covered bits; similar to get but unaffected by get overrides (hence slightly more efficient but less flexible), and generally get is recommended.\n- Documents set_val(): a non-overrideable method that sets the register .val or the field\u2019s bits in the parent register\u2019s val."
                },
                {
                  "title": "4.16.3 get",
                  "start_index": 89,
                  "end_index": 97,
                  "node_id": "0142",
                  "summary": "Summary of main points in the partial document:\n\n- Field parameters and basics: definition of bitslice, reg (parent register reference), lsb, msb, bitsize (derived), and init_val (default reset/init value).\n- Overview of register/field template system: templates can be applied to registers and fields; some templates are register-only; templates may be overrideable or non-overrideable; io access can carry aux data.\n- get_val and set_val: non-overrideable methods that directly read/write the underlying .val (or the field bits within the parent register); more efficient but less flexible than get/set.\n- get and set: overrideable methods that default to get_val/set_val; in fields they must be explicitly instantiated for overrides to take effect.\n- read_register and write_register (register-only): abstract methods with enabled_bytes parameter; default implementations dispatch to read_field/write_field for covered sub-fields and handle unmapped bits; read/write templates or field-level templates take precedence if inherited.\n- read_field and write_field: abstract methods with enabled_bits parameter for bit-level access; not implemented by default and must be instantiated to override; instantiating them on a register causes the register to behave as a single field (ignoring sub-field objects).\n- read and write templates: overrideable high-level access methods that extend read_field/get_val and write_field/get_val/set_val respectively; default behaviors use get/set; instantiating them on registers also makes the register act like a single field.\n- init_val template: parameter controlling initial/reset value for registers/fields; field overrides take precedence for covered bits; default init/reset behavior uses this parameter and recursively applies to sub-objects.\n- Event objects and templates: six event template families (simple, uint64, custom) \u00d7 (time or cycle); methods provided include event (handler), non-overrideable post(), and, for simple/uint64, remove/posting queries/next time; custom events add get_event_info, set_event_info, destroy for checkpoint/restore and cleanup.\n- Standard templates and utility.dml: common register/field behaviors provided (e.g., undocumented/reserved naming differences only); distinction between software (io_memory read/write via read/write methods) and hardware access (Simics configuration via get/set).\n- Reset framework and templates: three reset types (power-on, hard, soft) with corresponding templates and ports (POWER, HRESET, SRESET); default reset restores init_val and recurses into sub-objects; options to customize reset value (soft_reset_val) or suppress resets (sticky, no_reset); guidance on modeling POWER either as a pure reset or as an accurate power supply.\n- Examples of standard register/field modifiers: soft_reset_val (override soft-reset value), ignore_write (silence writes), read_zero (reads return 0), read_only (software writes logged and disallowed while hardware can modify), and notes on how register-level application may ignore field-level implementations."
                },
                {
                  "title": "4.16.4 set",
                  "start_index": 97,
                  "end_index": 98,
                  "node_id": "0143",
                  "summary": "This partial document section describes reset-related callbacks and a set of templates that modify read/write behavior for registers and fields. It notes an implemented reset callback interface (automatically provided for registers and fields) and top-level templates for power-on, hard, and soft resets (por/hreset/sreset mapped to power_on_reset, hard_reset, soft_reset). It explains that many templates can be applied to either registers or fields and that register-level application can override field-level read behavior (example: read_unimpl on a register ignores field read overrides while writes still propagate to fields). Specific templates covered include: soft_reset_val (uses soft_reset_val instead of init_val on soft reset); ignore_write (silences writes, useful for read-only fields within writable registers); read_zero (reads always return 0); read_only and write_only (software write/read restrictions and associated spec_violation logging behavior); write_1_clears (software clears bits by writing 1s); clear_on_read (reads return value then clear it); write_1_only and write_0_only (only set bits to 1 or 0 respectively); and read_constant (reads return a constant read_val while writes and the stored attribute remain unaffected, unlike the constant template which is for non-storing constant registers/fields)."
                },
                {
                  "title": "4.16.5 read_register",
                  "start_index": 98,
                  "end_index": 99,
                  "node_id": "0144",
                  "summary": "Summary of main points covered:\n\n- The section documents register/field access templates that define how reads and writes affect stored values and produce log messages.\n- write_only: register can be written but reads return 0; intended for registers (use read_zero for fields). First read logs a spec_violation at level 1, subsequent reads at level 2.\n- write_1_clears: software clears bits by writing 1s; new value = old_value & ~write_value (used for hardware-set, software-clear acknowledge bits).\n- clear_on_read: reads return the object value and then reset the stored value to 0 as a side-effect.\n- write_1_only / write_0_only: write_1_only lets software set bits (new = old | write); write_0_only lets software clear bits (new = old & write); each references the other as a related template.\n- read_constant: reads always return a specified constant (parameter read_val); writes do not affect the returned read value though backing storage may still change; related to constant, silent_constant, read_zero.\n- constant: object is intended to remain constant; writes are forbidden and have no effect on the intended constant behavior, though backing storage exists and can be modified via the register attribute (survives reset). First write that changes value logs spec_violation level 1, subsequent writes level 2; parameter init_val; related to read_constant and silent_constant.\n- silent_constant: object value remains constant and writes are ignored; end-user tweaks to attribute persist across resets; parameter init_val; related to constant and read_constant.\n- zeros / ones: zeros = constant 0; ones = constant all 1s. Software writes do not update value. First software write that would change value logs spec_violation at level 1, subsequent writes at level 2.\n- Throughout, related-templates and parameters are noted, and log output behavior (spec_violation and log levels) is called out for first vs. subsequent offending accesses."
                },
                {
                  "title": "4.16.6 write_register",
                  "start_index": 99,
                  "end_index": 100,
                  "node_id": "0145",
                  "summary": "This partial document section enumerates and explains a set of register/object \"templates\" that specify read/write behavior, logging and related parameters. It covers constant-type templates (constant, silent_constant, read_constant, zeros, ones) that prevent normal writes (either ignoring them or forbidding them), note whether backing storage exists (allowing user tweaks that survive reset), and specify init_val parameters for initial values. It defines logging semantics for illegal or unexpected accesses (e.g., first offending write/read typically generates a level-1 spec_violation or unimplemented message, with subsequent events logged at level 2 or 3, and some differences for field vs register accesses). It documents templates that suppress functionality or importance (ignore), mark objects as reserved (reserved: writes update value but first write logged), and unimplemented variants (unimpl, read_unimpl, write_unimpl, silent_unimpl) that warn on use and distinguish read vs write unimplemented behavior. Each template entry lists Description, Log Output behavior, Parameters when applicable, and Related Templates to indicate alternative or complementary behaviors."
                },
                {
                  "title": "4.16.7 read_field",
                  "start_index": 100,
                  "end_index": 101,
                  "node_id": "0146",
                  "summary": "The excerpt lists register/object templates and their behaviors: \"ignore\" (reads return 0, writes ignored); \"reserved\" (value stored, first software write logs a spec-viol at level 2); \"unimpl\" and its variants \"read_unimpl\", \"write_unimpl\", \"silent_unimpl\" (unimplemented functionality with detailed logging rules for first vs. subsequent accesses and differences between register vs. field accesses); \"undocumented\" (first access logs spec_violation level 1, subsequent level 2); \"unmapped\" (register excluded from bank address space); \"sticky\" and \"no_reset\" (values preserved across soft/hard resets); and \"design_limitation\" (intentionally out-of-scope, default read/write behavior). The section also records related-template links and begins bank-related templates with \"function_mapped_bank.\""
                },
                {
                  "title": "4.16.8 write_field",
                  "start_index": 101,
                  "end_index": 102,
                  "node_id": "0147",
                  "summary": "This partial document describes several object and bank-related templates and their behaviors. It defines silent_unimpl (unimplemented functionality that uses default reads/writes while minimizing log spam \u2014 first software read/write logs at level 2 and subsequent accesses at level 3; field reads do not log; first differing field write logs at level 2), undocumented (poorly documented objects that use default reads/writes and produce spec_violation logs: first access at level 1, subsequent at level 2), unmapped (register excluded from bank address space), sticky (do not reset object value on soft reset), design_limitation (functionality intentionally out of model scope and left as default reads/writes; related to unimpl and silent_unimpl), and no_reset (value unchanged on hard or soft reset). In the bank-related section it defines function_mapped_bank (bank marked with a function number) and function_io_memory (io_memory implementation that routes memory transactions to a bank with a matching function number, logs an error and reports a miss if none found; notes that function-number mapping is deprecated and distinct from PCI function numbers). It also documents miss_pattern_bank (handles unmapped accesses by ignoring writes and returning a specified byte value for each missed read byte). Finally, the connect-related map_target template is described: it provides a default set implementation assigning a session map_target pointer, a validate implementation that checks SIM_new_map_target, and exposes methods such as read(uint64 addr, uint64 size) -> (uint64) throws for issuing memory transactions."
                },
                {
                  "title": "4.16.9 read",
                  "start_index": 102,
                  "end_index": 92,
                  "node_id": "0148",
                  "summary": "No partial document text was provided, so no main points can be identified."
                },
                {
                  "title": "4.16.10 write",
                  "start_index": 92,
                  "end_index": 92,
                  "node_id": "0149",
                  "summary": "- read and write templates: neither is implemented by fields or registers by default and must be explicitly instantiated to take effect; each provides an overridable method (read(uint64) and write(uint64)) that perform the access and may have side effects.  \n- Register-level instantiation of read or write makes the register behave as a single field: reads/writes will ignore any actual field subobjects.  \n- write template extends write_field, get_val, and set_val; values are passed in the host's native endianness and the default write behavior uses the set method.  \n- init_val: a template parameter (uint64) that defines the initial value of a register's val member or, for a field, the initial bits of the parent's val. Default is 0 and the template is inherited by both registers and fields.  \n- init_val override precedence: a register-only override sets the full register value; if both register and field overrides exist, field overrides take precedence for the bits they cover. Technically, a field\u2019s default init_val is taken from the corresponding bits of the parent register\u2019s init_val, and the init implementation sets bits not covered by fields in registers and sets corresponding parent bits in fields.  \n- Event objects: the event template itself provides little functionality and must instantiate one of six predefined event templates (simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event), which expose methods like event and post. The event template also inherits shown_desc."
                },
                {
                  "title": "4.16.11 init_val",
                  "start_index": 92,
                  "end_index": 92,
                  "node_id": "0150",
                  "summary": "Summarizes template behavior for register/field access and initialization and introduces event object templates. Key points:\n- read template: extends read_field/get_val/set_val, provides an overridable read(uint64) method; value in host endianness; default uses get; not implemented by fields/registers unless explicitly instantiated; instantiating read on a register makes the register behave as a single field (ignores subfield objects).\n- write template: mirrors read (extends write_field/get_val/set_val), provides overridable write(uint64); value in host endianness; default uses set; also not enabled by default and has the same \u201csingle-field\u201d effect if instantiated on a register.\n- init_val template: extends init and supplies init_val : uint64 to define initial register val or field-covered bits; inherited by registers and fields, default 0; supports overrides in both register and field with field overrides taking precedence for covered bits; technically a field\u2019s default init_val is taken from the parent register\u2019s corresponding bits and the template provides default init behavior to set bits not covered by fields (for registers) or to set parent register bits (for fields).\n- Event objects: the event template is minimal and requires instantiation of one of six predefined event templates (simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event), which expose methods like event and post; the event template also inherits shown_desc. The document begins to list definitions for those six templates."
                }
              ],
              "node_id": "0139",
              "summary": "- Describes register parameters and attributes: fields (list of field references), init_val (default/reset value, defaults to 0), configuration (how Simics treats the register attribute: \"required\" | \"optional\" | \"pseudo\" | \"none\", default \"optional\"), persistent (bool), internal (bool, default true). Notes that a register may be unmapped to an address and that bank-array related parameters must be identical across array elements.\n- Explains register template overridable methods for handling bits not covered by declared fields:\n  - read_unmapped_bits(uint64 unmapped_enabled_bits, void *aux) -> uint64: default masks and returns unmapped bits; can implement side effects.\n  - write_unmapped_bits(uint64 val, uint64 enabled_bits, void *aux): default compares provided unmapped bits with the register value and logs spec-viol messages for mismatches without modifying val.\n- Introduces field objects: inheritance (object, init_val, shown_desc), and inherited methods get, set, init; notes init_val is used for instantiation and resets (default 0).\n- Lists field parameters: val (bitslice convenience accessor), reg (reference to containing register), lsb and msb (required; bit positions in little-endian bit numbering; recommends using [high:low] shorthand and warns about big-endian files), bitsize (auto-derived from lsb/msb), init_val.\n- Covers templates common to registers and fields: most templates (except read_register/write_register) apply to both; when writing shared templates, inherit read/write/get/set methods. Notes io-related methods may receive a void *aux (default NULL) which can be set by overriding parent bank's io_memory_access.\n- Details get_val and set_val templates:\n  - get_val(): non-overridable; returns .val for a register or the parent register bits covered by a field. Unlike get, get_val is unaffected by get overrides and is slightly more efficient but less flexible.\n  - set_val(uint64): non-overridable; sets .val in a register or the corresponding bits in the parent register for a field."
            },
            {
              "title": "4.17 Event objects",
              "start_index": 92,
              "end_index": 92,
              "node_id": "0151",
              "summary": "- Read/write templates: both extend lower-level templates (read_field/get_val/set_val for read; write_field/get_val/set_val for write) and provide a single overridable method (read(uint64) / write(uint64)). Values use the host's native endianness; defaults call the get/set methods. Neither template is instantiated by fields or registers by default and must be explicitly instantiated to take effect. Instantiating read or write on a register makes the register behave as a single field and causes accesses to ignore any actual field subobjects.\n\n- init_val parameter: a template parameter init_val : uint64 defines the initial value of a register's val member (or the bits covered by a field). It is inherited by both registers and fields and defaults to 0. Overrides are permitted at register and field levels: a register-only override defines the full register value; field overrides take precedence for the bits they cover. Technically, a field's default init_val is derived from the corresponding bits of its parent register's init_val, and the init template supplies a default init method that sets register bits not covered by fields and sets the corresponding parent register bits for fields.\n\n- Event objects and templates: the event template itself contains little functionality and requires instantiation of one of six predefined templates\u2014simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, or custom_cycle_event\u2014which expose methods such as event and post (and possibly others). The event template also inherits shown_desc."
            },
            {
              "title": "4.18 Event templates",
              "start_index": 92,
              "end_index": 94,
              "node_id": "0152",
              "summary": "- read and write templates:\n  - Both extend lower-level templates (read_field/write_field, get_val/set_val) and provide overrideable methods read(uint64) and write(uint64).\n  - Defaults set/replace value using set method; value is in host endianness.\n  - Not implemented by fields or registers by default \u2014 must be explicitly instantiated for overrides to take effect.\n  - Instantiating read or write on a register makes the register behave as a single field: accesses ignore any actual field subobjects.\n\n- init_val template:\n  - Extends init and supplies parameter init_val : uint64 to define initial register (or field-covered bits) value; default is 0.\n  - In registers with fields, overrides may be applied at register level (defines full register) or at field level (field overrides take precedence for covered bits).\n  - Default init implementation sets bits in register val not covered by fields and field objects set corresponding bits of parent register val.\n\n- Event objects and inheritance:\n  - The event template itself is minimal and requires instantiation of one of six predefined event templates.\n  - Event template also inherits shown_desc.\n\n- Six event templates and their semantics:\n  - simple_time_event / simple_cycle_event: events carrying no data.\n  - uint64_time_event / uint64_cycle_event: events carrying a single uint64 data value.\n  - custom_time_event / custom_cycle_event: events carrying complex data; user supplies serialization/deserialization.\n  - time templates use seconds as a floating-point time; cycle templates use cycles as a 64-bit integer.\n\n- Common methods provided by all six templates:\n  - event(), event(uint64 data), event(void *data): abstract handlers called when event triggers (custom variants must free data if appropriate).\n  - post(time), post(time, uint64 data), post(time, void *data): non-overridable methods to post an event to the device queue; time units depend on template; data passed through to event().\n\n- Methods specific to simple_* and uint64_* templates:\n  - remove(), remove(uint64 data): remove matching pending events.\n  - posted() -> bool, posted(uint64 value) -> bool: check whether such an event is queued.\n  - next(), next(uint64 data) -> (double or cycles_t): time until next occurrence (relative); returns negative if none queued.\n\n- Methods specific to custom_* templates:\n  - get_event_info(void *data) -> attr_value_t: produce checkpointable attribute for each pending event (default returns nil).\n  - set_event_info(attr_value_t info) -> void *: restore event user-data from checkpoint info (default only accepts nil).\n  - destroy(void *data): called for posted events when the device object is deleted; must free any allocated memory. destroy is not called automatically when an event triggers and should normally be called from event() as needed."
            },
            {
              "title": "5 Standard Templates",
              "start_index": 95,
              "end_index": 95,
              "nodes": [
                {
                  "title": "5.1 Templates for reset",
                  "start_index": 95,
                  "end_index": 96,
                  "nodes": [
                    {
                      "title": "5.1.1 power_on_reset, hard_reset, soft_reset",
                      "start_index": 96,
                      "end_index": 96,
                      "node_id": "0155",
                      "summary": "This partial document section (5.1.1 power_on_reset, hard_reset, soft_reset) explains reset behavior and templates for devices: default templates power_on_reset, hard_reset and soft_reset restore registers/fields to their init_val and can be customized by overriding methods (including signal_raise/signal_lower to add side effects). The default reset implementation recursively invokes resets on sub-objects, so overriding a reset without calling default() suppresses resets in sub-objects. Two common customizations are changing the reset value (via method override or the soft_reset_val parameter for soft resets) and suppressing resets (using the sticky template to suppress soft resets or no_reset to suppress all resets). Guidance on port naming is given: if hard and power-on resets are identical, prefer only an HRESET port so a POWER port signals distinct power-cycle behavior. Less common cases include renaming SRESET to device-specific ports when multiple \u201csoft\u201d resets exist, and accurately modeling powered-off behavior by treating POWER high as powered (low means device unresponsive and causes a reset on lowering). Two modes of treating POWER are described: as a simple reset signal toggled for power-on resets (convenient but less accurate) or as an actual power supply signal that is high before simulation and causes a reset on low\u2192high (more correct but harder to implement)."
                    },
                    {
                      "title": "5.1.2 por eset, hr eset, sr eset",
                      "start_index": 96,
                      "end_index": 97,
                      "node_id": "0156",
                      "summary": "- Reset framework and default behavior: describes power_on_reset, hard_reset and soft_reset callbacks implemented on objects (automatically for registers/fields), with default behavior restoring init_val and recursive calls into sub-objects; warns that overriding without calling default() suppresses sub-object resets. signal_raise/signal_lower can be overridden for reset side effects (e.g., tracking asserted reset).\n\n- Common reset overrides: how to change reset values (explicit override or soft_reset_val parameter for soft reset) and how to suppress resets using standard templates (sticky to suppress soft reset, no_reset to suppress all resets).\n\n- Port naming and recommendations: guidance to create only HRESET if hard and power-on resets are identical; preserve POWER and HRESET names when meaningful; replace SRESET with device-specific names if needed.\n\n- Simulating power-off: recommends treating POWER signal high as powered, low as power-down (device reset on POWER low); notes two approaches to POWER handling \u2014 treat POWER as a pure reset port (convenient but inaccurate if modeling power supply) or treat it as an actual power supply (accurate: raised before simulation, lowered on power down, reset on low\u2192high transitions).\n\n- Top-level reset entry points: poreset/hrset/srset described as top-level standard reset behaviors; related templates listed (power_on_reset, hard_reset, soft_reset).\n\n- Templates for registers and fields: explains that many templates affect reads or writes and that register-level templates can override field-level behavior for reads (example: read_unimpl on a register ignores field read implementations and returns the register value, while writes still propagate to fields).\n\n- Specific templates documented:\n  - soft_reset_val: sets soft-reset value via parameter instead of init_val.\n  - ignore_write: makes writes ignored (useful for read-only fields inside writable registers).\n  - read_zero: reads always return 0; writes unaffected.\n  - read_only: makes object read-only to software but writable by hardware; documents log behavior (first software write logs spec_violation at level 1, subsequent writes at level 2; fields log only on value change) and suggests using ignore_write when a register contains both writable and read-only fields."
                    }
                  ],
                  "node_id": "0154",
                  "summary": "- Introduces the DML standard templates (from utility.dml) usable for both registers and fields; many templates share functionality and differ mainly by name/log messages (e.g., undocumented vs reserved).\n- Clarifies terminology: \"object\" denotes a register or field; distinguishes software reads/writes (via io_memory using DML read/write) from hardware reads/writes (via Simics configuration attributes using DML set/get). Notes device code can still modify registers even when hardware modification is prohibited.\n- Describes reset-related templates and behaviors. DML has no built-in reset handling, so utility.dml provides common reset templates to cover typical mechanisms.\n- Defines three reset types: power-on reset, hard reset, and soft reset (software-induced). Explains typical semantics (registers restored to predefined values).\n- Explains how to enable reset types by instantiating templates poreset, hreset, sreset, which create ports POWER, HRESET, SRESET and invoke corresponding methods (power_on_reset, hard_reset, soft_reset) on rising edges.\n- Describes default reset behavior: registers/fields implement reset templates by default and restore to init_val; reset methods call recursively into sub-objects; overriding a reset method without calling default() suppresses sub-object resets.\n- Explains customization and suppression: override methods to change reset values; soft_reset_val template to configure soft-reset values; sticky suppresses soft reset only; no_reset suppresses all resets.\n- Gives guidance on POWER vs HRESET usage: prefer creating only HRESET if hard reset == power-on reset; preserve POWER/HRESET names when mapping to hardware if unambiguous.\n- Discusses modeling power-off state: recommend treating POWER high as powered, low as power-off; device reset on POWER lowering; two modeling strategies\u2014treat POWER as a pure reset port (convenient) or as an accurate power supply (more correct but more work).\n- Indicates upcoming section 5.1.1 will cover power_on_reset, hard_reset, soft_reset in detail."
                },
                {
                  "title": "5.2 Templates for registers and fields",
                  "start_index": 97,
                  "end_index": 97,
                  "nodes": [
                    {
                      "title": "5.2.1 soft_reset_val",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0158",
                      "summary": "This partial document describes reset-related callbacks and behavior templates for registers and fields. It notes that objects implement reset callbacks automatically (registers and fields), and that top-level templates exist for power-on, hard, and soft resets (power_on_reset, hard_reset, soft_reset). It explains how templates applied to registers vs fields interact (e.g., a register-level read_unimpl will ignore field-level read implementations but writes still propagate to fields). It enumerates several templates and their effects: soft_reset_val (uses a specified soft reset value instead of init_val), ignore_write (ignores writes, useful for read-only fields within writable registers), read_zero (reads always return 0), and read_only (software writes are disallowed but hardware may modify; first software write logs a spec_violation at level 1 and subsequent writes at level 2, with field logging only on value change)."
                    },
                    {
                      "title": "5.2.2 ignore_write",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0159",
                      "summary": "- Reset callbacks:\n  - A generic reset-callback template is implemented on any object to receive a callback on its corresponding reset event; registers and fields get this automatically.\n  - Top-level reset templates (poreset, hreset, sreset) provide standard reset behavior for power-on, hard, and soft reset and relate to the power_on_reset, hard_reset, and soft_reset implementations.\n\n- General notes on register/field templates:\n  - Many templates apply to both registers and fields and typically affect either read or write behavior.\n  - When a template is applied to a register, it can override or disregard field-level implementations for the affected operation. Example: applying a read_unimpl-like behavior on a register will ignore field read/read_field overrides and return the register\u2019s current value (via get), while writes still propagate to fields.\n\n- Specific templates covered:\n  - soft_reset_val: Applied to a register or field to define the reset value on soft reset via the soft_reset_val parameter instead of the default init_val. Related to the soft_reset template.\n  - ignore_write: Causes software writes to be ignored; useful for making individual fields read-only inside otherwise writable registers (alternative to read_only in some mixed cases).\n  - read_zero: Makes reads always return 0 regardless of the stored value; writes are unaffected. Related to read_constant.\n  - read_only: Marks the object as read-only for software (hardware may still modify it). Logging behavior: the first software write triggers a spec_violation log at level 1, subsequent writes log at level 2; field-level logs occur only if the written value differs from the old value. For registers containing both read-only and writable fields, ignore_write may be preferable since software often doesn\u2019t care about the written value."
                    },
                    {
                      "title": "5.2.3 read_zero",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0160",
                      "summary": "Summary of main points covered:\n\n- Reset callback interface: description of an interface implemented on objects to receive reset event callbacks; registers and fields implement this automatically.\n- Top-level reset templates: power-on, hard, and soft reset behaviors (por, hreset, sreset) implemented at the top level for standard reset handling.\n- Template application rules: templates can be applied to both registers and fields; many affect read or write behavior. When applied to a register, some templates override or ignore field-level read implementations (example: read_unimpl causes register reads to return the register value and ignore field read overrides), while writes may still propagate to fields.\n- soft_reset_val: when applied to a register or field, soft reset uses the specified soft_reset_val instead of the default init_val; related to the soft_reset template.\n- ignore_write: makes writes ignored; useful for read-only fields inside writable registers; referenced as an alternative to read_only when appropriate.\n- read_zero: makes reads always return 0 regardless of stored value; writes are unaffected; related to read_constant.\n- read_only: marks object value as read-only for software but writable by hardware; documents logging behavior (first software write logs spec_violation at level 1, subsequent writes at level 2) and that fields only log when the written value differs from the old value. Advises using ignore_write if a register contains both read-only and writable fields to avoid undesired behavior."
                    },
                    {
                      "title": "5.2.4 read_only",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0161",
                      "summary": "This partial document describes several register/field templates and reset-related behaviors. It explains a generic reset-callback template implemented on any object (automatically provided for registers and fields) and top-level templates for standard resets (power-on, hard, soft) with related template names. It notes that many templates apply to both registers and fields and typically affect either read or write operations; when applied to a register they can override or ignore per-field implementations for the affected operation (example: a register-level read_unimpl causes reads to return the register value via get and ignore field read overrides, while writes still propagate to fields). Specific templates covered include:\n- soft_reset_val: sets the reset value used on soft reset via a required soft_reset_val parameter instead of the default init_val (related to soft_reset).\n- ignore_write: causes writes to be ignored (useful for making specific fields effectively read-only inside writable registers; see read_only for more context).\n- read_zero: makes reads always return zero while leaving writes unaffected (related to read_constant).\n- read_only: makes the object read-only for software while allowing hardware modifications; documents logging behavior (first software write logs as spec_violation at level 1, subsequent writes at level 2; fields only log when the written value differs from the old value) and notes that ignore_write may be preferable for read-only fields inside otherwise writable registers."
                    },
                    {
                      "title": "5.2.5 write_only",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0162",
                      "summary": "Summary of covered points:\n\n- Reset callback interfaces: An implemented callback on any object to receive reset events; registers and fields automatically implement it. Related templates: poreset, hreset, sreset.\n- Top-level reset templates: Standard reset behaviors for power-on, hard, and soft resets implemented at top level. Related templates: power_on_reset, hard_reset, soft_reset.\n- Template application rules for registers and fields: Many templates affect read or write operations; when applied to a register they override field read implementations (e.g., read_unimpl on a register ignores field read overrides and returns the register value via get), while writes still propagate to fields.\n- soft_reset_val: Defines the reset value used on soft reset (soft_reset_val parameter) instead of the default init_val. Related template: soft_reset.\n- ignore_write: Causes writes to be ignored; useful for making fields effectively read-only inside otherwise writable registers (see read_only for more).\n- read_zero: Reads always return 0 regardless of stored value; writes remain unaffected. Related template: read_constant.\n- read_only: Software cannot modify the object value (hardware can); the first software write logs a spec_violation at log level 1, subsequent writes log at level 2. For fields, logging occurs only if the written value differs from the old value. If a register contains both read-only and writable fields, ignore_write may be preferable for fields."
                    },
                    {
                      "title": "5.2.6 write_1_clears",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0163",
                      "summary": "Summary of main points in the partial document:\n\n- Reset-callback template: a generic reset callback can be implemented on any object to receive reset-event callbacks; registers and fields automatically implement it.\n- Top-level reset templates: distinct templates for standard resets (power-on, hard, soft) are provided (por/hreset/sreset mapped to power_on_reset, hard_reset, soft_reset).\n- Template scope rules: many templates apply to both registers and fields; when applied to a register they can override field-level read implementations (e.g., read_unimpl on a register ignores field read overrides), while writes still propagate to fields.\n- soft_reset_val: a template for registers/fields that defines the reset value used on soft reset via the soft_reset_val parameter instead of the default init_val (related to soft_reset).\n- ignore_write: makes writes ignored\u2014useful for implementing read-only behavior for individual fields inside writable registers (see read_only for comparison).\n- read_zero: makes reads always return 0 regardless of stored value; writes are unaffected (related to read_constant).\n- read_only: marks an object as read-only to software (hardware may modify it); software write attempts produce spec_violation log messages (first at log-level 1, subsequent at level 2); fields only log if the written value differs. For mixed registers (read-only field plus writable fields), ignore_write may be preferable since software often ignores written values."
                    },
                    {
                      "title": "5.2.7 clear_on_read",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0164",
                      "summary": "This partial document describes reset- and access-related templates for register/field objects. It first covers a generic reset callback interface (automatically implemented for registers and fields) and top-level reset templates for power-on, hard, and soft resets (related templates: power_on_reset, hard_reset, soft_reset). It then introduces templates that can be applied to both registers and fields, noting that many affect read or write behavior and that applying a template to a register can override field-level implementations (example: read_unimpl on a register ignores field read overrides but writes still propagate). Specific templates documented include:\n- soft_reset_val: on soft reset, use the soft_reset_val parameter as the reset value instead of the default init_val (related: soft_reset).\n- ignore_write: causes writes to be ignored (useful for making individual fields effectively read-only inside writable registers; see read_only).\n- read_zero: makes reads always return 0 while leaving writes unaffected (related: read_constant).\n- read_only: makes the object read-only for software while allowing hardware modifications; documents logging behavior for software write attempts (first write generates a spec_violation at log-level 1, subsequent writes at log-level 2, and fields only log when the written value differs from the prior value). The section is truncated mid-explanation about choosing ignore_write versus read_only for registers containing mixed writable and read-only fields."
                    },
                    {
                      "title": "5.2.8 write_1_only",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0165",
                      "summary": "- Section 5.1.1: A reset-callback template is implemented on any object to receive the corresponding reset event; registers and fields get this automatically. Related templates: poreset, hreset, sreset.\n- Section 5.1.2: Top-level reset templates (poreset, hreset, sreset) provide standard behavior for power-on reset, hard reset, and soft reset. Related templates: power_on_reset, hard_reset, soft_reset.\n- Section 5.2: Templates applicable to both registers and fields, most affecting read or write behavior. When applied to a register, register-level templates can override/ignore field-level read implementations (e.g., read_unimpl), though writes still propagate to fields.\n- soft_reset_val: Applied to a register or field to specify a soft reset value (soft_reset_val) that overrides the default init_val. Related: soft_reset.\n- ignore_write: Writes are ignored; useful for making individual fields effectively read-only inside otherwise writable registers (see read_only for more detail).\n- read_zero: Reads always return 0 regardless of stored value; writes are unaffected. Related: read_constant.\n- read_only: The object is read-only to software but can be modified by hardware. Software writes produce log messages: the first write logs a spec_violation at level 1, subsequent writes at level 2; fields log only if the written value differs from the previous value. For registers mixing read-only and writable fields, ignore_write may be preferable."
                    },
                    {
                      "title": "5.2.9 write_0_only",
                      "start_index": 97,
                      "end_index": 98,
                      "node_id": "0166",
                      "summary": "This partial document section covers reset callbacks and a set of templates that modify register/field read/write/reset behavior. Main points:\n- Reset callbacks: description of an implemented callback for reset events (automatically for registers and fields) and top-level templates for standard resets: power-on reset, hard reset, and soft reset.\n- General note that many templates apply to both registers and fields; when applied to a register they can override or ignore field-level read implementations (writes still propagate to fields).\n- Templates for soft reset and reset values:\n  - soft_reset_val: defines a soft-reset value (soft_reset_val) used instead of init_val; related to soft_reset.\n- Templates that affect writes/reads and side effects:\n  - ignore_write: software writes are ignored (useful for read-only fields within writable registers).\n  - read_zero: reads always return 0; writes unaffected (related to read_constant).\n  - read_only: software cannot change the stored value (hardware can); software writes cause spec_violation logs (first write level 1, subsequent level 2); fields only log if value changes; suggests ignore_write when mixing writable fields to avoid noise.\n  - write_only: software can write but reads return 0; first read logs a spec_violation at level 1, subsequent reads at level 2 (intended for whole registers; use read_zero for write-only fields).\n  - write_1_clears: writes clear bits by writing 1s (new value = old & ~written).\n  - clear_on_read: reads return the value and then clear it to 0 as a side effect.\n  - write_1_only: software can only set bits (new value = old | written); related to write_0_only.\n  - write_0_only: software can only clear bits (new value = old & written); related to write_1_only.\n  - read_constant: reads return a specified constant (read_val) regardless of stored value; writes and stored attribute behavior differ (use constant template for non-stored constants)."
                    },
                    {
                      "title": "5.2.10 read_constant",
                      "start_index": 98,
                      "end_index": 98,
                      "node_id": "0167",
                      "summary": "- Describes access templates for registers/fields and their behaviors.\n- write_only: software can write but reads return 0; intended for registers (use read_zero for write-only fields); first read logs a spec_violation at level 1, subsequent reads at level 2.\n- write_1_clears: software clears bits by writing 1s; new value = old_value & ~written_value; commonly used when hardware sets bits and software acknowledges by clearing.\n- clear_on_read: reads return the current value and then reset the object to 0 as a side effect.\n- write_1_only: software can only set bits to 1; new value = old_value | written_value; related template: write_0_only.\n- write_0_only: software can only set bits to 0; new value = old_value & written_value; related template: write_1_only.\n- read_constant: reads always return a specified constant (writes do not affect the returned value); the register\u2019s stored attribute may still change even though reads return the constant; parameter: read_val (the constant value)."
                    },
                    {
                      "title": "5.2.11 constant",
                      "start_index": 98,
                      "end_index": 98,
                      "node_id": "0168",
                      "summary": "Summary of main points:\n- Describes access-behavior templates for registers/fields and their semantics.\n- write_only: register can be written but reads return 0; first read logs a spec_violation at log-level 1, subsequent reads at level 2.\n- write_1_clears: software clears bits by writing 1; new value = old_value & ~(written_value).\n- clear_on_read: reads return the current value and then reset the object to 0 as a side effect.\n- write_1_only: software can only set bits to 1; new value = old_value | written_value. (Related template: write_0_only.)\n- write_0_only: software can only set bits to 0; new value = old_value & written_value. (Related template: write_1_only.)\n- read_constant: reads always return a specified constant (parameter read_val); writes do not affect the read value, and the attribute reflects the stored value; use the constant template for registers/fields that do not store a value."
                    },
                    {
                      "title": "5.2.12 silent_constant",
                      "start_index": 98,
                      "end_index": 99,
                      "node_id": "0169",
                      "summary": "- Covers register/field access templates and their semantics for reads, writes, side effects and logging.\n- write_only: software can write but reads return 0; first read logs a spec_violation at level 1, subsequent reads at level 2. Intended for registers (use read_zero for write-only fields).\n- write_1_clears: software clears bits by writing 1s; new value = old & ~write_value (used for hardware-set, software-clear ack bits).\n- clear_on_read: reads return the object value and then reset it to 0 as a side effect.\n- write_1_only: software can only set bits to 1; new value = old | write_value. Related template: write_0_only.\n- write_0_only: software can only set bits to 0; new value = old & write_value. Related template: write_1_only.\n- read_constant: reads always return a specified constant (read_val); writes do not affect the read value though backing storage may change; related to constant, silent_constant, read_zero.\n- constant: writes are forbidden/no effect on reads; object has backing storage which can be changed via attributes (survives reset); first write that changes value logs spec_violation level 1, then level 2. Parameter: init_val. Related: read_constant, silent_constant, read_only.\n- silent_constant: object value remains constant and writes are ignored; end-user tweaks persist across reset; parameter: init_val. Related: constant, read_constant.\n- zeros: object is constant zero; writes are forbidden and generate spec_violation log on first offending write (level 1) then level 2.\n- ones: object is constant all ones; writes do not update the value and follow the same spec_violation logging behavior as zeros.\n- Emphasizes logging behavior for illegal accesses, the presence or absence of backing storage, and guidance on which template to choose based on desired runtime/read behavior."
                    },
                    {
                      "title": "5.2.13 zeros",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0170",
                      "summary": "Partial document describes a set of register/value templates and their behaviors:\n- Templates covered: constant, silent_constant, zeros, ones (with references to related templates like read_constant, read_only, ignore_write).\n- constant: writes are forbidden and have no effect on the model; the object still has backing storage (so reads reflect stored value and an end-user can tweak the register attribute\u2014those tweaks survive reset). Using constant signals the model should not update the register value or override the read method. Parameter: init_val. Logging: first conflicting write produces a spec_violation at log-level 1, subsequent writes at log-level 2.\n- silent_constant: object value remains constant and writes are ignored (do not update the stored value); end-user tweaks survive reset. By convention the model should not modify the value; use ignore_write if different behavior is desired. Parameter: init_val.\n- zeros: object is constant zero; software writes are forbidden and do not update the value. Logging behavior mirrors constant (first offending write log-level 1, remaining writes log-level 2).\n- ones: object is constant all-ones; software writes do not update the value. Logging behavior mirrors constant (first offending write log-level 1, remaining writes log-level 2)."
                    },
                    {
                      "title": "5.2.14 ones",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0171",
                      "summary": "This partial document describes register/value templates that enforce constant behaviors and their logging and parameters:\n- Lists related templates (constant, silent_constant, read_zero) for a preceding template.\n- constant (5.2.11): writes are forbidden and have no effect on the object value, but the object retains backing storage so end-users can modify the value via the register attribute (changes survive reset). Using this template signals the model should not update the register or override the read method; use read_only if that alternative is desired. Parameter: init_val. Related templates: read_constant, silent_constant, read_only. Logging: first write (or field write differing from stored value) produces a spec_violation at log-level 1; subsequent writes log at level 2.\n- silent_constant (5.2.12): the object value remains constant and writes are ignored (do not update value); end-user tweaks via attributes survive reset. By convention the model should not modify the value; if model should ignore writes but not be treated as a constant, use ignore_write. Parameter: init_val. Related templates: constant, read_constant.\n- zeros (5.2.13): object value is constant zero; software writes are forbidden and do not update the value. Logging: first differing write logs spec_violation at level 1, remaining writes at level 2.\n- ones (5.2.14): object value is constant all 1s; software writes do not update the value. Logging: same spec_violation behavior as zeros (first write level 1, remaining writes level 2)."
                    },
                    {
                      "title": "5.2.15 ignore",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0172",
                      "summary": "This partial document section describes several register/value templates and their behaviors:\n\n- Templates covered: constant, silent_constant, zeros (listed as \u201czer os\u201d), ones (and references to related templates like read_constant, read_zero, read_only, ignore_write).\n- constant:\n  - Description: Writes are forbidden and have no effect on the logical behavior, but the object has backing storage (so the end\u2011user can change the stored value by writing the register attribute; such tweaks survive reset).\n  - Modeling guidance: Using this template signals the object is intended to remain constant; the model should not update the register value or override the read method. Use read_only if a read-only semantic is desired.\n  - Log output: First write (or field write when field value differs from write value) produces a spec_violation at log level 1; subsequent writes at log level 2.\n  - Parameters: init_val (the constant value).\n  - Related templates: read_constant, silent_constant, read_only.\n- silent_constant:\n  - Description: The object value remains constant; writes are ignored and do not update the object value. End\u2011user tweaks to the stored value are allowed and survive reset.\n  - Modeling guidance: By convention the model should not modify the object value; if model-updated ignore-write behavior is wanted, use ignore_write.\n  - Parameters: init_val (the constant value).\n  - Related templates: constant, read_constant.\n- zeros (constant zero) and ones (constant all\u20111s):\n  - zeros: Object value is permanently 0; software writes are forbidden and do not update the value.\n  - ones: Object value is permanently all 1s; software writes do not update the value.\n  - Log output for both: First software write (if it would change the value) logs a spec_violation at log level 1; remaining writes log at level 2."
                    },
                    {
                      "title": "5.2.16 reserved",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0173",
                      "summary": "This partial document describes several register/value templates that enforce constant behavior and their logging/parameter conventions. Key points:\n\n- constant: Writes are forbidden and have no effect on the modelled value, but the object retains backing storage so an end-user can modify the value via the register attribute and those tweaks survive reset. Using this template signals the model should not update the register value or override the read method; use read_only if a true read-only behavior is desired. Parameter: init_val. Log behavior: first write (or field write that changes value) produces a spec_violation at log-level 1; subsequent writes at log-level 2. Related templates: read_constant, silent_constant, read_only.\n\n- silent_constant: The object value remains constant and software writes are ignored (do not update the stored value). End-user tweaks to the object value persist across reset. By convention the model should not modify the value (if model-updates are desired, use ignore_write). Parameter: init_val. Related templates: constant, read_constant.\n\n- zeros: A constant zero value. Software writes are forbidden and do not update the value. Log behavior: first write triggers spec_violation at log-level 1; remaining writes at log-level 2.\n\n- ones: A constant all-ones value. Software writes do not update the value. Log behavior mirrors zeros (first spec_violation at log-level 1, subsequent at level 2).\n\nThe document also lists related template names for cross-reference (e.g., read_constant, silent_constant, read_only, ignore_write)."
                    },
                    {
                      "title": "5.2.17 unimpl",
                      "start_index": 99,
                      "end_index": 100,
                      "node_id": "0174",
                      "summary": "This partial document section defines semantics, parameters and logging behavior for several register/field templates used to describe access behavior in a model. Main points:\n- constant: Writes are forbidden/no effect but the object has backing storage (can be tweaked via attribute), marked with init_val parameter; first write that changes value generates a spec_violation log at level 1, subsequent writes at level 2; related templates include read_constant, silent_constant, read_only.\n- silent_constant: Value remains constant; writes are ignored (do not update); init_val parameter; model conventionally should not modify value; related to constant and read_constant.\n- zeros / ones: Predefined constant values (all 0s or all 1s). Software writes do not update the value; first conflicting write logs a spec_violation at level 1, subsequent writes at level 2.\n- ignore: Object is unimportant to functionality \u2014 reads return 0 and writes are ignored.\n- reserved: Object marked reserved for software use; reads return, and writes update, the object value; first software write that changes value logs a spec_violation at level 2, no further logs.\n- unimpl: Functionality unimplemented; reads/writes use default implementations but should warn on usage; first register read/write logs an unimplemented message at level 1, subsequent accesses at level 3; reads from fields typically do not log; related templates include read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n- read_unimpl / write_unimpl: Variants where only read or only write functionality is unimplemented (with similar logging: first offending access level 1, subsequent level 3); each has the other access using default behavior and can be overridden.\n\nThe document also notes related-template relationships and the common init_val parameter where applicable."
                    },
                    {
                      "title": "5.2.18 read_unimpl",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0175",
                      "summary": "Summary of main points:\n\n- Defines several register/field behavior templates: ignore, reserved, unimpl, read_unimpl, write_unimpl.\n- ignore: object functionality unimportant \u2014 reads always return 0, writes are ignored.\n- reserved: object must not be used by software; writes update the stored value and reads return that value; first conflicting software write emits a spec-viol log at level 2, subsequent writes produce no logs.\n- unimpl: object functionality is unimplemented and should warn on use; reads and writes use default implementations. Logging: first register read or write emits an unimplemented log at level 1, subsequent accesses at level 3; field reads do not log; first field write (only if value changes) logs at level 1, subsequent field writes at level 3.\n- read_unimpl: only read functionality is unimplemented (writes use default and can be overridden); first register read logs unimplemented at level 1, subsequent reads at level 3; field reads do not log.\n- write_unimpl: only write functionality is unimplemented (reads use default and can be overridden); first register write logs unimplemented at level 1, subsequent writes at level 3; first field write (if value changes) logs at level 1, subsequent field writes at level 3.\n- Related templates referenced for unimplemented cases include silent_unimpl and design_limitation."
                    },
                    {
                      "title": "5.2.19 write_unimpl",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0176",
                      "summary": "This partial document defines several register/object behavior templates and their logging semantics: \n- \"ignore\": the object is functionally unimportant\u2014reads return 0 and writes are ignored. \n- \"reserved\": the object is reserved but usable; writes update the stored value and reads return it. The first software write to a register or to a field (only if the field value would change) emits a spec-viol log at level 2; subsequent writes are silent. \n- \"unimpl\": the object\u2019s functionality is unimplemented; default read/write behavior applies but software use triggers warnings. The first register read or write emits an unimplemented log at level 1, subsequent accesses at level 3; reads from fields do not log, while first field writes that change value log at level 1 and later at level 3. \n- \"read_unimpl\": only read functionality is unimplemented (writes use default and may be overridden); first register reads log at level 1, later reads at level 3; field reads do not log. \n- \"write_unimpl\": only write functionality is unimplemented (reads use default and may be overridden); first register writes log at level 1, later writes at level 3; first field writes that change value follow the same logging. \nRelated templates such as read_unimpl/write_unimpl/silent_unimpl/design_limitation and examples like read_only/write_only are referenced as overrides or related behaviors."
                    },
                    {
                      "title": "5.2.20 silent_unimpl",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0177",
                      "summary": "This partial document defines several register/object behavior templates and their logging policies. It covers \"ignore\" (object functionality unimportant: reads return 0, writes ignored); \"reserved\" (object reserved but writable: writes update value, reads return value, first write that changes a value generates a spec-violation log at level 2); and \"unimpl\" (functionality unimplemented: default read/write semantics but software use is warned, with first register read/write logged at level 1 and subsequent accesses at level 3; field read/write logging is more limited). It also details specialized variants\u2014read_unimpl (read unimplemented, writes default), write_unimpl (write unimplemented, reads default)\u2014including their specific logging behaviors, and lists related templates such as silent_unimpl and design_limitation."
                    },
                    {
                      "title": "5.2.21 undocumented",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0178",
                      "summary": "This partial document defines behavioral templates for objects/registers with descriptions, log-output rules, and related templates. The \"ignore\" template marks functionality as unimportant: reads return 0 and writes are ignored. The \"reserved\" template marks the object as reserved but writable: writes update the object value and reads return that value; the first software write to a register or to a field (only if the field value differs from the write) emits a spec-viol log at level 2, with no logs on subsequent writes. The \"unimpl\" template marks functionality as unimplemented and issues warnings when used: reads and writes use default implementations but generate unimplemented log messages\u2014first register read or write logs at level 1 and subsequent accesses at level 3; reads from fields do not log, while first field writes (if value changes) follow the same level-1/level-3 pattern. The \"read_unimpl\" template makes read access unimplemented (writes use default) and logs the first register read at level 1 and subsequent reads at level 3; field reads do not log. The \"write_unimpl\" template makes write access unimplemented (reads use default) and logs the first register write at level 1 and subsequent writes at level 3; first field writes that change value follow the same logging pattern. Each template lists related templates (e.g., unimpl, read_unimpl, write_unimpl, silent_unimpl, design_limitation)."
                    },
                    {
                      "title": "5.2.22 unmapped",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0179",
                      "summary": "Covers a set of register/object access templates and their behaviors:\n\n- Templates described: ignore, reserved, unimpl, read_unimpl, write_unimpl.\n- ignore: object functionality unimportant; reads return 0; writes are ignored.\n- reserved: object marked reserved and should not be used; writes update the stored value; reads return the value; first software write to a register or field (if field value differs from write value) produces a spec-viol log at level 2, with no further logs on subsequent writes.\n- unimpl: functionality unimplemented; default reads/writes used; software use should generate warnings. Logging: first register read => unimplemented log at level 1, subsequent reads at level 3; field reads produce no log. First register write => unimplemented log at level 1, subsequent writes at level 3; first field write (if value changes) => level 1 then level 3 for remaining writes. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n- read_unimpl: read functionality unimplemented; writes use default implementation (can be overridden). Logging: first register read => unimplemented log level 1, subsequent register reads level 3; field reads produce no log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n- write_unimpl: write functionality unimplemented; reads use default implementation (can be overridden). Logging: first register write => unimplemented log level 1, subsequent writes level 3; first field write (if value changes) => level 1 then level 3 for remaining writes. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.23 sticky",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0180",
                      "summary": "- Sections describe register/object behavior templates: ignore, reserved, unimpl, read_unimpl, and write_unimpl.\n- ignore: object functionality unimportant \u2014 reads return 0 and writes are ignored.\n- reserved: object marked reserved and should not be used \u2014 writes update the stored value and reads return it; first software write that changes a value generates a spec-viol log at level 2, with no logs on subsequent writes.\n- unimpl: functionality unimplemented; software usage should be warned; reads and writes follow default implementations; logging: first register read/write emits an unimplemented log at level 1, subsequent reads/writes at level 3; field reads do not log; first field write that changes value logs at level 1, subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n- read_unimpl: read functionality unimplemented while writes use default (can be overridden); logging: first register read logs unimplemented at level 1, remaining reads at level 3; field reads do not log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n- write_unimpl: write functionality unimplemented while reads use default (can be overridden); logging: first register write logs unimplemented at level 1, remaining writes at level 3; first field write that changes value logs at level 1, remaining field writes at level 3. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.24 design_limitation",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0181",
                      "summary": "This partial document defines templates for register/field behaviors and their logging semantics:\n\n- Covered templates: ignore, reserved, unimpl, read_unimpl, write_unimpl (with related-template references such as silent_unimpl and design_limitation).\n\n- ignore: object functionality unimportant \u2014 reads return 0 and writes are ignored.\n\n- reserved: object marked reserved and should not be used by software; writes update the object value and reads return it. Logging: the first software write to a register or to a field (only if the field value differs from the write value) produces a spec-violation log at level 2; no logs on subsequent writes.\n\n- unimpl: object functionality unimplemented; warn when software uses it. Reads and writes use default implementations. Logging: first register read or register write emits an \u201cunimplemented\u201d log at level 1, subsequent accesses at level 3; reads from fields do not log; first field write (if value differs) logs at level 1, subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- read_unimpl: read functionality unimplemented; write uses default implementation (overridable). Logging: first software read to a register logs \u201cunimplemented\u201d at level 1, subsequent reads at level 3; field reads do not log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- write_unimpl: write functionality unimplemented; read uses default implementation (overridable). Logging: first software write to registers logs \u201cunimplemented\u201d at level 1, subsequent writes at level 3; first write to a field (if value differs) logs at level 1, subsequent field writes at level 3. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.25 no_reset",
                      "start_index": 100,
                      "end_index": 101,
                      "node_id": "0182",
                      "summary": "Summary of a set of register/object behavior templates and their effects: the excerpt documents templates that define how registers and fields behave on reads/writes, how they interact with resets, and what log messages are generated. Covered templates include: \"ignore\" (reads return 0, writes ignored); \"reserved\" (marked unused but readable/writable, with a spec-viol log on the first software write); \"unimpl\" and variants (\"read_unimpl\", \"write_unimpl\", \"silent_unimpl\") which mark functionality as unimplemented and specify default read/write behavior, differing in when and at what log level unimplemented warnings are emitted (first access usually logged at level 1, later at level 3; silent_unimpl uses higher initial log-levels and suppresses field-read logs); \"write_unimpl\"/\"read_unimpl\" narrow unimplemented behavior to one access type; \"undocumented\" (poorly documented, first accesses logged as spec violations); \"unmapped\" (register excluded from bank address space); \"sticky\" and \"no_reset\" (preserve values across soft/hard resets); \"design_limitation\" (intentionally out-of-scope/unimplemented, with related templates noted). Each template entry specifies description, log-output behavior, and related templates. The excerpt ends as it begins the bank-related templates section with \"function_mapped_bank.\""
                    }
                  ],
                  "node_id": "0157",
                  "summary": "- Reset callbacks: objects can implement a callback for reset events; registers and fields get this automatically (templates: poreset, hreset, sreset corresponding to power_on_reset, hard_reset, soft_reset).\n- Top-level reset templates: power_on_reset, hard_reset, soft_reset provide standard reset behavior for power-on, hard, and soft resets.\n- Templates for registers and fields: many templates affect read or write behavior; when applied to a register they can override or ignore field-level implementations (example: read_unimpl on a register returns the register value via get and ignores field read overrides, while writes still propagate to fields).\n- soft_reset_val: when applied to a register or field, defines the reset value used on soft reset (parameter soft_reset_val) instead of the default init_val (related template: soft_reset).\n- ignore_write: causes writes to be ignored; useful for read-only fields inside writable registers (alternative to read_only in mixed registers).\n- read_zero: makes reads always return 0 while leaving writes unaffected (related: read_constant).\n- read_only: marks an object as read-only to software but writable by hardware; logging rules: first software write logs a spec_violation at level 1, subsequent writes at level 2; fields only log if the written value differs from the old value."
                },
                {
                  "title": "5.3 Bank related templates",
                  "start_index": 101,
                  "end_index": 101,
                  "nodes": [
                    {
                      "title": "5.3.1 function_mapped_bank",
                      "start_index": 101,
                      "end_index": 101,
                      "node_id": "0184",
                      "summary": "- silent_unimpl: Marks functionality as unimplemented while avoiding excessive logging. Reads/writes use default behaviors. Logging: first software read/write to a register emits an unimplemented message at level 2, subsequent accesses at level 3; software reads to fields produce no log; first field write that changes value logs at level 2, subsequent field writes at level 3. Related templates: unimpl, design_limitation.\n\n- undocumented: Functionality is undocumented or poorly documented; reads/writes use defaults. Logging: first software read and write emit spec_violation at level 1, with subsequent accesses at level 2.\n\n- unmapped: The register is excluded from the containing bank\u2019s address space.\n\n- sticky (stick y): Object value is not reset on soft reset; current value is retained.\n\n- design_limitation: Functionality intentionally left out of the model as a design decision (not an implementation gap). Reads/writes use defaults. Example use: debug registers. Related templates: unimpl, silent_unimpl.\n\n- no_reset: Register or field value is not changed on hard or soft reset.\n\n- Bank-related templates: section begins with function_mapped_bank (description not included in the partial text)."
                    },
                    {
                      "title": "5.3.2 function_io_memory",
                      "start_index": 101,
                      "end_index": 102,
                      "node_id": "0185",
                      "summary": "The partial document describes a set of object, register, bank, and connect templates and their behaviors:\n\n- silent_unimpl: marks functionality as unimplemented but suppresses verbose logging; reads/writes use default implementations; specifies logging levels for first and subsequent software reads/writes and field writes; related to unimpl and design_limitation.\n- undocumented: marks functionality as undocumented/poorly documented; uses default reads/writes; first software read/write emits a spec_violation at log-level 1, subsequent accesses at log-level 2.\n- unmapped: indicates a register is excluded from the containing bank's address space.\n- sticky: (sticky) do not reset object value on soft reset; keep current value.\n- design_limitation: functionality intentionally left out of the model as a design decision; default reads/writes for SW/HW; distinguished from unimplemented; related to unimpl and silent_unimpl.\n- no_reset: register/field value is not changed on hard or soft reset.\n\nBank-related templates:\n- function_mapped_bank: valid only in bank objects; marks a bank as usable by function_io_memory; parameter: function (integer).\n- function_io_memory: valid in implement objects named io_memory; implements io_memory interface by mapping transactions to a bank in the same (sub)device with a matching function number; logs an error and reports a miss if none found; notes that function-number mapping is deprecated and that PCI function numbers are unrelated; parameter: function.\n- miss_pattern_bank: valid in bank objects; handles unmapped accesses by ignoring writes and returning a specified byte value for each unmapped byte; parameter: miss_pattern; suggests overriding unmapped_get to customize behavior.\n\nConnect-related templates:\n- map_target: for connect objects to provide an easy way to send memory transactions to map-capable objects; sets a session variable map_target (map_target_t *) and provides validate to ensure SIM_new_map_target succeeds; defines methods such as read(uint64 addr, uint64 size) -> (uint64) throws."
                    },
                    {
                      "title": "5.3.3 miss_pattern_bank",
                      "start_index": 102,
                      "end_index": 102,
                      "node_id": "0186",
                      "summary": "- Describes templates and parameters for memory bank and connect-related objects in Simics.\n- function_mapped_bank: valid only in bank objects; parameter: function (integer); related template: function_io_memory.\n- function_io_memory: valid only in implement objects named io_memory; implements io_memory by function mapping \u2014 incoming memory transactions are dispatched to a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number; missing bank logs an error and reports a miss. Notes that function-number mapping is deprecated and PCI function numbers are unrelated to bank function numbers. Parameter: function (integer); related template: function_mapped_bank.\n- miss_pattern_bank: valid only in bank objects; handles unmapped accesses by ignoring writes and returning a specified value for each unmapped byte; to customize behavior override unmapped_get (which also customizes unmapped_read). Parameter: miss_pattern (value used for each missed byte).\n- map_target (connect-related): connect objects can instantiate map_target to send memory transactions to mappable objects; provides a default set implementation that assigns a session variable map_target (map_target_t *) for issuing transactions and a validate implementation that checks SIM_new_map_target succeeds. Defines methods including read(uint64 addr, uint64 size) -> (uint64) (and related transaction methods)."
                    }
                  ],
                  "node_id": "0183",
                  "summary": "Summary of main points in the partial document:\n\n- silent_unimpl: Marks an object as unimplemented but minimizes log noise; reads and writes use default behavior. First software read/write to a register emits an \"unimplemented\" log at level 2, subsequent reads/writes at level 3; software reads to fields produce no log; first field write that changes value logs at level 2, subsequent at level 3. Related templates: unimpl, design_limitation.\n\n- undocumented: Object is undocumented or poorly documented; default reads/writes. First software read or write produces a spec_violation log at level 1, subsequent accesses at level 2.\n\n- unmapped: Register is excluded from the address space of its containing bank.\n\n- sticky: Object value is not reset on soft-reset and retains its current value.\n\n- design_limitation: Functionality intentionally left unimplemented as a design decision (out of model scope); default reads/writes apply. Distinct from unimplemented (which may be implemented later). Example use: debug registers. Related templates: unimpl, silent_unimpl.\n\n- no_reset: Register or field value is not changed on hard or soft reset.\n\n- The document proceeds to bank-related templates and begins the entry for function_mapped_bank (description not included in the partial text)."
                },
                {
                  "title": "5.4 Connect related templates",
                  "start_index": 102,
                  "end_index": 102,
                  "nodes": [
                    {
                      "title": "5.4.1 map_target",
                      "start_index": 102,
                      "end_index": 103,
                      "node_id": "0188",
                      "summary": "This partial document describes several Simics template types and their key behaviors and parameters. It documents the function_mapped_bank template (valid only in bank objects) and its integer function parameter, and the function_io_memory implement (for io_memory) which routes incoming memory transactions to bank objects that instantiate function_mapped_bank with a matching function number, noting that function-number mapping is deprecated and unrelated to PCI function numbers. The miss_pattern_bank template (bank-only) is explained: it handles unmapped accesses by ignoring writes and returning a specified byte value for missed reads (miss_pattern parameter). Under connect-related templates, map_target is defined for connect objects to facilitate issuing memory transactions to mappable objects, including validation and convenience methods (read, read_bytes, write, write_bytes) and an overridable issue helper that calls the SIM API. Finally, signal-related templates are covered: signal_port implements a saved boolean signal state (high), logs spec violations on redundant raises/lowers, and allows overrides of signal_raise/signal_lower; signal_connect manages a saved signal.high when switching connections or during finalization and provides set_level to change the signal, with hooks to override set and post_init."
                    }
                  ],
                  "node_id": "0187",
                  "summary": "- Describes templates for memory bank and connect objects used in Simics device models.\n- function_mapped_bank: a bank template (valid only in bank objects) that marks a bank as mapped by a function number; parameter: function (integer); related to function_io_memory.\n- function_io_memory: an implement template (valid in implement objects named io_memory) that routes incoming memory transactions by matching the transaction\u2019s function number to a function_mapped_bank in the same (sub)device; if no match, logs an error and reports a miss. Notes that function-number mapping is deprecated (historically used by PCI) and PCI function numbers are unrelated to bank function numbers. Parameter: function (integer); related to function_mapped_bank.\n- miss_pattern_bank: a bank template handling unmapped accesses by ignoring writes and returning a specified byte value for each missed byte; to customize behavior override unmapped_get. Parameter: miss_pattern (value for each missed byte).\n- map_target (connect-related template): for connect objects that target mappable memory objects; provides default set (assigns session variable map_target of type map_target_t *) and validate (checks SIM_new_map_target can create a valid map target); defines transaction methods such as read(addr, size) -> (value) (snippet truncated)."
                },
                {
                  "title": "5.5 Signal related templates",
                  "start_index": 103,
                  "end_index": 103,
                  "nodes": [
                    {
                      "title": "5.5.1 signal_port",
                      "start_index": 103,
                      "end_index": 103,
                      "node_id": "0190",
                      "summary": "- Memory access API: methods for reading and writing to a connected object:\n  - read(uint64 addr, uint64 size) -> uint64 and read_bytes(uint64 addr, uint64 size, uint8 *bytes): read size bytes starting at addr; size must be \u2264 8 for read(); little-endian byte order; exceptions thrown on failure.\n  - write(uint64 addr, uint64 size, uint64 value) and write_bytes(uint64 addr, uint64 size, const uint8 *bytes): write size bytes starting at addr; size must be \u2264 8 for write(); little-endian for value; exceptions thrown on failure.\n- Transaction issuing: issue(transaction_t *t, uint64 addr) -> (exception_type_t) is a shorthand for SIM_issue_transaction; read/write methods use it and it can be overridden to modify transactions (e.g., add atoms) while preserving higher-level convenience methods.\n- Signal-related templates:\n  - signal_port: implements a signal interface with saved state (boolean high); logs a spec-violation at level 2 if raise/lower is called when already in that state; signal_raise and signal_lower can be overridden to add side effects.\n  - signal_connect: implements a connect with a signal interface using saved state in signal.high; when the connection changes while signal.high is true and the device is configured, it calls signal_lower on the old object and signal_raise on the new object; if the device is created with signal.high true, signal_raise is invoked on the connected object during finalize; behavior can be altered by overriding set and/or post_init.\n  - Provides set_level(uint1 high): sets the signal level by calling signal_raise or signal_lower as needed and updates signal.high.\n- Notes: signal_connect references signal_port as a related template."
                    },
                    {
                      "title": "5.5.2 signal_connect",
                      "start_index": 103,
                      "end_index": 103,
                      "node_id": "0191",
                      "summary": "This partial document describes APIs for reading and writing bytes in a connected object and a set of signal-related templates. It documents read/read_bytes and write/write_bytes methods (size up to 8 bytes, little-endian byte order, exceptions on failure) and an issue(transaction_t*, addr) helper that wraps SIM_issue_transaction and can be overridden to customize transactions. It then introduces signal-related templates: signal_port, which stores the current signal state in a saved boolean high and logs spec-violation messages if raise/lower are called while already in that state; and signal_connect, which stores signal.high and ensures that when a connection changes while high and the device is configured it calls signal_lower on the old object and signal_raise on the new one, and that a device created with signal.high true will call signal_raise on the connected object during finalize. The signal_connect behavior can be altered by overriding set or post_init, and it defines set_level(uint1 high) to change level by invoking signal_raise/signal_lower and updating signal.high. It also notes signal_port as a related template."
                    }
                  ],
                  "node_id": "0189",
                  "summary": "- Memory access API:\n  - read(uint64 addr, uint64 size) -> (uint64 value) throws: reads up to 8 bytes (size \u2264 8) from addr, little-endian, throws on failure.\n  - read_bytes(uint64 addr, uint64 size, uint8 *bytes) throws: reads size bytes into bytes, throws on failure.\n  - write(uint64 addr, uint64 size, uint64 value) throws: writes up to 8 bytes (size \u2264 8) to addr, little-endian, throws on failure.\n  - write_bytes(uint64 addr, uint64 size, const uint8 *bytes) throws: writes size bytes from bytes, throws on failure.\n  - issue(transaction_t *t, uint64 addr) -> (exception_type_t): shorthand for SIM_issue_transaction used by the read/write methods; can be overridden to modify transactions (e.g., add atoms) while preserving the simpler method interfaces.\n\n- Signal-related templates (section 5.5):\n  - signal_port:\n    - Implements a signal interface with saved state (boolean saved high).\n    - Logs a spec-violation at level 2 if a signal is raised while already high or lowered while already low.\n    - signal_raise and signal_lower methods can be overridden to add side effects.\n  - signal_connect:\n    - Implements a connect with a signal interface, storing current state in saved boolean signal.high.\n    - On changing the connection while signal.high is true and the device is configured, calls signal_lower on the old object and signal_raise on the new one.\n    - If the device is created with signal.high true, calls signal_raise on the connected object during finalize.\n    - Behavior can be changed by overriding set and/or post_init.\n    - Provides set_level(uint1 high): sets the signal level by calling signal_raise or signal_lower as needed and updates signal.high.\n    - Related template: signal_port."
                }
              ],
              "node_id": "0153",
              "summary": "This partial document is from Chapter 5 (\u201cStandard Templates\u201d) of the Device Modeling Language (DML) reference and explains the standard templates provided in utility.dml for modeling registers and fields. It notes that many templates share functionality but differ in name or logging to convey intent (for example, undocumented vs reserved). It defines the term \u201cobject\u201d to mean registers and fields, and distinguishes software reads/writes (io_memory interface using DML read/write) from hardware reads/writes (Simics configuration attributes using DML set/get), and that device code can still modify state even when hardware modification is prohibited. Section 5.1 covers reset templates: DML has no built-in reset handling but provides templates for common reset types\u2014power-on (poreset), hard (hreset) and soft (sreset)\u2014which restore registers to predefined values and create POWER/HRESET/SRESET ports that trigger reset behavior (invoking methods such as power_on_reset and hard_reset) on a rising edge."
            },
            {
              "title": "A Messages",
              "start_index": 104,
              "end_index": 104,
              "nodes": [
                {
                  "title": "A.1 Warning Messages",
                  "start_index": 104,
                  "end_index": 107,
                  "node_id": "0193",
                  "summary": "An appendix listing DML (Device Modeling Language) compiler/runtime diagnostic messages (warnings and errors), presented alphabetically with message tags and explanatory text. The excerpt covers many specific warnings\u2014security risks from using stack-allocated pointers with immediate after or hook send operations; signed/unsigned comparison pitfalls; outdated AST/precompiled file timestamps; constant truncation on assignment; experimental or deprecated language features; duplicate checkpoint names; missing version tags, documentation or short descriptions; ignored implementations lacking an \"is\" instantiation; log-level/group mixups; negative register offsets; version-compatibility issues (DML 1.2 vs 1.4) including throwing semantics and unused-method handling; potential confidential-information leaks; template instantiation/style recommendations; always-zero shift results; sizeof vs sizeoftype misuse; implicit time-type conversions; unused-parameter/object warnings; and dangerous pointer-to-pointer casts. It also begins the error-messages section, illustrating error statements that force compilation failure. Each entry includes clarifications, examples, and suggested mitigations or notes about default warning enablement."
                },
                {
                  "title": "A.2 Error Messages",
                  "start_index": 107,
                  "end_index": 123,
                  "node_id": "0194",
                  "summary": "A reference section from a DML/Simics manual listing compiler warnings and an alphabetical catalog of error messages (with tags like [WTTYPEC], [ENBOOL], etc.), their meanings, typical causes, and suggested fixes. The warnings cover issues such as implicit time-type conversions, unused implementations/parameters, and unsafe pointer casts. The error list documents a wide range of static-check and semantic errors\u2014template and inheritance problems, method/interface rules, array and register bounds, attribute and layout restrictions, import/version/pragma problems, serialization/checkpoint constraints, formatting and log issues, and numerous type- and syntax-related errors\u2014often explaining context-sensitive rules and remediation strategies."
                }
              ],
              "node_id": "0192",
              "summary": "- Section A documents warning and error messages from the dmlc tool, with clarifications and tags for each message (messages listed alphabetically).\n- A.1 focuses on warning messages and shows example warnings and their meanings, e.g., SystemC-specific warnings [WSYSTEMC] and a generic \"warning;\" statement [WWRNSTMT].\n- Explains redundant log-level syntax [WREDUNDANTLEVEL] and its ineffectiveness when levels are identical.\n- Highlights severe safety warnings about callbacks and message sending: unsafe immediate \"after\" callbacks that reference stack-allocated data [WIMMAFTER], and unsafe hook send operations that transmit pointers to stack data [WHOOKSEND].\n- Provides mitigation advice for unsafe sends (use send_now or wrap send in a method combined with immediate after) to avoid dangling-pointer/security risks.\n- Notes a semantic warning about comparing negative constants to unsigned integers [WNEGCONSTCOMP], explaining DML\u2019s special comparison behavior and the likely unintended result."
            },
            {
              "title": "B Provisional language features",
              "start_index": 124,
              "end_index": 124,
              "nodes": [
                {
                  "title": "B.1 List of stable provisional features",
                  "start_index": 124,
                  "end_index": 124,
                  "nodes": [
                    {
                      "title": "explicit_param_decls",
                      "start_index": 124,
                      "end_index": 125,
                      "node_id": "0197",
                      "summary": "This partial document section describes the DML provisional-language-features mechanism and documents two stable provisional features.\n\n- Provisional features overview\n  - Provisional features are language extensions enabled on a per-file basis by adding a line like:\n    provisional feature_name, other_feature_name;\n    immediately after the dml 1.4; statement.\n  - Two flavours:\n    - Stable provisional features: designs are reasonably mature and expected to remain mostly stable; incompatible changes would be introduced as a new provisional version and both versions kept for a time. These may be reasonable to use in production.\n    - Unstable provisional features: subject to significant incompatible changes; intended for experimental evaluation by a small group and not recommended for production without coordination with the DML team.\n\n- B.1 List of stable provisional features (documented in this excerpt)\n  - explicit_param_decls\n    - Extends parameter-definition syntax to distinguish declaring a new parameter vs overriding an existing one, so accidental misspelled overrides become compile errors.\n    - Introduces explicit declaration forms (examples):\n      - Typed shorthand: param NAME: TYPE = value; is equivalent to declaring param NAME: TYPE; and assigning param NAME = value; (similar for param NAME: TYPE default value;)\n      - Untyped shorthand: param NAME := value; or param NAME :default value; map to declaration + assignment forms.\n    - Using a declaration form when you intended to override an existing parameter causes a compile error; similarly, a plain assignment form (param NAME = value; or param NAME default value;) that does not actually override a pre-existing parameter is an error.\n    - To allow code that may either declare or override, you can include both a param NAME; declaration and a param NAME = value; (or default) in the same scope; that combination suppresses the error.\n    - Enabling this feature affects only parameter definitions in the file in which it is enabled.\n\n  - simics_util_vect\n    - Enables a vect type based on the Simics C API VECT macro (simics/util/vect.h) as an interim, somewhat inconsistent vector mechanism until a cleaner solution is introduced.\n    - Syntax: BASETYPE vect, e.g. typedef int vect int_vect_t; to define a vector-of-int type.\n    - Caveats:\n      - vect types typically must be typedef:ed before use because the C expansion VECT(int) produces a struct; repeated expansions can produce incompatible types, causing typeof and similar constructs to behave unexpectedly unless typedefs are used.\n    - Importing internal.dml exposes many vect-related C macros to DML (VINIT, VELEMSIZE, VRESIZE, VADD, VREMOVE, VLEN, VCOPY, etc.).\n    - DML supports native indexing syntax for vect types, which translates to VGET/VSET; example code shows using VLEN and v[0] to access the first element."
                    },
                    {
                      "title": "simics_util_vect",
                      "start_index": 125,
                      "end_index": 126,
                      "node_id": "0198",
                      "summary": "- Rules for declaring and overriding DML parameters:\n  - Describes forms like \"param NAME;\" and assignment/default forms and how they relate (some forms are shorthand for combining declaration and default).\n  - If a declaration form intended as a new declaration is used to override an existing parameter (or vice versa), DML will signal an error.\n  - To allow a declaration that may be either an override or a new parameter, include both a plain \"param NAME;\" and the assignment/default form in the same scope; this suppresses the error.\n  - Enabling the explicit_param_decls feature affects only parameter definitions in the file where it is enabled.\n\n- simics_util_vect feature and vect types:\n  - Introduces a vect type in DML based on the VECT macro from the Simics C API (simics/util/vect.h) as an interim vector mechanism.\n  - Syntax: BASETYPE vect (e.g., \"typedef int vect int_vect_t;\") to define vector types.\n  - Caveats and limitations:\n    - vect types generally must be typedef'ed before use because VECT(BASE) expands to a struct; multiple expansions produce incompatible types.\n    - typeof in DML does not work properly for vect types unless they are typedef'ed.\n  - Importing \"internal.dml\" exposes many C vector macros to DML (list provided, e.g., VINIT, VLEN, VADD, VCOPY, etc.).\n  - DML indexing syntax is translated to VGET/VSET (example provided showing v[0] and VLEN usage).\n  - Enabling simics_util_vect in a file only affects vect declarations in that file.\n  - If simics_util_vect is disabled, using vect is an error unless the experimental_vect compatibility feature is enabled.\n\n- The partial document ends with a heading indicating further discussion (e.g., \"A Messages C Managing deprecated language features\")."
                    }
                  ],
                  "node_id": "0196",
                  "summary": "The partial document explains DML\u2019s provisional language features: why they exist (e.g., incomplete designs or backward-incompatible changes) and how they are enabled on a per-file basis by adding a provisional declaration immediately after the \"dml 1.4;\" statement (e.g., provisional feature_name, other_feature_name;). It distinguishes two flavours of provisional features: stable provisionals (reasonably proven designs that may evolve but, if changed incompatibly, get a new name/version and can be used in production) and unstable provisionals (expected to change significantly and intended for experimental evaluation, not production). The document begins a list of stable provisional features and describes the explicit_param_decls feature in detail: it extends parameter syntax to distinguish declaring a new parameter from overriding an existing one (so misspelled overrides become compile errors) and introduces new shorthand forms for typed and untyped parameter declarations/definitions (examples shown for forms like param NAME: TYPE = value; param NAME: TYPE default value; and param NAME := value;). The excerpt ends mid-sentence while explaining the untyped-parameter shorthand."
                }
              ],
              "node_id": "0195",
              "summary": "The excerpt describes the DML \u201cprovisional features\u201d mechanism: how provisional language extensions are enabled per-file (using a provisional feature list placed after the dml 1.4; declaration) and why provisional features exist (to trial features not yet ready for full inclusion, e.g., designs under evaluation or backwards-incompatible changes). It distinguishes two kinds of provisional features\u2014stable (designs expected to remain largely stable, usable in production with care and versioned if incompatible changes occur) and unstable (subject to significant change, intended for experimentation by modelers and not recommended for production). The document then begins a list of stable provisional features and documents the explicit_param_decls feature: this extends parameter syntax to distinguish declaring a new parameter from overriding an existing one (so misspelled overrides become compile errors) and introduces new shorthand forms for typed and untyped parameter declarations (showing equivalences such as param NAME: TYPE = value; and param NAME := value;)."
            },
            {
              "title": "C Managing deprecated language features",
              "start_index": 127,
              "end_index": 127,
              "nodes": [
                {
                  "title": "C.1 Deprecation mechanisms",
                  "start_index": 127,
                  "end_index": 128,
                  "node_id": "0200",
                  "summary": "Summary of main points in the partial document\n\n- Purpose: describes how DML handles deprecated language features and how users with large code bases can migrate smoothly when the language or Simics API changes.\n\n- Types of deprecations: removed/renamed symbols (easy to fix), semantic changes to language constructs or APIs (can change behavior without errors), and changes in how compiled models appear in Simics (affects model end-users and may require coordinated migration).\n\n- Primary deprecation mechanism: Simics API versions. Each deprecated DML feature is tied to an API version; Simics major-version upgrades drop features from previous API versions. This allows staged migration across Simics N \u2192 N+1.\n\n- Recommended migration workflow:\n  1. While on Simics version N, update modules to API version N (can migrate modules one-by-one).\n  2. Upgrade Simics to N+1 (should not affect DML immediately).\n  3. Migrate modules to API N+1 gradually; Simics N+1 supports API N so updates can be phased.\n\n- Additional controls: DML compiler flags to selectively disable deprecated features to ease gradual migration or to prevent use of legacy features still present in the latest API (reduces bloat, improves consistency and performance).\n\n- Command-line controls: dmlc supports --api-version (also SIMICS_API_VERSION in make or SIMICS_API/MODULE_SIMICS_API in CMake) and --no-compat=tag to disable a specific compatibility feature. Each tag creates a global boolean parameter named _compat_tag for use inside DML code.\n\n- Examples of deprecated features (removed when compiling with Simics API 7+; individually disableable with --no-compat=TAG under older APIs):\n  - dml12_goto: preserves the deprecated goto statement; advises replacing goto/label patterns with throw/catch.\n  - dml12_inline: in DML 1.2 inlining could replace typed constant arguments with constants, affecting semantics and compilation behavior.\n  - dml12_int: affects many integer arithmetic semantics\u2014older mode maps integer ops directly to C (including odd-sized uintNN types), which can cause surprising results. Disabling it enforces modern semantics (e.g., change assert 0 \u2192 assert false; while (1) \u2192 while (true)); non-standard-size integers behavior and valid value ranges (example: int1) also change.\n\n- The excerpt ends mid-explanation of dml12_int implications and migration guidance."
                },
                {
                  "title": "C.2 Controlling deprecation on the DML command-line",
                  "start_index": 128,
                  "end_index": 128,
                  "node_id": "0201",
                  "summary": "This partial document discusses deprecation of legacy DML features and how to control compatibility in the DML compiler (DMLC). Main points covered:\n\n- Rationale for deprecation: avoiding older features that have newer replacements keeps the codebase cleaner, more consistent, reduces model bloat from redundant APIs, and can improve performance.\n- How to control API/compatibility on the command line:\n  - DMLC supports an --api-version flag to select the API version used for a model.\n  - Build-system variables that control this: SIMICS_API_VERSION (make) and SIMICS_API / MODULE_SIMICS_API (CMake).\n  - A --no-compat=tag flag disables an individual legacy feature (tag), and each tag also maps to a global boolean parameter named _compat_tag that programs can query.\n- A list of deprecated compatibility features, specifically those supported only up to --simics-api=6 (removed when compiling with Simics API 7+). These can be disabled individually with --no-compat=TAG when using older APIs.\n- Descriptions of specific deprecated compatibility tags:\n  - dml12_goto: preserves the old goto statement; recommended migration is to replace goto/labels with throw/catch constructs, though conversion can be nontrivial.\n  - dml12_inline: inlines constant arguments for DML 1.2 device methods; can speed compilation but has unintuitive semantics.\n  - dml12_int: changes many integer-arithmetic semantics. When enabled, integer operations are translated straight to C (including representing odd-sized integer types as native C widths), which can yield unexpected behavior. Disabling it enforces modern DML semantics (e.g., 64-bit arithmetic with truncation on casts/stores) and requires code changes such as replacing assert 0 with assert false and while (1) with while (true). It also alters behavior for non-standard-size integers (e.g., uint5) and small signed types (e.g., int1) compared to older semantics."
                },
                {
                  "title": "C.3 List of deprecated features",
                  "start_index": 128,
                  "end_index": 128,
                  "nodes": [
                    {
                      "title": "C.3.1 Features available up to and including --simics-api=6",
                      "start_index": 128,
                      "end_index": 128,
                      "nodes": [
                        {
                          "title": "dml12_goto",
                          "start_index": 128,
                          "end_index": 128,
                          "node_id": "0204",
                          "summary": "Summary of main points in the partial document:\n\n- Motivation: Removing legacy features keeps the code base cleaner, more consistent, and can reduce model bloat and performance costs from redundant functionality.\n\n- Controlling deprecation via DMLC and build system:\n  - DMLC supports an --api-version flag to select the Simics API level for a model.\n  - Build variables controlling this: SIMICS_API_VERSION (make) or SIMICS_API / MODULE_SIMICS_API (CMake).\n  - DMLC also supports --no-compat=tag to disable specific legacy features; each tag also creates a global boolean parameter named _compat_tag that programs can check.\n\n- Deprecated-features list (section for features available up to and including --simics-api=6):\n  - These features are removed when compiling with Simics API 7+; with older APIs they can be disabled individually via --no-compat=TAG.\n\n- Specific deprecated compatibility features described:\n  - dml12_goto: preserves the legacy goto statement. Recommendation: refactor goto-based control flow into throw/catch constructs; disabling goto may require nontrivial code changes.\n  - dml12_inline: controls inlining behavior for DML 1.2 devices where constant arguments in typed parameters are inlined as constants; this can speed compilation but has unintuitive semantics.\n  - dml12_int: affects many integer-arithmetic semantics. When enabled, many integer operations are translated directly into C without compensating for DML specifics (e.g., odd-sized uintNN types), which can produce surprising behavior. Disabling this feature enforces modern DML semantics and triggers errors for legacy idioms (examples: assert 0 \u2192 assert false; while (1) \u2192 while (true)). Other effects: nonstandard-size integers were previously represented as native C types (e.g., uint5 as uint8), allowing out-of-range values; DML 1.4 uses 64-bit arithmetic with truncation on casts/stores. Legacy code may rely on older behaviors such as comparing int1 variables to 1, which is incompatible with modern semantics."
                        },
                        {
                          "title": "dml12_inline",
                          "start_index": 128,
                          "end_index": 128,
                          "node_id": "0205",
                          "summary": "- Explains rationale for removing legacy features (cleaner, more consistent code, reduced model bloat and performance cost).\n- Describes how to control API/compatibility on the DML compiler: --api-version (and SIMICS_API_VERSION / SIMICS_API / MODULE_SIMICS_API build variables) and the --no-compat=tag flag; each tag also creates a global boolean parameter named _compat_tag for runtime checks.\n- Introduces a list of deprecated compatibility features that were available up to --simics-api=6 and removed in API 7+, and how they can be disabled individually with --no-compat=TAG.\n- Details specific deprecated features:\n  - dml12_goto: preserves the deprecated goto statement; recommends refactoring goto-based control to throw/catch.\n  - dml12_inline: controls inlining of constant arguments for DML 1.2 methods; can speed compilation but changes semantics.\n  - dml12_int: affects integer semantics and code generation (translating integer ops directly to C, handling of odd-sized uintNN types); disabling it enforces modern DML semantics (64-bit arithmetic with truncation on casts/stores) and requires code changes like assert 0 \u2192 assert false and while (1) \u2192 while (true); notes pitfalls such as smaller-width integers being represented in larger native C types under the old behavior."
                        },
                        {
                          "title": "dml12_int",
                          "start_index": 128,
                          "end_index": 128,
                          "node_id": "0206",
                          "summary": "Summary of the partial document:\n- Explains why avoiding legacy features (when replacements exist) improves code cleanliness, consistency, and performance.\n- Describes how to control deprecation/compatibility in the DML compiler (DMLC):\n  - Use --api-version to set the Simics API version.\n  - Build-system variables: SIMICS_API_VERSION (make) or SIMICS_API / MODULE_SIMICS_API (CMake).\n  - Use --no-compat=tag to disable specific legacy features; each tag also exposes a global boolean parameter named _compat_tag.\n- Begins a list of deprecated features removed when using Simics API 7+ (available up to --simics-api=6) and individually disableable with --no-compat=TAG.\n- Details specific compatibility tags:\n  - dml12_goto: preserves the deprecated goto statement; recommended migration is to replace gotos with throw/catch constructs.\n  - dml12_inline: preserves DML 1.2 inline behavior where constant arguments to typed parameters are inlined as constants; can speed compilation but has surprising semantics.\n  - dml12_int: preserves older integer semantics by translating integer ops directly to C, affecting behavior for odd-sized integer types (e.g., uint5 represented as uint8) and requiring code changes (e.g., assert 0 \u2192 assert false, while (1) \u2192 while (true)); modern DML uses 64-bit arithmetic with truncation on casts/stores, and DML 1.4 changes semantics of small signed types (e.g., int1 values)."
                        }
                      ],
                      "node_id": "0203",
                      "summary": "- Discusses rationale for removing legacy features: keeping the code base cleaner, more consistent, avoiding model bloat and performance regressions from redundant/old APIs.\n- Explains how deprecation and compatibility are controlled for DML on the command line: --api-version to select the API, build-system variables (SIMICS_API_VERSION in make, SIMICS_API / MODULE_SIMICS_API in CMake), and the --no-compat=tag flag to disable individual legacy features.\n- Notes that each --no-compat tag also defines a global boolean parameter named _compat_tag that programs can check to detect availability.\n- Introduces a list of deprecated features that were supported up to --simics-api=6 and removed when compiling with Simics API 7 or newer; in older APIs these can be disabled individually with --no-compat=TAG.\n- Describes specific deprecated compatibility features:\n  - dml12_goto: preserves the deprecated goto statement; suggests refactoring goto-based control flow into throw/catch where possible.\n  - dml12_inline: affects inlining of methods in DML 1.2 devices so constant arguments in typed parameters are inlined as constants, which can change compilation behavior and semantics.\n  - dml12_int: major differences in integer arithmetic semantics when enabled \u2014 DMLC maps many integer ops directly to C without DML-specific handling (affecting odd-sized uintNN types), leading to semantic surprises. Practical consequences include required source changes (e.g., assert 0 -> assert false, while (1) -> while (true)), non\u2011standard integer sizes being represented by larger native C types (e.g., uint5 as uint8), and shifts toward 64-bit arithmetic with truncation on casts/stores. It also calls out legacy code patterns that break (e.g., comparing int1 to 1) and how modern DML semantics differ (int1 values being 0 and -1 in DML 1.4).\n- Indicates the document continues with additional deprecated-feature entries and the available tags."
                    }
                  ],
                  "node_id": "0202",
                  "summary": "This partial document discusses deprecation and compatibility control for DML/Simics APIs, covering: rationale for avoiding legacy features (cleaner, more consistent code; less bloat; better performance); how to control API/compatibility on the DML compiler command line (the --api-version flag, SIMICS_API_VERSION/SIMICS_API or MODULE_SIMICS_API build variables, and the --no-compat=tag option that disables specific legacy features and exposes a corresponding global boolean _compat_tag); and a list of deprecated compatibility features removed when moving to Simics API 7+ (features supported up to --simics-api=6). It gives examples of such tags and their effects: dml12_goto (deprecated goto support and suggested rewrite to throw/catch), dml12_inline (inlining constant typed parameters in DML 1.2 with performance/semantic tradeoffs), and dml12_int (legacy integer semantics that map operations directly to C, affect odd-sized integer types, require code changes like replacing assert 0/while (1) with assert false/while (true), and cause different behavior for small-width integer types). The excerpt stops mid-explanation of further dml12_int implications."
                }
              ],
              "node_id": "0199",
              "summary": "This partial document is an appendix section (\"Managing deprecated language features\") from the DML (Device Modeling Language) 1.4 reference manual explaining how language evolution and incompatible changes are handled and how users can migrate large DML code bases. It categorizes types of deprecations\u2014removed/renamed library symbols (easy to fix), semantic changes to language constructs or APIs (harder because they may not produce errors), and changes to how compiled models appear in Simics that affect end-users. It describes the primary deprecation mechanism: associating DML features with Simics API versions, where Simics major-version upgrades drop features from previous API versions. A recommended migration workflow is given: update modules to API N while on Simics N (module-by-module), upgrade Simics to N+1, then migrate modules to API N+1 gradually; Simics N+1 continues to support API N to ease transition. The document also explains compiler flags that can selectively disable deprecated or legacy features to enable incremental migration and to prevent new code from relying on legacy behavior."
            }
          ],
          "node_id": "0129",
          "summary": "- Rules for the automatically created attribute for a connect object: default mode is \"optional\"; the attribute may be set to nil only when the parameter is \"optional\" or \"pseudo\"; for arrays of connects this rule applies element-wise. An internal [bool] flag controls whether the attribute is internal.\n\n- Connect templates: the init_as_subobj template lets a connect automatically instantiate and set itself to an auto-created subobject (useful for private helper objects). It accepts a classname parameter (the class of the created subobject), overrides configuration to \"none\" (making the connect invisible to users), and inherits the init and connect templates. Warning: classname is looked up with SIM_get_class while the device module is loading, so if the subobject class is defined in the same module but later than the device class, the lookup can fail; moving the subobject class to a separate module avoids this.\n\n- Interface objects: the interface template has a required parameter defaulting to true; if set false the interface is optional and the parent connect may attach to objects that do not implement it. The template provides a session variable val (const void *) pointing to the Simics interface struct of the connected object; when optional, val can be compared to NULL to check presence.\n\n- Port objects: the port template exposes an obj parameter which, on Simics API \u22645 evaluates to dev.obj, and on API \u22656 evaluates to the conf_object_t * of the port\u2019s port object.\n\n- Subdevice objects: the subdevice template exposes an obj parameter that evaluates to the conf_object_t * of the Simics object representing the subdevice."
        },
        {
          "title": "Port objects",
          "start_index": 128,
          "end_index": 84,
          "node_id": "0207",
          "summary": "The partial document contains only task instructions: it asks the reader to generate a description of a partial document\u2019s main points and to directly return that description with no additional text. No substantive content or topic-specific material is provided."
        },
        {
          "title": "Subdevice objects",
          "start_index": 84,
          "end_index": 84,
          "node_id": "0208",
          "summary": "- Connect attribute behavior\n  - Specifies how Simics treats the automatically created attribute for a connect object; default is \"optional\".\n  - The attribute may be set to nil only when this parameter is \"optional\" or \"pseudo\"; for arrays of connects this rule applies element-wise.\n  - internal [bool] parameter controls whether the attribute is internal.\n\n- Connect templates\n  - init_as_subobj template: causes the connect to auto-create and assign a private helper object.\n  - Accepts classname parameter that defines the class of the automatically created subobject.\n  - Class lookup uses SIM_get_class during device module loading; if the subobject class is defined in the same module and defined after the device class, lookup may fail \u2014 solution: move subobject class to a separate module.\n  - The template sets configuration to \"none\" by default (making the connect invisible to users) and inherits the init and connect templates.\n\n- Interface objects\n  - interface template has a required parameter (default true); if set to false the interface is optional and the parent connect may attach to objects lacking the interface.\n  - Provides a session variable val of type const void * that points to the Simics interface struct of the connected object; when optional, val can be compared to NULL to detect absence.\n\n- Port objects\n  - port template exposes an obj parameter:\n    - With Simics API 5 or earlier it evaluates to dev.obj.\n    - With Simics API 6 or newer it evaluates to the conf_object_t * of the port's port object.\n\n- Subdevice objects\n  - subdevice template exposes an obj parameter that evaluates to the conf_object_t * of the Simics object representing the subdevice."
        },
        {
          "title": "Implement objects",
          "start_index": 85,
          "end_index": 85,
          "node_id": "0209",
          "summary": "This partial document covers implementation-related templates and bank objects for an I/O memory/register framework. It states that the generic \"implement\" template provides no parameters or methods, and that a single implement template named bank_io_memory can be instantiated to implement the io_memory interface by redirecting accesses to a specified bank. Bank objects inherit both the bank template and the shown_desc template and expose key methods: io_memory_access for handling generic_transaction_t-based accesses (extracting info from the memop, updating it, returning success/failure, and optionally passing auxiliary decoded info via aux); transaction_access for handling transaction_t-based accesses (mapping to read/write/get/set, returning a defined exception type on success or IO-not-taken on failure, with accesses larger than 8 bytes split into smaller chunks); and write for performing writes at an offset (which can throw exceptions to signal failure). The default write behavior forwards accesses to contained registers by determining which registers are hit using register offsets/sizes and bank parameters partial and overlapping; any parts of the access not covered invoke unmapped_write with a bitmask and exceptions from unmapped_write are propagated, causing the access to fail."
        },
        {
          "title": "Implement templates",
          "start_index": 85,
          "end_index": 85,
          "node_id": "0210",
          "summary": "- Section 4.11: Implement objects\n  - Notes that the implement template provides no specific parameters or methods.\n\n- Section 4.12: Implement templates\n  - Describes a single template for implement objects: bank_io_memory.\n  - bank_io_memory is used when implementing the io_memory interface and redirects accesses to a specified bank (via the bank parameter).\n  - Bank objects implement io_memory by inheriting this template.\n\n- Section 4.13: Bank objects\n  - Bank template also inherits shown_desc and defines key methods for handling memory/transaction accesses.\n  - io_memory_access(generic_transaction_t *memop, uint64 offset, void *aux) -> (bool)\n    - Entry point for generic_transaction_t-based accesses.\n    - Extracts info from memop, calls appropriate memop-specific methods, updates memop, returns true on success.\n    - offset is relative to the bank; aux is NULL by default but can carry extra decoded information if io_memory_access is overridden and calls default with aux.\n  - transaction_access(transaction_t *t, uint64 offset, void *aux) -> (exception_type_t)\n    - Entry point for transaction-interface accesses.\n    - Extracts info from t, dispatches to read/write/get/set methods, updates t.\n    - Returns Sim_PE_No_Exception on success or Sim_PE_IO_Not_Taken otherwise.\n    - offset is relative to the bank; aux is used similarly to io_memory_access for passing extra info.\n    - Accesses larger than 8 bytes are split into smaller chunks (implementation details undefined).\n  - write(uint64 offset, uint64 value, uint64 enabled_bytes, void *aux) throws\n    - Describes write behavior at a bank-relative offset; throwing an exception signals failure (commonly for writes outside registers).\n    - Default behavior forwards the write to registers:\n      1. Determine which registers are hit by the access using each register\u2019s offset and size. Partial hits depend on bank parameter partial; non-fully-covering hits depend on bank parameter overlapping.\n      2. If any part of the access is not covered by a hit register, call unmapped_write with a bitmask of the unmapped portions. Exceptions from unmapped_write propagate and cause the access to fail."
        },
        {
          "title": "Bank objects",
          "start_index": 85,
          "end_index": 86,
          "node_id": "0211",
          "summary": "- Scope: Describes the implement template, the single implement template bank_io_memory for redirecting io_memory accesses to a bank, and the structure and behavior of bank objects (which also inherit shown_desc).\n\n- Implement templates: bank_io_memory is the only implement template; it\u2019s instantiated when implementing io_memory and forwards accesses to a specified bank.\n\n- Bank object entry points:\n  - io_memory_access(memop, offset, aux) -> bool: handles generic_transaction_t-based accesses, extracts information, calls memop-free methods, can pass auxiliary decoded info via aux; returns true on success.\n  - transaction_access(t, offset, aux) -> exception_type_t: handles transaction_t-based accesses, maps to read/write/get/set, updates t, returns Sim_PE_No_Exception on success or Sim_PE_IO_Not_Taken otherwise; accesses >8 bytes are split into smaller chunks (details undefined). aux can carry decoded info.\n\n- Read/write flow and unmapped handling:\n  - write(offset, value, enabled_bytes, aux) throws: default forwards to registers. Steps: determine hit registers (using register offsets and bank parameters partial/overlapping), call unmapped_write if any portion is unmapped (may throw to abort), then call write_register on hit registers in ascending offset order.\n  - unmapped_write(offset, value, bits, aux) throws: invoked for writes not fully covered by registers; bits encodes unmapped bytes (in lowest 'size' bits each 0xff byte marks an unmapped byte); value is the original write in host endianness. Default logs a spec-viol message and throws.\n  - read(offset, enabled_bytes, aux) -> value throws: decomposed like write; uses read_register results combined with unmapped_read for unmapped portions.\n  - unmapped_read(offset, bits, aux) throws: default implementation always throws.\n\n- Partial/overlapping semantics: bank parameters control how accesses map to registers:\n  - overlapping (bool): whether accesses spanning multiple registers are allowed (defaults true). Must be same across bank array elements.\n  - partial (bool): whether partial-register accesses are allowed. Partial reads extract touched fields; partial writes merge existing field bits via get and then call write on fields/registers. Defaults true and must be uniform across bank array.\n\n- Additional bank parameters:\n  - mappable (boolean): whether bank is exposed as an io_memory interface port and mappable in a memory space (defaults true).\n  - register_size: inherited from device; provides default size for register objects.\n  - byte_order (string): inherited from device; \"little-endian\" or \"big-endian\" used for multi-byte register accesses.\n\n- Aux parameter usage: aux is NULL by default but can be used to carry extra decoded information from higher-level access methods down to register/field methods."
        },
        {
          "title": "Register objects",
          "start_index": 86,
          "end_index": 88,
          "node_id": "0212",
          "summary": "This partial document describes the behavior and API for memory-mapped register banks and registers in a Simics-like modeling framework. It covers:\n- Access methods: how write_register is invoked for hit registers, and how unmapped_write/unmapped_read are called for accesses not fully covered by registers (including parameters bits and value, endianness, default behaviors, and that throwing an exception aborts the access). It also explains read and its composition from read_register and unmapped_read.\n- Bank template parameters and semantics: mappable (exposed as io_memory), overlapping (allowing accesses spanning registers), partial (allowing sub-register accesses and how partial reads/writes are handled), register_size, byte_order, be_bitorder (presentation hint for field bit numbering), use_io_memory (choosing legacy io_memory vs transaction interface), and obj (port/object compatibility across API versions). Notes that some parameters must be uniform across bank arrays.\n- Register template: inheritance from object and other templates (get, set, shown_desc, read_register, write_register, init_val), and parameters including val, size, bitsize, offset, fields, init_val, configuration (attribute handling), persistent, and internal. Defaults and constraints are noted (e.g., bitsize = size*8).\n- Register methods for unmapped bits: read_unmapped_bits (default masks and returns unmapped regions) and write_unmapped_bits (default compares and logs spec-viol messages for mismatches but does not modify val), and how these are used by default read_register/write_register implementations.\n- Field objects: inheritance from object and templates init_val and shown_desc, inheriting get, set, init methods and the init_val parameter; fields are referenced by registers."
        },
        {
          "title": "Field objects",
          "start_index": 88,
          "end_index": 88,
          "node_id": "0213",
          "summary": "Describes register-template parameters and behaviors: address mapping constraints for bank-array elements (must be uniform across indices); a fields list referencing register field objects; init_val used by default init, hard/soft reset and power-on reset (default 0); configuration setting (\"required\" | \"optional\" | \"pseudo\" | \"none\") controlling how Simics treats the auto-created attribute for the register (default \"optional\"); persistent and internal boolean flags (internal defaults true). Documents overridable methods for handling bits not covered by fields: read_unmapped_bits(unmapped_enabled_bits, aux) used by read_register with a default that masks and returns unmapped bits, and write_unmapped_bits(val, enabled_bits, aux) invoked by write_register for partially covered bytes with a default that compares unmapped bits and logs spec-viol messages for mismatched bitranges without modifying val. Introduces Field objects: field template inherits object, init_val and shown_desc, inherits get, set and init methods and the init_val parameter, and includes a val [integer] parameter."
        },
        {
          "title": "Templates for registers and fields",
          "start_index": 88,
          "end_index": 88,
          "nodes": [
            {
              "title": "4.15 Field objects",
              "start_index": 88,
              "end_index": 89,
              "node_id": "0215",
              "summary": "- Registers: parameters and attributes covered, including fields (list of field object references), init_val (default/reset value, defaults to 0), configuration (how auto-created attributes are treated: \"required\"|\"optional\"|\"pseudo\"|\"none\", default \"optional\"), persistent (bool), and internal (bool, default true). Note that bank-array mapping constraint: register address mapping must be identical across bank indices.\n\n- Register overridable methods: read_unmapped_bits(uint64 unmapped_enabled_bits, void *aux) and write_unmapped_bits(uint64 val, uint64 enabled_bits, void *aux). Default read_unmapped_bits masks and returns unmapped regions; default write_unmapped_bits compares unmapped bits and logs spec-viol messages for mismatches without modifying val. The unmapped_* arguments describe bits not covered by fields.\n\n- Field objects: inheritance from object, init_val and shown_desc templates; inherit get, set and init methods. Field-specific parameters: val (bitslice value convenience), reg (reference to containing register), lsb and msb (required bit indices in little-endian bit numbering; recommendation to use [high:low] shorthand and be careful with big-endian files), bitsize (auto-derived from lsb/msb), and init_val (default/reset value, defaults to 0).\n\n- Templates for registers and fields: many templates apply to both; when writing templates for both, typically inherit read, write, get and set methods. Some methods accept void *aux (default NULL) carrying extra access info; this can be set by overriding the parent bank's io_memory_access method.\n\n- get_val and set_val templates: provide non-overridable methods. get_val() -> uint64 returns a register\u2019s .val or a field\u2019s bits from its parent register (and is unaffected by overridden get). set_val(uint64) sets a register\u2019s .val or the corresponding bits in the parent register for a field. get_val is more efficient but less flexible than get."
            },
            {
              "title": "4.16 Templates for registers and fields",
              "start_index": 89,
              "end_index": 90,
              "nodes": [
                {
                  "title": "4.16.1 get_val",
                  "start_index": 90,
                  "end_index": 91,
                  "node_id": "0217",
                  "summary": "- Describes behavioral templates and overrideable methods for register/field access (sections 4.16.3\u20134.16.9), including get, set, read, write and their *_val / *_field / *_register variants.\n- Notes set_val vs set: set_val is similar to set but is una\ufb00ected if set is overridden (slightly more efficient); generally use set for flexibility.\n- get / set: overrideable methods get() -> uint64 and set(uint64) used for checkpointing/inspection without side-e\ufb00ects; defaults delegate to get_val/set_val. In fields these templates must be explicitly instantiated for overrides to take effect, though field objects have callable defaults.\n- read_register / write_register: register-only abstract interfaces that may have side-e\ufb00ects and operate with an enabled_bytes mask indicating which bytes are accessed. Returned/written values use host endianness.\n- Default register read/write behavior: if register has fields, read_register invokes sub-field read_field (least to most significant), then read_unmapped_bits for bits not covered; write_register similarly invokes write_field then write_unmapped_bits. If no fields, defaults operate on the register's val via set/get.\n- read_field / write_field: abstract interfaces for bit-granular access using enabled_bits masks; not implemented by default and must be instantiated for overrides to take effect. These are the interfaces used by registers to access sub-fields.\n- Important effects of instantiation: implementing read_field/write_field on a register makes the register behave as a single field (ignores sub-field objects), useful for centralized handling (e.g., read-only registers or validation of violating writes).\n- read: extends read_field and get_val, providing overrideable read() -> uint64; default read delegates to get()."
                },
                {
                  "title": "4.16.2 set_val",
                  "start_index": 91,
                  "end_index": 92,
                  "node_id": "0218",
                  "summary": "- Register write behavior:\n  - If a register has no fields, writes set the register's val member via the set method.\n  - If a register has fields, by default write_register invokes write_field on all sub-fields that are at least partially covered by enabled_bytes, in order from least to most significant bit, then calls write_unmapped_bits for enabled bits not covered by fields.\n  - If a register (or field) instantiates the write or write_field template, that template overrides write_register and governs write behavior.\n  - Instantiating write_field on a register makes the register behave as a single field (ignores subfield objects), useful for central handling such as blocking writes to read-only registers.\n\n- read_field template:\n  - Abstract method: read_field(uint64 enabled_bits, void *aux) -> (uint64).\n  - Reads a field or register (possibly with side effects), returning a value in host endianness.\n  - enabled_bits is a bitmask specifying which bits are accessed; returned bits are only significant where enabled_bits has ones. If access spans multiple fields, bits for other fields are zero.\n  - Not implemented by default; must be explicitly instantiated to take effect.\n  - Instantiating read_field on a register makes reads treat the register as a single field, ignoring subfields.\n\n- write_field template:\n  - Abstract method: write_field(uint64 value, uint64 enabled_bits, void *aux).\n  - Writes to a field or register (possibly with side effects), value in host endianness; enabled_bits same semantics as read_field.\n  - Not implemented by default; explicit instantiation required.\n  - Instantiating write_field on a register makes writes treat the register as a single field (ignoring subfields).\n\n- read template:\n  - Extends read_field and get_val.\n  - Overrideable method: read() -> (uint64).\n  - Default behavior retrieves the value using the get method; returns host-endian value.\n  - Not implemented by default; must be instantiated to override.\n  - Instantiating read on a register causes reads to ignore subfield objects (treats register as single field).\n\n- write template:\n  - Extends write_field, get_val, and set_val.\n  - Overrideable method: write(uint64).\n  - Default behavior sets the value using the set method; value in host endianness.\n  - Not implemented by default; explicit instantiation required.\n  - Instantiating write on a register makes writes ignore subfields (treats register as single field).\n\n- init_val parameter:\n  - Provides init_val : uint64 to define initial value of a register's val member (or the bits covered by a field).\n  - Used by default reset methods; default is 0.\n  - In registers with fields, overrides may be provided both at register and field levels:\n    - If overridden only in the register, it defines the full register value.\n    - If overridden in register and some fields, field overrides take precedence for the bits they cover.\n  - Technically, a field's default init_val comes from corresponding bits in parent register's init_val; the template also supplies a default init method that sets bits in val not covered by fields (for registers) or sets parent register bits (for fields).\n\n- Event objects and templates:\n  - The event template is minimal and requires instantiation of one of six predefined templates: simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event.\n  - These event templates expose methods like event and post (and possibly others).\n  - Event objects also inherit the shown_desc template."
                },
                {
                  "title": "4.16.3 get",
                  "start_index": 92,
                  "end_index": 90,
                  "node_id": "0219",
                  "summary": "A single, explicit instruction requiring that the response consist solely of a description and include no additional text."
                },
                {
                  "title": "4.16.4 set",
                  "start_index": 90,
                  "end_index": 90,
                  "node_id": "0220",
                  "summary": "- Explains the difference between set_val and set: set_val is unaffected by overrides (slightly more efficient), while set is more flexible and generally recommended.\n- Describes the get template (extends get_val): provides an overrideable get() -> uint64 to retrieve a register/field value without side effects (used for checkpointing/inspection); default implementation calls get_val. For fields, overrides must be explicitly instantiated, though fields supply a callable default.\n- Describes the set template (extends set_val): provides an overrideable set(uint64) to modify a register/field value without side effects; default calls set_val. For fields, overrides must be explicitly instantiated, with a callable default provided.\n- Details read_register (registers only): abstract read_register(uint64 enabled_bytes, void *aux) -> uint64 reads a register (possibly with side effects); return is in host endianness. enabled_bytes is a byte-wise mask (0xff means that byte is significant); parts corresponding to other registers are zero when crossing register boundaries. Default register implementation calls sub-field read_field methods (least to most significant) for covered bytes and uses read_unmapped_bits for bits not covered by fields. If no fields exist, read_unmapped_bits is not called. If read_field or read templates are inherited, they take precedence over read_register.\n- Introduces write_register (registers only): abstract write_register(uint64 value, uint64 enabled_bytes, void *aux) writes to a register (possibly with side effects); enabled_bytes semantics match read_register. Registers provide a default write implementation whose behavior depends on whether the register has fields (further details follow in the next section)."
                },
                {
                  "title": "4.16.5 read_register",
                  "start_index": 90,
                  "end_index": 90,
                  "node_id": "0221",
                  "summary": "- Discusses register/field value access templates and methods, comparing set_val and set: set_val is unaffected by overrides (slightly more efficient), set is more flexible and generally recommended.\n- get template: extends get_val and provides an overridable get() -> uint64 for retrieving a register/field value without side effects (used for checkpointing/inspection); default uses get_val. In a field, get must be explicitly instantiated for overrides to take effect, though field objects supply a callable default.\n- set template: extends set_val and provides an overridable set(uint64) to modify a register/field value without side effects (used for checkpointing/inspection); default uses set_val. In a field, set must be explicitly instantiated for overrides to take effect, though field objects supply a callable default.\n- read_register (registers only): abstract method read_register(uint64 enabled_bytes, void *aux) -> uint64. Reads may have side effects; return value uses host native endianness. enabled_bytes is a byte-mask specifying which bytes are accessed (bytes only significant if corresponding enabled_bytes byte == 0xff). If access spans multiple registers, enabled_bytes bits for other registers are zero.\n- Default read_register behavior: invokes read_field on all subfields at least partially covered by enabled_bytes in order from least to most significant bit; bits not covered by fields are retrieved via read_unmapped_bits with unmapped_enabled_bits; if a register has no fields, read_unmapped_bits is not called by default.\n- If a register inherits read_field or read templates, those take precedence over read_register and define the register's read behavior.\n- write_register (registers only): abstract method write_register(uint64 value, uint64 enabled_bytes, void *aux). Writes may have side effects; enabled_bytes semantics same as read_register. A register-provided default implementation exists and its behavior depends on whether the register has fields."
                },
                {
                  "title": "4.16.6 write_register",
                  "start_index": 90,
                  "end_index": 90,
                  "node_id": "0222",
                  "summary": "This partial document describes register/field access templates and their override behavior: it contrasts set_val and set (set_val is unaffected by set overrides and slightly more efficient, but set is generally recommended), and explains get/get_val and set/set_val templates\u2014get() and set(uint64) are overrideable, used for checkpointing/inspection without side effects, defaulting to get_val/set_val, and in fields an explicit instantiation is required for overrides (fields still provide callable defaults). It documents register-only abstract methods read_register and write_register, the enabled_bytes mask semantics (each byte of the returned value is significant only if the corresponding enabled_bytes byte is 0xff, with host-native endianness), and multi-register access behavior. The default read_register implementation calls read_field on covered subfields from least to most significant bit and uses read_unmapped_bits for bits not covered by fields (unless the register has no fields); if a register instead inherits read_field or read templates those take precedence over read_register. The write_register method is introduced with similar enabled_bytes semantics and a default implementation whose behavior depends on whether the register has fields (details follow beyond the excerpt)."
                },
                {
                  "title": "4.16.7 read_field",
                  "start_index": 90,
                  "end_index": 97,
                  "node_id": "0223",
                  "summary": "- Explanation of set_val vs set: set_val is unaffected by overrides of set (slightly more efficient); recommendation to use set for flexibility.\n- get and set templates: overrideable get() -> uint64 and set(uint64) methods for inspecting/modifying register values without side-effects; default implementations use get_val/set_val; must be explicitly instantiated in fields to override.\n- read_register / write_register (register-only): abstract methods with enabled_bytes bitmask semantics; default implementations dispatch to read_field/write_field of sub-fields (LSB\u2192MSB) and handle unmapped bits via read_unmapped_bits/write_unmapped_bits; precedence rules when read/write or read_field/write_field templates are implemented.\n- read_field / write_field: abstract field-level interfaces with enabled_bits bitmask semantics; not implemented by default (must instantiate to override); instantiating them on a register makes the register behave as a single field (ignoring sub-field objects).\n- read / write templates: overrideable read() -> uint64 and write(uint64) that extend read_field/get_val and write_field/get_val/set_val respectively; default behaviors use get/set; must be instantiated to take effect; register-level instantiation ignores sub-fields.\n- init_val parameter: defines initial register value or field-covered bits; used by default reset methods; override precedence between register and field-level init_val; default init implementation sets unmapped bits in registers and corresponding bits in parent register for fields.\n- Event objects and templates: event template requires instantiation of one of six predefined templates (simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event); distinctions between simple/uint64/custom and time vs cycle variants; common methods event() and non-overrideable post(); simple/uint64 templates provide remove/posted/next; custom templates add get_event_info, set_event_info, and destroy for checkpointing and custom data handling (destroy must be called explicitly when appropriate).\n- Introduction to standard templates (utility.dml): templates for common register/field behaviors; note that many templates differ only by name/logging; distinction between software (io_memory read/write \u2192 DML read/write) and hardware accesses (Simics config attributes \u2192 DML set/get).\n- Reset templates and behavior: three reset types (power-on, hard, soft) with corresponding templates/ports (poreset/hreset/sreset \u2192 POWER/HRESET/SRESET) invoking power_on_reset/hard_reset/soft_reset methods; default reset restores init_val and recursively calls sub-objects; ways to override or suppress resets (e.g., soft_reset_val, sticky, no_reset); guidance on modeling POWER as either a pure reset or an accurate power supply.\n- Examples of register/field templates: soft_reset_val (override soft reset value), ignore_write (ignore software writes), read_zero (reads always return 0), read_only (software-read-only but hardware-modifiable, with specific logging behavior)."
                },
                {
                  "title": "4.16.8 write_field",
                  "start_index": 97,
                  "end_index": 98,
                  "node_id": "0224",
                  "summary": "Covers reset callbacks and register/field templates and their behaviors. Describes implemented reset callbacks on objects and top-level reset templates for power-on, hard, and soft resets (power_on_reset, hard_reset, soft_reset), and a soft_reset_val template to override the default init_val on soft reset. Explains general semantics when applying templates to registers vs fields (e.g., a template on a register can override field read implementations while writes still propagate to fields). Lists and explains per-template behaviors: ignore_write (writes ignored), read_zero (reads return 0), read_only (software cannot modify value; hardware can; spec_violation logging on first/remaining writes; suggestion to prefer ignore_write for read-only fields in writable registers), write_only (software can write but reads return 0; logging on first/remaining reads; for registers only), write_1_clears (writing 1 clears bits; new value = old & ~written), clear_on_read (read returns value then clears it), write_1_only (software can only set bits; new = old | written) and write_0_only (software can only clear bits; new = old & written), and read_constant (reads return a constant read_val while stored value and writes remain unaffected; contrast with constant template for non-storing constants). Mentions related templates referenced for several entries."
                },
                {
                  "title": "4.16.9 read",
                  "start_index": 98,
                  "end_index": 91,
                  "node_id": "0225",
                  "summary": "A single, explicit instruction requiring the responder to provide a direct description of the partial document and to include no additional or extraneous text, emphasizing concise, standalone output."
                },
                {
                  "title": "4.16.10 write",
                  "start_index": 91,
                  "end_index": 91,
                  "node_id": "0226",
                  "summary": "- Behavior of register writes:\n  - If a register has no fields, the default write sets the register's val member to the new value using the set method.\n  - If a register has fields, the default write invokes write_field on all sub-fields that are at least partially covered by enabled_bytes, in order from least to most significant bit, then calls write_unmapped_bits for enabled bits not covered by any field.\n  - If a register inherits a write or write_field template, that template overrides write_register and defines the register's write behavior.\n\n- write_field:\n  - Abstract method signature: write_field(uint64 value, uint64 enabled_bits, void *aux).\n  - Performs writes to a field or register, possibly with side effects; value is in the host's native endianness.\n  - enabled_bits is a bitmask indicating which bits are being written; bits outside enabled_bits are not significant.\n  - Not implemented by default for fields or registers; must be explicitly instantiated for overrides to take effect.\n  - write_field is the low-level interface used by registers, though higher-level write templates are usually easier to use.\n  - Instantiating write_field on a register causes the register to behave as a single field for writes (ignoring actual subfield objects), useful for central handling of invalid writes (e.g., read-only registers).\n\n- read_field:\n  - Abstract method signature: read_field(uint64 enabled_bits, void *aux) -> (uint64).\n  - Performs reads from a field or register, possibly with side effects; returned value is in the host's native endianness.\n  - enabled_bits is a bitmask defining which bits of the register are accessed; each bit of the return is significant only when the corresponding enabled_bits bit is 1. If the access spans multiple fields, the enabled_bits parts for other fields are zero.\n  - Not implemented by default for fields or registers; must be explicitly instantiated for overrides to take effect.\n  - read_field is the register-access interface, but higher-level read templates are usually easier to express.\n  - Instantiating read_field on a register makes reads behave as if the register is a single field, ignoring actual subfield objects.\n\n- read:\n  - Extends read_field and get_val templates.\n  - Provides an overrideable method read() -> (uint64).\n  - Performs reads from a field or register; return is in host native endianness.\n  - Default read behavior is to retrieve the value using the get method."
                },
                {
                  "title": "4.16.11 init_val",
                  "start_index": 91,
                  "end_index": 101,
                  "node_id": "0227",
                  "summary": "This partial document is from the Device Modeling Language (DML) reference and covers templates and behaviors for registers/fields, event objects, and standard templates. Main points:\n\n- Register write semantics:\n  - Default: if no fields, set the register's val via set; if fields exist, invoke write_field on sub-fields covered by enabled_bytes (least to most significant), then call write_unmapped_bits for uncovered enabled bits.\n  - Inherited write or write_field templates override write_register, causing reads/writes to treat the register as a single field (ignoring sub-field objects).\n  - write_field and write operate on host-native endianness; enabled_bits masks which bits are affected.\n  - read_field/write_field are abstract and not active unless explicitly instantiated; they are the low-level register-access interfaces, though read/write templates are usually easier to use.\n\n- Read semantics:\n  - read_field and read return uint64 in host endianness; enabled_bits indicates significance of returned bits.\n  - Instantiating read or read_field on a register makes reads treat the register as a single field, ignoring sub-field implementations.\n\n- init_val:\n  - Parameter init_val defines initial val for registers and covered bits for fields; defaults to 0.\n  - Overrides can be at register or field level; field overrides take precedence for covered bits.\n  - init_val provides default init behavior and influences reset defaults.\n\n- Event objects and templates:\n  - Event template requires one of six specific templates: simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event.\n  - simple_* carry no data; uint64_* carry a 64-bit value; custom_* require user serialization.\n  - Time variants use seconds (double), cycle variants use cycles (uint64).\n  - All define event() (abstract) and post(time, optional data) (non-overrideable) to post events to a device queue.\n  - simple/uint64 templates add remove, posted, next methods.\n  - custom templates add get_event_info, set_event_info (for checkpointing), and destroy (for freeing user data).\n\n- Reset templates and behavior:\n  - Three reset types: power-on (POWER/poreset), hard (HRESET/hreset), soft (SRESET/sreset), with corresponding callbacks (power_on_reset, hard_reset, soft_reset).\n  - Default resets recursively restore init_val; reset methods can be overridden or suppressed.\n  - Standard helpers: soft_reset_val to customize soft-reset value; sticky to suppress soft reset; no_reset to suppress all resets.\n  - Guidance on modeling POWER as either a reset signal or an accurate power-supply signal (affects initial state and behavior).\n\n- Standard templates for registers/fields (read/write and other common behaviors):\n  - Access modifiers: ignore_write, read_zero, read_only, write_only, write_1_clears, clear_on_read, write_1_only, write_0_only.\n  - Constant/immutable variants: read_constant (returns a constant on reads), constant (writes forbidden), silent_constant, zeros, ones.\n  - Status/intent markers: ignore, reserved, undocumented, design_limitation.\n  - Unimplemented variants and logging: unimpl, read_unimpl, write_unimpl, silent_unimpl \u2014 describe default behavior and logging levels for first vs subsequent accesses.\n  - Misc: unmapped (exclude register from bank address space), sticky (preserve value on soft reset), no_reset (do not change on hard/soft reset).\n\n- Notes on template application:\n  - Many templates apply to both registers and fields; applying certain templates to a register causes reads to disregard sub-fields (treat as single field), while writes may still propagate to fields.\n  - Logging behavior differs by template and first vs later accesses.\n\n- Context:\n  - This material is part of the Standard Templates chapter of DML 1.4 (utility.dml), describing common patterns for device register modeling. The excerpt ends as bank-related templates begin."
                }
              ],
              "node_id": "0216",
              "summary": "- Describes field/register parameters: reg (reference to containing register), lsb and msb (required bit positions in little-endian bit numbering; recommends using [high:low] shorthand and warns about big-endian pitfalls), bitsize (auto-derived from lsb/msb), and init_val (default value used for init and reset, defaults to 0).\n- Notes the field-level val bitslice: direct manipulation of a field\u2019s val is a simpler alternative to get_val()/set_val(), but val is not part of the field template type and can\u2019t be used in all contexts.\n- Introduces templates specific to registers and fields (section 4.16), stating that all templates except read_register and write_register apply to both registers and fields, and advising inheritance of read/write/get/set when writing templates usable by both.\n- Explains the auxiliary void *aux argument (default NULL) for some methods and how it can be set via the parent bank\u2019s io_memory_access method.\n- get_val and set_val: non-overridable, efficient methods that read/write the raw register or field bits (field versions operate on the parent register\u2019s val subset); they are unaffected by overrides of get/set and are slightly more efficient but less flexible.\n- get and set: overrideable methods (default implementations call get_val/set_val) intended for checkpointing/inspection without side effects; field templates must be explicitly instantiated for overrides to take effect, though callable defaults exist.\n- read_register (registers only): abstract method signature and semantics; reads may have side effects, return host-endian value, and accept enabled_bytes bitmask indicating which bytes are significant. Default implementation calls read_field on covered subfields (least to most significant) and read_unmapped_bits for bytes not covered by fields; read_field/read templates override read_register behavior.\n- write_register (registers only): abstract write method with the same enabled_bytes concept; default behavior depends on whether the register contains fields (details continue beyond the partial text)."
            },
            {
              "title": "4.17 Event objects",
              "start_index": 101,
              "end_index": 92,
              "node_id": "0228",
              "summary": "A brief meta-instruction telling the reader to directly return a description of the partial document and to include no other text or additional content."
            },
            {
              "title": "4.18 Event templates",
              "start_index": 92,
              "end_index": 94,
              "node_id": "0229",
              "summary": "- Read and write templates\n  - Both extend lower-level templates (read_field/get_val/set_val for read; write_field/get_val/set_val for write) and provide a single overridable method: read(uint64) or write(uint64).\n  - Default behavior uses the set/get methods; read/write are not implemented by fields or registers by default and must be explicitly instantiated for overrides to take effect.\n  - Instantiating read or write on a register makes the register behave as a single field: register accesses will ignore any actual field subobjects.\n\n- init_val parameter\n  - Extends the init template and supplies init_val : uint64 to define the initial value for a register's val member (or the bits covered by a field).\n  - Default is 0. Overrides may be given at the register and/or field level:\n    - If overridden only at the register, it defines the register's full initial value.\n    - If overridden at both register and some fields, field overrides take precedence for bits they cover.\n  - Implementation detail: a field's default init_val is derived from its parent register's init_val; the template also provides default init methods to set bits not covered by fields (register) or to set corresponding bits in the parent's val (field).\n\n- Event objects and templates\n  - The event template itself is minimal and must instantiate one of six predefined templates: simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event.\n  - The event template also inherits shown_desc.\n\n- Event template variants and semantics\n  - simple_*: carry no data.\n  - uint64_*: carry a single 64-bit integer payload.\n  - custom_*: carry arbitrary data; user must supply serialization/deserialization for checkpointing.\n  - *_time_event: time is in seconds (floating-point).\n  - *_cycle_event: time is in cycles (64-bit integer).\n\n- Common methods (all six templates)\n  - event(), event(uint64 data), event(void *data): abstract handler invoked when the event triggers. For custom events, event() should free any allocated data.\n  - post(time), post(time, uint64 data), post(time, void *data): non-overridable; posts the event to the device queue to fire after the specified time (units depend on template). Data passed to post is forwarded to event().\n\n- Methods specific to simple_* and uint64_* templates\n  - remove(), remove(uint64 data): remove matching events from the queue.\n  - posted() -> bool, posted(uint64 value) -> bool: test whether an event is in the queue.\n  - next(), next(uint64 data) -> (double or cycles_t): time until next occurrence (relative), or negative if none.\n\n- Methods specific to custom_* templates\n  - get_event_info(void *data) -> attr_value_t: called per pending event when saving a checkpoint; should produce an attribute to restore the event (default returns nil).\n  - set_event_info(attr_value_t info) -> void *: used to recreate user data when restoring a checkpoint (default checks for nil).\n  - destroy(void *data): called on posted events when the device object is deleted; should free any allocated data. Note: destroy is not called automatically when an event triggers, so event() should typically free data as well."
            },
            {
              "title": "5 Standard Templates",
              "start_index": 95,
              "end_index": 95,
              "nodes": [
                {
                  "title": "5.1 Templates for reset",
                  "start_index": 95,
                  "end_index": 96,
                  "nodes": [
                    {
                      "title": "5.1.1 power_on_reset, hard_reset, soft_reset",
                      "start_index": 96,
                      "end_index": 96,
                      "node_id": "0232",
                      "summary": "- Describes reset behavior templates (power_on_reset, hard_reset, soft_reset) applied by default to all registers/fields, with init_val as the default restore value.\n- Explains that signal_raise and signal_lower can be overridden to add side effects when reset signals change (e.g., prevent interaction during reset).\n- Notes the default reset methods recursively call corresponding resets in sub-objects; overriding a reset without calling default() suppresses resets in sub-objects.\n- Covers common overrides: changing reset target values (via explicit override or soft_reset_val parameter for soft reset) and suppressing resets using standard templates (sticky suppresses soft reset; no_reset suppresses all resets).\n- Recommends creating only an HRESET port when hard reset and power-on reset behave identically, using the presence of a POWER port to indicate distinct power-cycling behavior.\n- Discusses less common cases: replacing SRESET with device-specific port names when needed while preserving POWER and HRESET if unambiguous.\n- Recommends how to simulate a powered-off state: treat POWER high as powered, device behaves as powered-off while POWER is low, and device is reset when POWER is lowered; if used, POWER must be raised explicitly after instantiation.\n- Explains two approaches to handling POWER: treat as a pure reset port (convenient but unsuitable for accurate power-supply modeling) or treat as an actual power supply (raise before simulation, lower on power-down, with reset on low\u2192high transition; more correct but less convenient)."
                    },
                    {
                      "title": "5.1.2 poreset, hreset, sreset",
                      "start_index": 96,
                      "end_index": 97,
                      "node_id": "0233",
                      "summary": "- Describes reset handling infrastructure: power_on_reset, hard_reset and soft_reset callbacks are implemented on objects (automatically on registers/fields) and default to restoring init_val; signal_raise/signal_lower can be overridden for additional side effects.\n- Explains default recursive reset behavior (sub-objects\u2019 resets are invoked unless an override omits calling default()), and consequences of suppressing recursive resets.\n- Covers common override patterns: changing reset target values (explicit override or using soft_reset_val for soft resets) and suppressing resets using standard templates (sticky suppresses soft reset; no_reset suppresses all resets).\n- Recommends port usage: if hard and power-on reset behave the same, create only HRESET; presence of POWER implies distinct power-cycle behavior.\n- Discusses uncommon cases: remapping SRESET to device-specific names when multiple soft-reset-like signals exist; options for accurately simulating powered-off state (POWER high = powered, low = off and triggers reset on lowering), and the implication that a device may start \u201coff\u201d and require POWER to be raised before functioning.\n- Describes two ways to treat POWER: as a pure reset port (convenient but limited) or as an actual power supply signal (more correct for accurate power modeling).\n- Documents templates for registers and fields and how they interact with read/write semantics (noting that applying a template to a register can override field-level read implementations, e.g., read_unimpl behavior).\n- Lists specific register/field templates covered:\n  - soft_reset_val: defines soft-reset value via parameter instead of init_val.\n  - ignore_write: software writes are ignored (useful for maintaining writable registers with read-only fields).\n  - read_zero: reads always return 0; writes unaffected.\n  - read_only: software cannot change the value (hardware may); logging: first software write logs spec_violation at level 1, subsequent writes at level 2; field logging only if value changes."
                    }
                  ],
                  "node_id": "0231",
                  "summary": "This partial document describes the DML (Device Modeling Language) standard templates (from utility.dml) with emphasis on reset-related templates and behavior. Main points:\n\n- Scope and usage\n  - Standard templates apply to both registers and fields and are available after importing utility.dml.\n  - Many templates share functionality and differ mainly by name or log messages (e.g., undocumented vs reserved to hint documentation status or usage restrictions).\n  - The text uses the term \u201cobject\u201d to mean either a register or a field.\n\n- Access semantics\n  - Distinguishes software vs hardware accesses:\n    - Software reads/writes use the io_memory interface and DML built-in read/write methods.\n    - Hardware accesses use Simics configuration attributes and DML set/get methods.\n  - Device code can still modify registers even if hardware modification is disallowed.\n\n- Reset concepts and templates\n  - Describes three reset types: power-on reset, hard reset, and soft reset, and their typical meanings:\n    - Power-on: when power is first applied.\n    - Hard reset: triggered by a physical hard-reset line (often same as power-on).\n    - Soft reset: triggered by software (e.g., register write); may be multiple or absent on some devices.\n  - DML provides templates poreset, hreset, sreset that:\n    - Create ports named POWER, HRESET, SRESET implementing a signal interface.\n    - Trigger methods power_on_reset, hard_reset, soft_reset on rising edges in all objects implementing the corresponding templates.\n    - Default behavior: all registers/fields implement these templates and reset to their init_val.\n    - signal_raise and signal_lower may be overridden for additional side effects (e.g., tracking reset assertion).\n    - Default reset methods recursively call reset on sub-objects; overriding without calling default() suppresses resets in sub-objects.\n\n- Common template customizations\n  - Two common overrides:\n    - Change reset value: via method override or the soft_reset_val template (for soft reset values).\n    - Suppress reset: sticky (suppresses soft reset only) or no_reset (suppresses all resets).\n\n- Recommendations and special cases\n  - If hard and power-on resets are identical, prefer creating only an HRESET port to signal that POWER would imply distinct power-cycle behavior.\n  - For devices with multiple hardware-specific reset types, replace SRESET with clearer device-specific port names, while preserving POWER and HRESET if unambiguous.\n  - Modeling powered-off behavior:\n    - Recommended convention: POWER high = device powered; POWER low = device inactive and should not react; lowering POWER triggers reset.\n    - If using this scheme, the device is considered powered off after instantiation, so POWER must be raised explicitly before normal operation.\n    - Two modeling approaches for POWER:\n      - Treat POWER as a pure reset port (convenient but may misrepresent power-off behavior).\n      - Treat POWER as an actual power supply (more accurate: signal raised before simulation, lowered when power off; reset is a lower-then-raise)."
                },
                {
                  "title": "5.2 Templates for registers and fields",
                  "start_index": 97,
                  "end_index": 97,
                  "nodes": [
                    {
                      "title": "5.2.1 soft_reset_val",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0235",
                      "summary": "- Describes reset-related interfaces and templates:\n  - A generic reset-callback interface implemented on objects to receive corresponding reset events; registers and fields get this automatically.\n  - Top-level templates for standard resets: power-on reset, hard reset, and soft reset (poreset/hr eset/sr eset \u2192 power_on_reset, hard_reset, soft_reset).\n- Explains that many templates can be applied to both registers and fields and typically affect either read or write behavior; when applied to a register they override field-level read implementations (writes still propagate to fields).\n- Documents specific register/field templates:\n  - soft_reset_val: sets the reset value used on soft reset via the soft_reset_val parameter (related to soft_reset).\n  - ignore_write: causes writes to be ignored; useful for making individual fields effectively read-only inside a writable register.\n  - read_zero: reads always return 0 while writes remain unaffected (related to read_constant).\n  - read_only: permits hardware modification but prevents software writes; software write attempts generate log messages (first write as spec_violation at log level 1, subsequent writes at level 2); fields only log when the written value differs from the old value."
                    },
                    {
                      "title": "5.2.2 ignore_write",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0236",
                      "summary": "- Reset callback templates: a generic \"reset\" callback is implemented on any object to get notified of the corresponding reset event; registers and fields implement this automatically.\n- Top-level reset templates: power-on, hard, and soft reset behaviors are provided by por/hreset/sreset (related templates: power_on_reset, hard_reset, soft_reset).\n- Templates for registers and fields: a set of templates can be applied to both registers and fields, most affecting either read or write operations. When applied to a register, the template overrides field-level implementations for that operation (e.g., a read_unimpl on a register causes reads to return the register value via get and ignore field read overrides, while writes still propagate to fields).\n- soft_reset_val: when applied to a register or field, defines the value used on soft reset (soft_reset_val) instead of the default init_val; related template: soft_reset.\n- ignore_write: writes from software are ignored; useful for implementing read-only behavior for fields inside otherwise writable registers (see read_only for differences).\n- read_zero: reads always return 0 regardless of stored value; writes are unaffected; related template: read_constant.\n- read_only: software cannot modify the object value (but hardware can). Logging: the first software write generates a spec_violation at log level 1; subsequent writes generate log level 2. For fields, writes only log if the written value differs from the old value. If a register contains both read-only and writable fields, consider ignore_write for fields to avoid undesirable logging/behavior."
                    },
                    {
                      "title": "5.2.3 read_zero",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0237",
                      "summary": "This partial document describes reset- and access-related templates for register/field objects. Key points:\n- Reset callbacks: a generic reset-callback template is implemented on any object (auto-implemented for registers and fields) to receive reset events; related templates listed as poreset, hreset, sreset.\n- Top-level reset templates: separate top-level templates provide standard behavior for power-on, hard, and soft resets (power_on_reset, hard_reset, soft_reset).\n- Templates applicability: several templates can be applied to both registers and fields and typically affect either read or write behavior; when applied at the register level, they override field implementations for that operation (example: read_unimpl on a register ignores field read implementations but writes still propagate to fields).\n- soft_reset_val: allows specifying a soft-reset value (soft_reset_val) for a register or field that overrides the default init_val; related to soft_reset.\n- ignore_write: causes writes to be ignored (useful for making individual fields effectively read-only inside writable registers).\n- read_zero: makes reads always return 0 while leaving writes unaffected; related to read_constant.\n- read_only: marks an object as read-only to software while permitting hardware modifications; software writes generate log messages (first write as spec_violation at level 1, subsequent writes at level 2), and fields only log if the written value changes. The document notes that for registers containing both read-only and writable fields, ignore_write may be preferable since software often does not care about what is written to such fields."
                    },
                    {
                      "title": "5.2.4 read_only",
                      "start_index": 97,
                      "end_index": 97,
                      "node_id": "0238",
                      "summary": "- Reset callbacks and top-level reset templates: objects can implement a reset callback (auto-implemented for registers and fields). Top-level templates provide standard power-on, hard and soft reset behavior (por/ hreset/ sreset linked to power_on_reset, hard_reset, soft_reset).\n- Template application rules for registers and fields: many templates apply to both registers and fields and typically affect either read or write operations. When applied to a register, a template can override/disregard field-level implementations for the affected operation (e.g., a read template on a register ignores field read overrides and returns the register value), while other operations (like writes) may still propagate to fields.\n- soft_reset_val: lets a register or field use a specific soft-reset value (soft_reset_val) instead of the default init_val; related to the soft_reset template.\n- ignore_write: makes writes be ignored (useful for read-only fields inside writable registers; see read_only notes).\n- read_zero: makes reads always return 0 (writes unchanged); related to read_constant.\n- read_only: marks an object as read-only to software while hardware can modify it. Software writes generate spec_violation log messages (first write at log-level 1, subsequent writes at log-level 2); fields only log when the written value actually changes. For registers containing both read-only and writable fields, consider ignore_write instead, since software often ignores written values."
                    },
                    {
                      "title": "5.2.5 write_only",
                      "start_index": 97,
                      "end_index": 98,
                      "node_id": "0239",
                      "summary": "This partial document describes reset callbacks and a set of behavioral templates that can be applied to registers and fields. It explains that objects implement reset callbacks (automatically for registers and fields) and that top-level templates provide standard power-on, hard, and soft reset behavior (power_on_reset, hard_reset, soft_reset). It then covers that templates may be applied to either registers or fields and often affect only reads or writes; applying a template at the register level can override field-level read behavior while writes still propagate to fields. The listed templates include: soft_reset_val (use a specified soft_reset_val instead of init_val on soft reset); ignore_write (ignore software writes); read_zero (reads return 0); read_only (software cannot modify value, hardware can; first bad write logs at spec_violation level 1, subsequent at level 2; fields only log on value change); write_only (software can write but reads return 0, with similar logging behavior); write_1_clears (writing 1 clears bits via old_value & ~write_value); clear_on_read (read returns value and then clears it); write_1_only (writes can only set bits via OR); write_0_only (writes can only clear bits via AND); and read_constant (reads always return a constant read_val while writes and the stored attribute are unaffected)."
                    },
                    {
                      "title": "5.2.6 write_1_clears",
                      "start_index": 98,
                      "end_index": 98,
                      "node_id": "0240",
                      "summary": "Summary of the partial document: descriptions of several register/field access templates and their semantics.\n\n- write_only: Register value can be modified by software but cannot be read back (reads return 0). Intended for registers; for write-only fields prefer read_zero. Logging: first read generates a spec_violation at log-level 1, subsequent reads at log-level 2.\n\n- write_1_clears: Software clears bits by writing 1s; commonly used where hardware sets bits and software writes 1 to acknowledge. New value = old_value AND (bitwise complement of the value written).\n\n- clear_on_read: Reads return the object value, and the object's value is reset to 0 as a side-effect of the read.\n\n- write_1_only: Software can only set bits to 1. New value = old_value OR value_written. Related template: write_0_only.\n\n- write_0_only: Software can only set bits to 0. New value = old_value AND value_written. Related template: write_1_only.\n\n- read_constant: Reads always return a specified constant value; writes do not affect the read result. The stored attribute reflects the actual stored value (not the read-returned constant). Intended for registers/fields that store a value but must return a fixed read value; for non-storing constant registers use the separate constant template. Parameters: read_val (the constant return value)."
                    },
                    {
                      "title": "5.2.7 clear_on_read",
                      "start_index": 98,
                      "end_index": 98,
                      "node_id": "0241",
                      "summary": "- Discusses register/field access templates and their semantics for software reads/writes.\n- write_only: register can be modified by software but reads return 0; intended only for registers (use read_zero for write-only fields); first read logs a spec_violation at level 1, subsequent reads at level 2.\n- write_1_clears: software clears bits by writing 1s; new value = old_value AND (NOT written_value); used for hardware-set, software-clear acknowledgment bits.\n- clear_on_read: reads return the object value and then reset the object value to 0 as a side effect.\n- write_1_only: software can only set bits to 1; new value = old_value OR written_value; related template: write_0_only.\n- write_0_only: software can only set bits to 0; new value = old_value AND written_value; related template: write_1_only.\n- read_constant: reads always return a specified constant (writes unaffected); stored register/field attribute reflects stored value (not the read value); for non-stored constant registers/fields use the constant template; parameter: read_val (the constant returned)."
                    },
                    {
                      "title": "5.2.8 write_1_only",
                      "start_index": 98,
                      "end_index": 99,
                      "node_id": "0242",
                      "summary": "This partial document lists and explains register/field access templates and their semantics, including read/write behavior, side effects, logging, and related parameters. It covers write-only (reads return 0 and produce spec_violation logs), templates that change bits on specific write values (write_1_clears: writing 1 clears bits; write_1_only: writing sets bits via OR; write_0_only: writing clears bits via AND), and clear_on_read (reads return the value then reset it to 0). It describes read_constant (reads always return a specified constant regardless of stored backing value) and constant/silent_constant (writes are ignored; backing storage exists and can be tweaked, with silent_constant intended to avoid model updates). It also documents zeros and ones (registers fixed to all 0s or all 1s, writes ignored) and specifies logging behavior for first vs. subsequent spec violations (first at log-level 1, remaining at log-level 2). Parameters like read_val and init_val and cross-references to related templates are noted."
                    },
                    {
                      "title": "5.2.9 write_0_only",
                      "start_index": 99,
                      "end_index": 98,
                      "node_id": "0243",
                      "summary": "The provided partial document contains no text or substantive content, so there are no main points or topics to summarize."
                    },
                    {
                      "title": "5.2.10 read_constant",
                      "start_index": 98,
                      "end_index": 99,
                      "node_id": "0244",
                      "summary": "This excerpt documents a set of register/field access templates and their semantics, including logging and parameters. Key templates: write_only (modifiable by software but reads return 0; first read logs a spec_violation at level 1, subsequent reads at level 2). write_1_clears (software clears bits by writing 1; new value = old & ~written). clear_on_read (reads return the value and then reset it to 0). write_1_only (software can only set bits to 1; new value = old | written) and write_0_only (software can only set bits to 0; new value = old & written). read_constant (reads always return a specified constant regardless of stored backing value; parameter read_val; related to constant, silent_constant, read_zero). constant (writes are forbidden and ignored, but backing storage exists and can be tweaked via attributes; init_val parameter; first illegal write logs spec_violation level 1, subsequent writes level 2). silent_constant (object remains constant, writes ignored without logging; init_val parameter; related to constant/read_constant). zeros and ones (special cases: constant 0 or all 1s respectively; writes ignored and illegal writes generate spec_violation logging on first write). Related-template cross-references and intended usage notes (e.g., use read_zero for write-only fields, use constant vs read_only distinctions) are also provided."
                    },
                    {
                      "title": "5.2.11 constant",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0245",
                      "summary": "This partial document section documents register/field templates that enforce constant values and their behaviors. It covers:\n- The \"constant\" template: writes are forbidden and have no effect on the object value (backing storage still holds a value that affects reads); using this template signals that the model should not update the register value or override the read method; parameter init_val; related templates read_constant, silent_constant, read_only; logging: first write (or field write that changes value) emits a spec_violation at log-level 1, subsequent writes at log-level 2.\n- The \"silent_constant\" template: object value remains constant and software writes are ignored (do not update the value); end-user tweaks to the attribute persist across reset; parameter init_val; related templates constant, read_constant; convention is that the model should not modify the value (use ignore_write if model should ignore writes but behave differently).\n- The \"zeros\" and \"ones\" templates: special-case constants for all-0 and all-1 values respectively; software writes do not update the object value; logging matches constant behavior (first offending write spec_violation log-level 1, remaining writes log-level 2).\n- Cross-references to related templates (e.g., read_constant, read_only, ignore_write) and distinctions between forbidding writes versus ignoring them and whether the model is expected to modify the stored value."
                    },
                    {
                      "title": "5.2.12 silent_constant",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0246",
                      "summary": "This partial document defines several register/value templates and their behaviors: it lists related templates and then describes the \"constant\" template (writes are forbidden and have no effect on the intended constant value, though backing storage still exists so end-users can tweak the attribute and those tweaks persist across resets; models should not update the register value or override read unless using read_only). It specifies logging: a first write that changes value triggers a spec_violation at log-level 1 and subsequent writes at level 2; the template accepts an init_val parameter and relates to read_constant, silent_constant, and read_only. The \"silent_constant\" template makes the object value remain constant and ignores writes (tweaks by end-users persist across reset); it takes an init_val parameter and is related to constant and read_constant (models should avoid modifying the value unless ignore_write behavior is desired). The \"zeros\" template fixes the object value to 0, forbids software writes, and uses the same spec_violation logging behavior (first offending write level 1, remaining writes level 2). The \"ones\" template fixes the object to all 1s, disallows software writes, and uses the same logging semantics for offending writes."
                    },
                    {
                      "title": "5.2.13 zeros",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0247",
                      "summary": "The partial document lists several register/field value templates and their key behaviors: \n- Related templates section references constant, silent_constant, and read_zero. \n- constant: marks an object intended to stay constant; writes are forbidden and have no effect on the model, though the object retains backing storage so end-users can tweak the value via the register attribute and those tweaks survive reset. The template signals the model not to update the register value or override the read method; use read_only if a different read-only behavior is desired. Parameters: init_val. Log output: the first write that changes the value generates a spec_violation at log-level 1, subsequent writes at log-level 2. Related templates: read_constant, silent_constant, read_only. \n- silent_constant: the value remains constant and software writes are ignored (do not update the object value); end-user tweaks to the backing storage survive reset. By convention the model should not modify the value; use ignore_write if model updates are desired. Parameters: init_val. Related templates: constant, read_constant. \n- zeros: object value is constant zero; software writes are forbidden and do not update the value. Log output: first differing write logs spec_violation at level 1, remaining writes at level 2. \n- ones: object value is constant all 1s; software writes do not update the value. Log output: same spec_violation behavior as zeros."
                    },
                    {
                      "title": "5.2.14 ones",
                      "start_index": 99,
                      "end_index": 99,
                      "node_id": "0248",
                      "summary": "This partial document describes several register/field template behaviors and their relationships:\n\n- Related templates (5.2.10.3): lists constant, silent_constant, read_zero as related templates for a preceding template.\n\n- constant (5.2.11): writes are forbidden and have no effect on the register API, but the object retains backing storage so reads reflect a stored value. End-users can modify that stored value via the register attribute and such tweaks survive reset. Using this template indicates the model should not update the register value or override the read method; use read_only if a different read-only behavior is desired. First conflicting write produces a spec_violation log at level 1, subsequent writes at level 2. Parameter: init_val. Related templates: read_constant, silent_constant, read_only.\n\n- silent_constant (5.2.12): the object value remains constant and writes are ignored (do not update the object value). End-user tweaks to the stored value survive reset. By convention the model should not modify the object value; if the goal is to ignore writes, consider the ignore_write template. Parameter: init_val. Related templates: constant, read_constant.\n\n- zeros (5.2.13): object value is constant zero; software writes are forbidden and do not update the value. Logging: the first software write (if it would change the value) triggers a spec_violation at level 1, subsequent writes at level 2.\n\n- ones (5.2.14): object value is constant all ones; software writes do not update the value. Logging behavior mirrors zeros (first conflicting write level 1, remaining writes level 2)."
                    },
                    {
                      "title": "5.2.15 ignore",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0249",
                      "summary": "- ignore: Object functionality is unimportant \u2014 reads return 0 and writes are ignored.\n- reserved: Object is reserved and should not be used by software \u2014 writes update the object value and reads return the value. First software write to a register or field (if the field value differs from the written value) generates a spec-viol log at level 2; no logs on subsequent writes.\n- unimpl: Object functionality is unimplemented; warn on use. Reads and writes use default implementations. Log behavior: first register read/write produces an unimplemented log at level 1, subsequent reads/writes at level 3; reads from fields do not log; first field write (if value differs) logs at level 1, subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n- read_unimpl: Read functionality is unimplemented while write uses the default (overridable). Logging: first software read to a register logs unimplemented at level 1, remaining register reads at level 3; field reads do not log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n- write_unimpl: Write functionality is unimplemented while read uses the default (overridable). Logging: first software write to a register logs unimplemented at level 1, remaining register writes at level 3; first field write (if value differs) logs at level 1, remaining field writes at level 3. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.16 reserved",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0250",
                      "summary": "This partial document defines several register/object behavior templates and their read/write and logging semantics:\n\n- ignore: Object functionality is unimportant; reads always return 0 and writes are ignored.\n\n- reserved: Object is reserved and should not be used by software. Writes update the object value and reads return that value. The first software write to a register or field (if the field value changes) generates a spec-violation log message at log-level 2; subsequent writes produce no logs.\n\n- unimpl: Object functionality is unimplemented; software usage should be warned. Reads and writes use default implementations. Logging: the first read from a register emits an \"unimplemented\" log at level 1, subsequent reads at level 3; reads from fields do not log. The first write to a register emits an \"unimplemented\" log at level 1, subsequent writes at level 3. The first write to a field (if the value changes) logs at level 1, subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- read_unimpl: Read functionality is unimplemented; writes use default behavior and can be overridden. Logging: first software read to a register logs \"unimplemented\" at level 1, subsequent register reads at level 3; field reads do not log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- write_unimpl: Write functionality is unimplemented; reads use default behavior and can be overridden. Logging: first software write to registers logs \"unimplemented\" at level 1, subsequent writes at level 3. First write to a field (if the value changes) logs at level 1, subsequent field writes at level 3. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.17 unimpl",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0251",
                      "summary": "This partial document defines behavior templates for register/field objects: \"ignore\" (reads return 0, writes ignored); \"reserved\" (object marked reserved, reads return stored value, writes update value, first differing write logs a spec-viol at level 2); and \"unimpl\" (functionality unimplemented, default read/write behavior, software use warned). It specifies logging rules for unimplemented cases: first access logs at level 1 and subsequent accesses at level 3, with field-specific exceptions (reads from fields typically do not log; first field writes log only if value changes). It also documents access-specific templates \"read_unimpl\" and \"write_unimpl\" (only read or write is unimplemented, other access uses default and can be overridden) and lists related templates for each case."
                    },
                    {
                      "title": "5.2.18 read_unimpl",
                      "start_index": 100,
                      "end_index": 100,
                      "node_id": "0252",
                      "summary": "Summary of main points:\n\n- ignore: Object functionality is unimportant; reads always return 0 and writes are ignored.\n\n- reserved: Object is marked reserved; writes update the stored value and reads return that value. First software write (when the field value changes) triggers a spec-viol log at level 2; subsequent writes do not log.\n\n- unimpl: Object functionality is unimplemented and should warn on use; reads and writes use default implementations. Logging: first register read/write produces an \"unimplemented\" log at level 1, remaining accesses log at level 3; reads from fields do not log, and first field write (if value changes) logs at level 1, subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- read_unimpl: Read functionality is unimplemented (writes use default behavior or can be overridden). Logging: first register read logs \"unimplemented\" at level 1, subsequent reads at level 3; field reads do not log. Related templates: unimpl, write_unimpl, silent_unimpl, design_limitation.\n\n- write_unimpl: Write functionality is unimplemented (reads use default behavior or can be overridden). Logging: first register write logs \"unimplemented\" at level 1, subsequent writes at level 3; first field write (if value changes) logs at level 1, subsequent field writes at level 3. Related templates: unimpl, read_unimpl, silent_unimpl, design_limitation."
                    },
                    {
                      "title": "5.2.19 write_unimpl",
                      "start_index": 100,
                      "end_index": 125,
                      "node_id": "0253",
                      "summary": "- Defines a set of object templates that control register/field behavior and logging for various implementation statuses:\n  - ignore: reads return 0, writes ignored.\n  - reserved: object reserved; reads return current value, writes update it; first software write logs a spec-viol at level 2.\n  - unimpl / read_unimpl / write_unimpl / silent_unimpl: unimplemented behaviors with detailed logging policies (first vs subsequent accesses, different log levels for register vs field accesses); related template links listed.\n  - undocumented: poorly documented objects; first read/write generate spec_violation logs (level 1), subsequent at level 2.\n  - unmapped: register excluded from bank address space.\n  - sticky / no_reset: preserve value across soft/hard resets.\n  - design_limitation: intentionally out-of-scope/unimplemented behavior (distinguished from unimpl); related templates noted.\n\n- Bank-related templates:\n  - function_mapped_bank: marks a bank with a function number for mapping.\n  - function_io_memory: implements io_memory by routing transactions to a bank with a matching function number (deprecated pattern; logs errors and reports misses if no match).\n  - miss_pattern_bank: handles unmapped accesses by ignoring writes and returning a configurable byte value for each missed byte.\n\n- Connect-related template:\n  - map_target: provides a default connect implementation to send memory transactions to mapped objects, exposes session variable map_target and convenience methods:\n    - read, read_bytes, write, write_bytes (little-endian, size constraints), and issue (wrapper around SIM_issue_transaction); methods throw on failure and can be overridden.\n\n- Signal-related templates:\n  - signal_port: implements a saved boolean signal.high with spec-violation logging if raised/lowered redundantly; methods signal_raise/signal_lower overridable.\n  - signal_connect: connect implementing signal interface with saved state; handles connect changes by invoking raise/lower as needed; provides set_level(high) to set signal state.\n\n- Compiler messages and diagnostics (appendix A):\n  - Extensive listing of DMLC warning messages with tags (e.g., WLOGMIXUP, WIMMAFTER) and explanations of common pitfalls and unsafe constructs.\n  - Extensive listing of error messages with tags (e.g., EATTRCOLL, EREGOL, ENOFILE), each explaining specific language/schema/semantic errors the compiler can emit.\n\n- Provisional language features (appendix B):\n  - Explanation of provisional feature types (stable vs unstable) and how to enable them per-file.\n  - Two examples documented:\n    - explicit_param_decls: stricter syntax to distinguish declaring a new parameter vs overriding an existing one, to catch misspellings and accidental overrides.\n    - simics_util_vect: provisional support for a vect type (wrapper around Simics C API VECT) with caveats and provided helper macros/functions."
                    },
                    {
                      "title": "5.2.20 silent_unimpl",
                      "start_index": 125,
                      "end_index": 100,
                      "node_id": "0254",
                      "summary": "The partial document text is empty or missing, so no content or main points can be identified."
                    },
                    {
                      "title": "5.2.21 undocumented",
                      "start_index": 100,
                      "end_index": 128,
                      "node_id": "0255",
                      "summary": "Summary of main points in the partial document:\n\n- Object-state templates: descriptions and logging behavior for templates that mark unused or unimplemented functionality, including:\n  - ignore, reserved (writes update value, reads return value, first-write spec-viol log), unimpl (warns on first use, default read/write behavior), read_unimpl, write_unimpl, silent_unimpl (reduced logging), undocumented (spec_violation logs), unmapped (register excluded from bank address space), sticky (value preserved across soft-reset), design_limitation (intentionally out-of-scope unimplemented), no_reset (no change on hard/soft reset).\n  - Related-template cross-references for unimpl variants and design_limitation.\n\n- Bank-related templates:\n  - function_mapped_bank: marks banks mapped by function number (parameter: function).\n  - function_io_memory: implements io_memory via function mapping; looks up banks by function number, logs error and reports miss if none found (parameter: function). Notes deprecation and PCI legacy usage.\n  - miss_pattern_bank: handles unmapped accesses by ignoring writes and returning a specified byte value for missed reads (parameter: miss_pattern).\n\n- Connect-related template:\n  - map_target: helper for connect objects to send memory transactions to mapped objects; provides session variable map_target and convenience methods read, read_bytes, write, write_bytes, issue (uses SIM_issue_transaction). Validates SIM_new_map_target.\n\n- Signal-related templates:\n  - signal_port: signal interface with saved boolean high, logs spec-viol on redundant raises/lowers; signal_raise/signal_lower override points.\n  - signal_connect: connect implementing signal interface with saved state; handles connect changes and finalization by calling signal_lower/raise as needed; provides set_level(high) method. Related to signal_port.\n\n- Compiler messages (Appendix A excerpts):\n  - A.1 lists many warning messages (tags like WNEGCONSTCOMP, WIMMAFTER, WLOGMIXUP, WNOVER, etc.), with explanations and usage cautions (e.g., unsafe after/send usage, deprecated features, missing docs, redundant log-level specs).\n  - A.2 lists numerous error messages (tags like EATTRCOLL, EAMBDEFAULT, EIMPORT, EINDEPENDENTVIOL, EREGNSZ, ENOSTRUCT, etc.), each describing a specific compile-time error condition and typical causes/remedies. The appendix enumerates syntax, semantic, type, template, and API/version-related errors.\n\n- Provisional language features (Appendix B excerpt):\n  - Explanation of provisional features (stable vs unstable), how they are enabled per-file, and purpose (experimental or transitional language extensions).\n  - Examples of stable provisional features shown: explicit_param_decls (makes parameter declaration vs override explicit, new forms and rules) and simics_util_vect (adds vect type wrapper around Simics VECT, macros exposed, caveats about typedef and typeof).\n\n- Managing deprecated language features (Appendix C excerpt):\n  - Deprecation mechanisms: Simics API versioning, compiler flags (--api-version, --no-compat=tag) and global compatibility booleans.\n  - Migration guidance: stepwise module updates across Simics API versions.\n  - Examples of deprecated compatibility features retained for older API versions (e.g., dml12_goto, dml12_inline, dml12_int) and notes on their semantics/effects."
                    },
                    {
                      "title": "5.2.22 unmapped",
                      "start_index": 128,
                      "end_index": 130,
                      "node_id": "0256",
                      "summary": "This partial document describes deprecation control for DML features and enumerates legacy compatibility options that can be disabled to enforce newer Simics API semantics. Key points:\n\n- Rationale: avoiding legacy features that have newer replacements keeps code cleaner, more consistent, and can reduce model bloat and performance issues.\n- How to control deprecation: DMLC supports --api-version (SIMICS_API_VERSION / SIMICS_API / MODULE_SIMICS_API in builds) and --no-compat=tag to disable specific compatibility features; each tag also creates a global boolean parameter named _compat_tag that scripts can check.\n- Deprecated-feature lists are split by the last API that supported them:\n  - Features available up to and including --simics-api=6 (removed in API 7): examples and effects include\n    - dml12_goto: preserves the deprecated goto statement (suggested refactor to throw/catch).\n    - dml12_inline: inlines constant arguments in DML 1.2 methods with some semantic surprises.\n    - dml12_int: preserves old integer/C-like semantics (representation of odd-sized integers, undefined-C behaviors, comparison differences, need to change assert 0 / while (1) patterns, etc.); applies only to DML 1.2 files.\n    - dml12_misc: preserves numerous small DML1.2 quirks (sizeof(typename) behavior, typeof on non-lvalues, select over vect, string literals to non-const char*, c_name oddities, loggroup naming, extern without type, anonymous banks, unused-template instantiation quirks, shared top-level symbol/name collisions, etc.).\n    - io_memory: compatibility switch for io_memory vs transaction interfaces and the use_io_memory default.\n    - shared_logs_on_device: preserves a long-standing buggy logging behavior in shared methods (logs on device).\n    - suppress_WLOGMIXUP: suppresses the WLOGMIXUP warning by default below API 7 and describes how --no-compat and --warn differ in enabling/reporting that warning.\n  - Features available up to and including --simics-api=7 (removed in API 8): examples include\n    - broken_conditional_is: preserves a bug that silenced template-instantiation errors inside #if blocks.\n    - broken_unused_types: preserves a bug that suppressed errors for unused extern-declared types.\n\nThe excerpt documents both the mechanism for opting out of legacy behaviors and detailed descriptions of individual compatibility tags and their consequences for code migration."
                    },
                    {
                      "title": "5.2.23 sticky",
                      "start_index": 130,
                      "end_index": 100,
                      "node_id": "0257",
                      "summary": "The provided partial document contains no text, so no main points or topics can be determined."
                    },
                    {
                      "title": "5.2.24 design_limitation",
                      "start_index": 100,
                      "end_index": 132,
                      "node_id": "0258",
                      "summary": "Summary of the partial document:\n\n- Templates for object status and logging: Descriptions of templates that mark objects as ignore, reserved, unimplemented (unimpl) and variants (read_unimpl, write_unimpl, silent_unimpl), undocumented, unmapped, sticky, design_limitation, and no_reset. For each, the behavior on reads/writes and the logging policy (first-access vs subsequent, log levels, differences for registers vs fields) are specified.\n\n- Bank-related templates: Definitions for function_mapped_bank, function_io_memory (mapping io_memory transactions to banks by function number, with deprecation note), and miss_pattern_bank (handling unmapped accesses by returning a configurable byte pattern and ignoring writes).\n\n- Connect and map target support: The map_target template for connect objects that provides convenient read/write/issue methods to send memory transactions to mapped objects, including method signatures and error behavior.\n\n- Signal support templates: signal_port and signal_connect templates implementing saved signal state, logging on invalid transitions, and semantics for changing connections (set_level behavior and hooks for override).\n\n- Messages (warnings): A large collection of DMLC warning messages with explanations and examples (e.g., WLOGMIXUP, WIMMAFTER, WNEGCONSTCOMP, WASTRUNC, WEXPERIMENTAL), including guidance on when they arise and how to silence or fix them.\n\n- Messages (errors): Extensive alphabetical listing of compiler error messages (EN*, E*), each describing the cause, context, and typical fixes; covers syntax errors, type and layout problems, template/template-quali\ufb01ed call issues, parameter and array errors, and many other DML-specific diagnostics.\n\n- Provisional and deprecated language features: Explanation of provisional features (stable vs unstable), how to enable them per-file, and two concrete provisional features (explicit_param_decls and simics_util_vect) with usage notes and caveats.\n\n- Managing deprecation and compatibility: Guidance on deprecation mechanisms tied to Simics API versions, compiler flags (--api-version, --no-compat), and detailed lists of legacy compatibility features retained for API <=6 and <=7 (e.g., dml12_goto, dml12_int, io_memory, legacy_attributes, lenient_typechecking), their effects, and migration recommendations."
                    },
                    {
                      "title": "5.2.25 no_reset",
                      "start_index": 132,
                      "end_index": 101,
                      "node_id": "0259",
                      "summary": "No content was provided in the partial document, so no main points or topics can be identified."
                    }
                  ],
                  "node_id": "0234",
                  "summary": "Describes reset- and access-related templates for registers and fields. 5.1.1 explains a generic reset-event callback implemented on objects (automatically by registers and fields). Top-level reset templates (porest, hreset, sreset) map to standard power_on_reset, hard_reset and soft_reset behaviors. Section 5.2 covers templates that can be applied to either registers or fields and notes that most affect read or write operations; when applied to a register they override field read implementations (reads return the register value via get and ignore field read overrides) while writes still propagate to fields. Specific templates: soft_reset_val (sets the reset value used on soft reset via the soft_reset_val parameter, overriding init_val; related to soft_reset); ignore_write (causes writes to be ignored, useful for making individual fields behave read-only inside writable registers); read_zero (reads always return 0, writes are unaffected; related to read_constant); read_only (software cannot modify the object value, hardware can; software writes produce log messages\u2014first write is a spec_violation at log level 1, subsequent writes at level 2, and fields only log if the written value differs from the old value; for mixed registers with both read-only and writable fields, ignore_write may be preferable since software often disregards writes to the full register)."
                },
                {
                  "title": "5.3 Bank related templates",
                  "start_index": 101,
                  "end_index": 101,
                  "nodes": [
                    {
                      "title": "5.3.1 function_mapped_bank",
                      "start_index": 101,
                      "end_index": 102,
                      "node_id": "0261",
                      "summary": "This partial document describes several object/templates used in a modeling framework, focusing on their purpose, runtime behavior (especially logging), and relationships:\n\n- silent_unimpl: Marks functionality as unimplemented but suppresses verbose logs. Default read/write semantics are used. First register read/write logs an \u201cunimplemented\u201d message at level 2, subsequent accesses at level 3; field reads produce no log, field writes log only if value changes (level 2 first, then level 3). Related to unimpl and design_limitation.\n\n- undocumented: Indicates functionality is undocumented or poorly documented. Uses default reads/writes. The first software read and write emit a spec_violation at log level 1; subsequent accesses at level 2.\n\n- unmapped: Indicates a register is excluded from its bank\u2019s address space.\n\n- sticky: (written as \u201cstick y\u201d in the partial text) Indicates object values are not reset on soft-reset; current value is preserved.\n\n- design_limitation: Used when functionality is intentionally out of scope for the model (left unimplemented by design). Uses default reads/writes. Distinguished from unimplemented (which implies a future implementation may be intended). Related to unimpl and silent_unimpl.\n\n- no_reset: Specifies that a register\u2019s or field\u2019s value does not change on hard or soft reset.\n\n- Bank-related templates:\n  - function_mapped_bank: Applied to bank objects; used with function_io_memory to mark banks mapped to a specific function number. Parameter: function (integer).\n  - function_io_memory: For implement objects named io_memory; implements io_memory by mapping incoming memory transactions to a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number. Logs an error and reports a miss if no matching bank exists. Notes that function-number mapping is deprecated (legacy PCI use) and that PCI function numbers are unrelated to these bank function numbers. Parameter: function (integer). Related to function_mapped_bank.\n  - miss_pattern_bank: For bank objects; handles unmapped accesses by ignoring writes and returning a specified byte value for each unmapped byte in reads. Parameter: miss_pattern. Custom behavior can be implemented by overriding unmapped_get (which also customizes unmapped_read).\n\n- Connect-related template:\n  - map_target: For connect objects to facilitate sending memory transactions to mappable objects. Provides a default set implementation that assigns a session variable map_target (map_target_t *), and a validate implementation that checks SIM_new_map_target succeeds. Begins to define methods such as read(uint64 addr, uint64 size) -> (uint64) throws (method listing is truncated in the partial text)."
                    },
                    {
                      "title": "5.3.2 function_io_memory",
                      "start_index": 102,
                      "end_index": 102,
                      "node_id": "0262",
                      "summary": "- Describes templates and behaviors for mapping memory banks by a function number:\n  - function_mapped_bank: valid only in bank objects; banks are recognized as function-mapped when instantiated from the function_io_memory template; parameter: function (integer); related template: function_io_memory.\n  - function_io_memory: valid only in implement objects named io_memory; implements io_memory by routing incoming memory transactions to a bank in the same (sub)device that instantiates function_mapped_bank and has a matching function number; logs an error and reports a miss if no matching bank exists; notes that mapping by function number is deprecated (still used for PCI legacy), and PCI standard function numbers are unrelated to bank function numbers; parameter: function (integer); related template: function_mapped_bank.\n\n- miss_pattern_bank:\n  - Valid only in bank objects; handles unmapped accesses by ignoring writes and returning a specified value for each unmapped byte on reads; suggests overriding unmapped_get to customize behavior; parameter: miss_pattern (value returned for each missed byte).\n\n- Connect-related template map_target:\n  - A connect object can instantiate map_target to facilitate sending memory transactions to objects mappable into Simics memory maps; provides default set implementation that assigns a session variable map_target of type map_target_t * for issuing transactions, and a default validate implementation that checks SIM_new_map_target returns a valid pointer; defines methods including read(uint64 addr, uint64 size) -> (uint64) throws."
                    },
                    {
                      "title": "5.3.3 miss_pattern_bank",
                      "start_index": 102,
                      "end_index": 102,
                      "node_id": "0263",
                      "summary": "- function_mapped_bank: a bank-only template that maps a bank to a specific function number (integer parameter \"function\"); listed as related to function_io_memory.\n- function_io_memory: an implement-only template for objects named io_memory that routes incoming memory transactions by finding a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number. If no match is found, an error is logged and a miss is reported. Notes that function-number mapping is deprecated (historically used by PCI) and that PCI function numbers are unrelated to these bank function numbers. Parameter: \"function\". Related to function_mapped_bank.\n- miss_pattern_bank: a bank-only template that handles unmapped accesses by ignoring writes and returning a specified value for each unmapped byte on reads (parameter \"miss_pattern\"); customization can be done by overriding unmapped_get to affect unmapped_read.\n- map_target (connect-related): a template for connect objects to send memory transactions to mappable objects, providing default implementations of set (assigns session variable map_target of type map_target_t *) and validate (checks SIM_new_map_target returns a valid pointer). It also defines methods such as read(uint64 addr, uint64 size) -> (uint64) throws."
                    }
                  ],
                  "node_id": "0260",
                  "summary": "This excerpt lists register/field \u201ctemplates\u201d and their meanings: \n- silent_unimpl: object left unimplemented but uses default reads/writes and suppresses verbose logs (first software read/write logs at level 2, subsequent at level 3; field reads silent; field writes log at level 2 only on first change). \n- undocumented: functionality lacks documentation; uses default reads/writes and emits spec_violation logs (first access at level 1, subsequent at level 2). \n- unmapped: register excluded from the bank address space. \n- sticky: value is retained across soft-resets. \n- design_limitation: intentionally unimplemented by design (uses default reads/writes); contrasted with unimpl and related to silent_unimpl. \n- no_reset: value not changed by hard or soft reset. \nThe fragment then begins the bank-related templates section (5.3) and the entry for function_mapped_bank."
                },
                {
                  "title": "5.4 Connect related templates",
                  "start_index": 102,
                  "end_index": 102,
                  "nodes": [
                    {
                      "title": "5.4.1 map_target",
                      "start_index": 102,
                      "end_index": 103,
                      "node_id": "0265",
                      "summary": "Summary of main points in the partial document:\n\n- function_mapped_bank: template valid only for bank objects. Banks instantiated from function_io_memory are mapped to a specific function number. Parameter: function (integer). Related to function_io_memory.\n\n- function_io_memory: template valid only for implement objects named io_memory. Implements memory handling by mapping incoming transactions to banks in the same (sub)device that instantiate function_mapped_bank with a matching function number; logs an error and reports a miss if no match. Notes that mapping by function number is deprecated (legacy PCI use) and that PCI function numbers are unrelated to bank function numbers. Parameter: function (integer).\n\n- miss_pattern_bank: template for bank objects that defines behavior for unmapped accesses: ignores writes and returns a specified value for each unmapped byte. Parameter: miss_pattern. Suggests overriding unmapped_get to customize behavior.\n\n- map_target (connect-related): connect template to send memory transactions to mappable objects. Sets a session variable map_target and validates via SIM_new_map_target. Provides convenience methods: read, read_bytes, write, write_bytes (little-endian, size limits), and issue (wrapper for SIM_issue_transaction) which can be overridden to modify transactions.\n\n- signal_port (signal-related): implements a signal interface with saved boolean state high; logs spec-violation messages if raised/lowered when already in that state. signal_raise and signal_lower may be overridden for side effects.\n\n- signal_connect: connect template implementing a signal interface with saved state signal.high. Handles transitions when the connect target changes or when created with signal.high true (calls signal_lower on old and signal_raise on new during changes and finalize). set_level(uint1 high) method sets the signal level and updates saved state. Related to signal_port.\n\n- Cross-references: templates reference one another (e.g., function_mapped_bank \u2194 function_io_memory, signal_connect \u2194 signal_port)."
                    }
                  ],
                  "node_id": "0264",
                  "summary": "- Describes templates for memory-mapped bank and IO handling in Simics, including where each template is valid and their parameters.\n- function_mapped_bank: valid only in bank objects; parameter: integer \"function\" specifying the function number; related template: function_io_memory.\n- function_io_memory: valid only in implement objects named io_memory; implements io_memory by mapping incoming memory transactions to a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number; logs an error and reports a miss if no matching bank exists; notes that mapping by function number is deprecated (used for PCI legacy) and PCI function numbers are unrelated to these bank function numbers; parameter: integer \"function\"; related template: function_mapped_bank.\n- miss_pattern_bank: valid in bank objects; handles unmapped accesses by ignoring writes and returning a specified byte value for each unmapped read byte; overriding unmapped_get customizes unmapped_read; parameter: miss_pattern (value used for each missed byte).\n- map_target (connect-related): a connect object can instantiate map_target to simplify issuing memory transactions to objects mappable into Simics memory maps; provides a default set implementation that assigns a session variable map_target of type map_target_t * and a validate implementation that checks SIM_new_map_target returns a valid pointer; defines methods such as read(uint64 addr, uint64 size) -> (uint64) throws."
                },
                {
                  "title": "5.5 Signal related templates",
                  "start_index": 103,
                  "end_index": 103,
                  "nodes": [
                    {
                      "title": "5.5.1 signal_port",
                      "start_index": 103,
                      "end_index": 103,
                      "node_id": "0267",
                      "summary": "This partial document describes low-level read/write and signaling APIs and templates for a connected object. Main points:\n- Read/write primitives: read, read_bytes, write, write_bytes with signatures and behavior; reads/writes throw exceptions on failure; size must be \u22648 for scalar read/write; byte order is little-endian.\n- issue(transaction_t *t, uint64 addr): a shorthand for SIM_issue_transaction used by the read/write methods; can be overridden to add atoms or customize transactions.\n- Signal templates: signal_port implements a saved boolean state (signal.high), logs spec-violation messages if raising/lowering when already in that state, and allows overriding signal_raise/signal_lower for side effects.\n- signal_connect implements a connect with saved signal state (signal.high). If the connection changes while signal.high is true and the device is configured, signal_lower is called on the old object and signal_raise on the new; if the device is created with signal.high true, signal_raise is invoked on the connected object during finalize. Behavior can be altered by overriding set and/or post_init.\n- Provided helper: set_level(uint1 high) to change the level by calling signal_raise or signal_lower and updating signal.high."
                    },
                    {
                      "title": "5.5.2 signal_connect",
                      "start_index": 103,
                      "end_index": 103,
                      "node_id": "0268",
                      "summary": "- Definitions of read/write primitives for a connected object: read (<=8 bytes, little-endian), read_bytes, write (<=8 bytes, little-endian), and write_bytes; all throw on failure.\n- issue(transaction_t *t, uint64 addr) is a shorthand for SIM_issue_transaction used by the read/write methods and can be overridden to modify transaction composition.\n- signal_port template: implements a signal interface that saves state in a boolean signal.high, logs spec violations if raising/lowering when already in that state, and allows overriding signal_raise and signal_lower for additional side effects.\n- signal_connect template: implements a connect with saved signal state (signal.high); when the connection changes while signal.high is true and the device is configured, it calls signal_lower on the old object and signal_raise on the new one; if created with signal.high true, signal_raise is called in finalize. Behavior can be altered by overriding set or post_init.\n- signal_connect provides set_level(uint1 high) to update the signal level and signal.high.\n- Notes the relation between templates (signal_connect references signal_port)."
                    }
                  ],
                  "node_id": "0266",
                  "summary": "Summary of main points in the partial document:\n\n- Memory access API:\n  - read(addr, size) and read_bytes(addr, size, bytes): read up to 8 bytes from the connected object into a return value or provided buffer; little-endian byte order; throw an exception on failure.\n  - write(addr, size, value) and write_bytes(addr, size, bytes): write up to 8 bytes to the connected object from a value or buffer; little-endian byte order; throw an exception on failure.\n  - Size constraints: size must be 8 or less for the scalar read/write variants.\n  - issue(transaction_t *t, uint64 addr) -> (exception_type_t): a convenience wrapper around SIM_issue_transaction used by the read/write methods; can be overridden to modify transactions (e.g., add atoms) while preserving the simpler read/write interfaces.\n\n- Signal-related templates (Section 5.5):\n  - signal_port: implements a signal interface with saved state (boolean high). It logs a spec-violation if signal_raise/signal_lower is called when the signal is already in that state. signal_raise and signal_lower can be overridden to implement side effects.\n  - signal_connect: implements a connect holding saved state in signal.high. If the connection changes while signal.high is true and the device is configured, the template calls signal_lower on the old object and signal_raise on the new one. If the device is created with signal.high true, signal_raise is called on the connected object during finalization. Behavior can be changed by overriding set or post_init. Provides set_level(uint1 high) to change the signal level and update signal.high.\n  - Related template: signal_port."
                }
              ],
              "node_id": "0230",
              "summary": "Summary of partial document:\n\n- Introduces Chapter 5 describing standard templates included in the Device Modeling Language (DML) library, usable for both registers and fields after importing utility.dml.\n- Notes that many templates provide the same functionality but differ in name or log messages to communicate intended usage (example: undocumented vs reserved).\n- Clarifies terminology: \"object\" used generically for registers and fields.\n- Distinguishes software vs hardware accesses:\n  - Software reads/writes: via io_memory interface, using DML built-in read/write methods.\n  - Hardware reads/writes: via Simics configuration attributes, using DML built-in set/get methods.\n  - Device code may still modify registers even when hardware modification is prohibited.\n- Covers reset-related templates (Section 5.1):\n  - Describes three reset types: power-on reset, hard reset, and soft reset, and typical semantics (registers restored to predefined values).\n  - Explains DML provides poreset, hreset, sreset templates, which create POWER, HRESET, SRESET ports implementing a signal interface that triggers the corresponding reset on a rising edge by calling appropriate reset methods (e.g., power_on_reset, hard_reset...)."
            },
            {
              "title": "A Messages",
              "start_index": 104,
              "end_index": 104,
              "nodes": [
                {
                  "title": "A.1 Warning Messages",
                  "start_index": 104,
                  "end_index": 107,
                  "node_id": "0270",
                  "summary": "Appendix A documents the compiler messages for DML: an alphabetical, tagged listing of warnings (A.1) and errors (A.2) produced by dmlc, with explanations, causes and suggested mitigations. A.1 enumerates many specific warnings (e.g., SystemC warnings, redundant log levels, unsafe immediate after or hook send using pointers to stack data, unsigned/signed comparison quirks, truncation on assignment, experimental/deprecated features, duplicate checkpoint names, missing version or documentation, log-spec mixups, negative register offsets, confidential-name leaks, size/type operators, implicit time-type conversions, unused/legacy DML 1.2 methods, suspect pointer casts, etc.), notes which are disabled by default, and gives remediation tips (casts, use of send_now, conditional compilation, use sizeoftype, explicit time casts). A.2 notes that errors are likewise listed alphabetically with tags (example: EERRSTMT for a forced compilation error via an error; statement)."
                },
                {
                  "title": "A.2 Error Messages",
                  "start_index": 107,
                  "end_index": 123,
                  "node_id": "0271",
                  "summary": "Partial document: an alphabetical catalogue of DML (Simics) compiler warnings and error messages, their tags, meanings, constraints, typical causes and suggested fixes. Main points covered:\n- Several warning entries (e.g., implicit time-type conversions for after calls, unused parameters/objects, suspicious pointer-to-pointer casts, unused DML 1.2 method implementations) with advice on silencing or fixing them (explicit casts, #if blocks, void* intermediate casts).\n- A large, detailed A.2 Error Messages section listing error codes and explanations (with examples) for many categories of problems encountered when writing/compiling DML:\n  - Template and inheritance issues (ambiguous default implementations, template-qualified method calls, invalid upcasts, cyclic template inheritance, abstract method requirements).\n  - Method/implementation constraints (shared vs non-shared, inline/export/throwing restrictions, return/value/output parameter rules, default/override rules).\n  - Type, expression and operator errors (wrong types, invalid casts, illegal comparisons, non-boolean conditions, untyped/unknown types, serialization limits).\n  - Array, register and bitfield restrictions (bounds, sizes, variable-length arrays, overlapping registers, bitslice rules, endian/bit-order constraints).\n  - Attribute and interface errors (name collisions, missing get/set, checkpointable requirements, invalid attribute parameters).\n  - Layout/struct/function constraints (illegal struct members, recursive types, function-array/const-function errors).\n  - Compile-time/import issues (file not found, cyclic imports, DML/API version mismatches, provisional features, too many log groups).\n  - Control-flow and static analysis errors (missing returns, unreachable/undefined values, uninitialized parameters, uncaught exceptions).\n  - Logging/format and after/hook usage rules (format string errors, log level limits, hook message component and send_now serialization requirements, after callback parameter restrictions).\n- Numerous concrete examples of error contexts and practical remediation hints (e.g., use explicit casts, add try/catch, declare missing methods/parameters, adjust attribute declarations, use correct syntax or #if guards)."
                }
              ],
              "node_id": "0269",
              "summary": "- Appendix listing dmlc warning and error messages (Device Modeling Language 1.4 reference), ordered alphabetically with tags (e.g., [WNDOC]).\n- Notes existence of SystemC-specific warnings ([WSYSTEMC]) and simple source-code warnings like use of the literal statement \"warning;\" ([WWRNSTMT]).\n- Explains redundant log-level syntax where \"X then Y\" has no effect if levels are identical ([WREDUNDANTLEVEL]).\n- Highlights severe safety warnings about use of stack-allocated data with delayed callbacks and hook sends:\n  - Immediate 'after' callbacks that capture pointers to stack variables are unsafe because the data is invalid when the callback runs, with advice to avoid this ([WIMMAFTER]).\n  - Sending messages via a hook with message components that are pointers to stack data is similarly unsafe; recommends using send_now or wrapping the send in a method that owns the locals and delaying that method instead ([WHOOKSEND]).\n- Describes a semantics caveat when comparing negative constants to unsigned integers: DML\u2019s special comparison method makes such comparisons have a constant (usually unintended) result ([WNEGCONSTCOMP])."
            },
            {
              "title": "B Provisional language features",
              "start_index": 123,
              "end_index": 124,
              "nodes": [
                {
                  "title": "B.1 List of stable provisional features",
                  "start_index": 124,
                  "end_index": 124,
                  "nodes": [
                    {
                      "title": "explicit_param_decls",
                      "start_index": 124,
                      "end_index": 124,
                      "node_id": "0274",
                      "summary": "The partial document describes DML\u2019s \u201cprovisional language features\u201d mechanism and a specific stable provisional feature. Key points:\n- How to enable provisional features on a per-file basis (by placing a provisional feature list after the dml 1.4; statement).\n- The two kinds of provisional features: stable (designs expected to remain largely stable; may be versioned if incompatible changes occur; usable in production) and unstable (likely to change; intended for evaluation and not for production without coordination with the DML team).\n- The start of a list of stable provisional features, with a detailed entry for explicit_param_decls: this feature extends parameter-definition syntax to distinguish declaring a new parameter from overriding an existing one (helping catch misspelled overrides), and introduces new shorthand forms for typed and untyped parameter declarations (examples showing equivalences such as param NAME: TYPE = value and param NAME := value)."
                    },
                    {
                      "title": "simics_util_vect",
                      "start_index": 124,
                      "end_index": 126,
                      "node_id": "0275",
                      "summary": "This partial document describes DML\u2019s provisional feature mechanism and details two stable provisional features.\n\nMain points:\n- Provisional features: compiler extensions enabled per-file by adding provisional feature_name, ...; immediately after the dml 1.4; line. Used when a feature isn\u2019t ready for full language inclusion (e.g., design not fully evaluated or backwards-incompatible).\n- Two flavours:\n  - Stable provisional features: design is proven and expected to remain fairly stable; incompatible changes would be handled by creating a new provisional version and keeping both in parallel. Suitable for production in many cases.\n  - Unstable provisional features: likely to undergo significant incompatible changes; intended for evaluation by a small team and not recommended for production.\n- Stable provisional features listed (excerpt):\n  - explicit_param_decls: extends parameter syntax to distinguish declaring a new parameter vs overriding an existing one, providing forms that explicitly indicate declaration intent (e.g., param NAME: TYPE = value; as shorthand for separate declaration and assignment). Compiler errors are produced for mismatched intent; a paired param NAME; can mark an ambiguous case. Enabling affects only that file.\n  - simics_util_vect: adds a vect type wrapping the Simics C API VECT macro (syntax BASETYPE vect). Notes and caveats: vect types typically must be typedefed to avoid incompatible duplicate struct definitions; DML imports various VECT-related C macros via internal.dml; DML indexing is mapped to VGET/VSET; example usage shown. Enabling is per-file, and using vect without this feature is an error unless an experimental compatibility feature is enabled."
                    }
                  ],
                  "node_id": "0273",
                  "summary": "- Explains DML\u2019s mechanism for provisional language features: how they are enabled per file using a provisional feature list placed after the dml 1.4; statement.\n- Distinguishes two flavours of provisional features:\n  - Stable provisional features: design is proven, expected to remain largely stable; incompatible changes would create a new provisional version and run versions in parallel; can be used in production.\n  - Unstable provisional features: expected to undergo significant changes, intended for experimental evaluation and not recommended for production without coordination with the DML team.\n- Begins a catalog of stable provisional features, introducing explicit_param_decls:\n  - Purpose: extend parameter-definition syntax to distinguish declaring a new parameter from overriding an existing one, enabling the compiler to catch misspelled overrides as errors.\n  - Describes new shorthand forms for typed parameters (e.g., param NAME: TYPE = value; and param NAME: TYPE default value; as shorthands for separate declaration and initialization forms).\n  - Starts to mention shorthand for untyped parameters (e.g., param NAME := value;) before the excerpt ends."
                }
              ],
              "node_id": "0272",
              "summary": "- Notes an error (EARGT) indicating an argument\u2019s data type differs from the function/method prototype or definition (wrong type in parameter).\n- Describes \u201cProvisional language features\u201d in DML: how provisional features can be enabled per file (via provisional feature_name, ...; after dml 1.4;) and why features are provisional (e.g., design not finalized or backward incompatible).\n- Distinguishes two flavours of provisional features: stable (relatively mature, may be kept in parallel if incompatible changes occur) and unstable (subject to significant change, not recommended for production).\n- Lists a stable provisional feature: explicit_param_decls \u2014 extends parameter syntax to distinguish declaring a new parameter vs overriding an existing one (helps catch misspelled overrides), and gives shorthand forms/examples for typed and untyped parameter declarations."
            },
            {
              "title": "C Managing deprecated language features",
              "start_index": 127,
              "end_index": 127,
              "nodes": [
                {
                  "title": "C.1 Deprecation mechanisms",
                  "start_index": 127,
                  "end_index": 128,
                  "node_id": "0277",
                  "summary": "Summary of the partial document:\n- Purpose: describes how DML handles deprecated language features and provides mechanisms to help large code bases migrate smoothly when the language or Simics APIs change.\n- Types of deprecations covered: removed/renamed library symbols, semantic changes to language constructs/APIs, and changes to how compiled models appear in Simics (which can affect model end-users as well as model authors).\n- Migration workflow tied to Simics API versions: associate deprecated features with Simics API versions; recommended steps\u2014update modules to API N while on Simics N, upgrade Simics to N+1, then update modules to API N+1 incrementally (Simics N+1 maintains compatibility with API N).\n- Additional controls: compiler flags to selectively disable deprecated features to enable gradual migration or to prevent use of legacy features even when still supported; rationale includes cleaner code, avoidance of redundancy, and performance considerations.\n- Command-line controls: dmlc --api-version to select API version; --no-compat=tag to disable specific deprecated features; corresponding global boolean parameter names are formed as _compat_tag; when using Simics build system, API version is set via SIMICS_API_VERSION (make) or SIMICS_API/MODULE_SIMICS_API (CMake).\n- Example deprecated features (those removed when compiling with Simics API 7+; individually disableable under older APIs):\n  - dml12_goto: preserves deprecated goto statement; suggests refactoring to exceptions/catch.\n  - dml12_inline: inlines constant typed parameters as constants for DML 1.2 devices, with potential unintuitive semantics.\n  - dml12_int: affects integer arithmetic semantics\u2014older behavior maps many integer ops directly to C (including odd-sized uintNN types), causing subtle differences (examples: assert 0 -> assert false; while (1) -> while (true); int1 comparisons)."
                },
                {
                  "title": "C.2 Controlling deprecation on the DML command-line",
                  "start_index": 128,
                  "end_index": 128,
                  "node_id": "0278",
                  "summary": "Summary of main points in the partial document:\n\n- Rationale: Removing legacy features when newer replacements exist keeps the codebase cleaner, more consistent, and can reduce model bloat and performance costs.\n- Deprecation control: DMLC provides command-line controls for API/compatibility:\n  - --api-version to select the Simics API version (controlled in builds via SIMICS_API_VERSION in make or SIMICS_API / MODULE_SIMICS_API in CMake).\n  - --no-compat=tag to disable individual legacy features; each tag also creates a global boolean parameter named _compat_tag that programs can check.\n- Deprecated-features list (features available up to and including --simics-api=6): documents functionality removed when compiling with Simics API 7+ and which can be disabled with --no-compat=TAG.\n- Specific deprecated compatibility features described:\n  - dml12_goto: preserves the deprecated goto statement; recommends reworking goto-based control flow into throw/catch constructs but allows selective disabling.\n  - dml12_inline: affects inlining behavior for DML 1.2 devices where constant arguments in typed parameters may be inlined as constants\u2014can improve compilation time but has unintuitive semantics.\n  - dml12_int: changes many integer-arithmetic semantics\u2014when enabled, integer ops are translated directly to C (affecting odd-sized uintNN types), which can cause surprising behavior. Disabling it enforces modern DML semantics (e.g., assert 0 \u2192 assert false, while (1) \u2192 while (true)), and notes on representation differences (e.g., uint5 mapped to uint8 in old semantics; modern semantics use 64-bit arithmetic with truncation)."
                },
                {
                  "title": "C.3 List of deprecated features",
                  "start_index": 128,
                  "end_index": 129,
                  "nodes": [
                    {
                      "title": "C.3.1 Features available up to and including --simics-api=6",
                      "start_index": 129,
                      "end_index": 129,
                      "nodes": [
                        {
                          "title": "dml12_goto",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0281",
                          "summary": "Summary of main points in the partial document:\n\n- Suggestion to rewrite occurrences of int1 to use the uint1 type (grep pattern provided to find candidates).\n- Explanation of how certain undefined behaviours in C (e.g., negative shifts, division by zero, oversized shifts, signed-shift overflow) are handled differently in modern DML: modern DML defines them (typically as unconditional critical errors or truncation) whereas traditional DML inherited C\u2019s undefined behaviour.\n- Comparison operator semantics: traditional DML inherited C semantics for <, <=, ==, >=, >, while modern DML compares values as integers. This affects comparisons between signed and unsigned values (example: -1 vs 0xffffffffffffffff).\n- dml12_int feature scope: applies only to DML 1.2 files; importing a DML 1.2 file into a DML 1.4 file does not force legacy semantics for the importing file.\n- dml12_misc compatibility feature: preserves numerous DML 1.2 quirks that were cleaned up in 1.4. Examples include allowing sizeof(typename), typeof on non-lvalues, select over vect types, passing string literals to non-const char*, using '-' in c_name, overriding interface type via c_name in implement, loggroup identifiers accessible with the same name in generated C code, applying & to non-lvalues, extern statements without a type, anonymous banks, unused templates instantiating non-existing templates, and reusing the same symbol for top-level objects and top-level symbols.\n- io_memory vs transaction interfaces: the transaction interface (introduced in version 6) will replace io_memory; enabling the related feature sets top-level use_io_memory to true so bank objects implement io_memory by default instead of transaction.\n- shared_logs_on_device compatibility feature: changes log semantics in shared methods so logs always target the device object (rather than the nearest enclosing configuration), noting this was a longstanding bug that has affected existing scripts."
                        },
                        {
                          "title": "dml12_inline",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0282",
                          "summary": "- Suggests replacing uses of int1 with uint1 (recommend grepping for \u201c[\u02c6a-z_]int1[\u02c60-9]\u201d to find candidates).\n- Notes that some C undefined behaviours were inherited by traditional DML; modern DML defines them (e.g., unconditional critical error on negative shifts or division by zero; truncation on too-large shift operands or signed-shift overflow).\n- Explains comparison semantics: traditional DML follows C rules for <, <=, ==, >=, >, while modern DML compares values as integers (affecting comparisons between signed and unsigned values; e.g., -1 vs 0xffff...).\n- Clarifies that the dml12_int feature only affects DML 1.2 files; importing a DML 1.2 file into a DML 1.4 context still uses modern DML semantics for that file.\n- Describes dml12_misc, a compatibility feature that restores several DML 1.2 quirks, including: sizeof(typename); typeof on non-lvalues; select over vect types; passing string literals to non-const char*; using \u2018-\u2019 in c_name; overriding interface type via c_name in implement; loggroup identifiers visible in generated C; applying & to non-lvalues; extern without type; anonymous banks; unused templates potentially instantiating non-existing templates; and allowing the same symbol as both a top-level object and a top-level symbol.\n- Explains io_memory compatibility: the transaction interface (introduced in version 6) will replace io_memory; when the feature is enabled, use_io_memory defaults to true so bank objects implement io_memory instead of transaction by default.\n- Describes shared_logs_on_device: changes logging semantics inside shared methods so logs always target the device object (fixing a longstanding bug where shared-method logs used the nearest enclosing configuration)."
                        },
                        {
                          "title": "dml12_int",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0283",
                          "summary": "- Suggests replacing occurrences of the int1 type with uint1 (grep for [^a-z_]int1[^0-9] to find candidates).\n- Explains differences between traditional DML (inherits C undefined behavior) and modern DML (well-defined behavior): modern DML produces critical errors for negative shifts or division by zero, truncates overly large shift operands, and defines behavior for signed-shift overflow.\n- Describes change in comparison semantics: traditional DML follows C rules for <, <=, ==, >=, >; modern DML compares as integers (notably affecting signed vs unsigned comparisons such as -1 vs 0xffffffffffffffff).\n- Notes that the dml12_int feature only affects DML 1.2 files; imported DML 1.4 files still use modern semantics.\n- Documents the dml12_misc compatibility feature, which restores a set of legacy DML 1.2 quirks, including: sizeof(typename) usage, typeof on non-lvalues, select over vect types, passing string literals to non-const char* args, allowing '-' in c_name, using c_name to override interface type in implement, making loggroup identifiers accessible in generated C, applying & to non-lvalues, extern without a type, anonymous bank declarations, unused templates instantiating non-existing templates, and reusing a symbol name for both $-scoped top-level objects and non-$ top-level symbols.\n- Describes io_memory compatibility: when enabled, use_io_memory defaults true so bank objects implement io_memory (legacy) rather than the newer transaction interface introduced in version 6.\n- Describes shared_logs_on_device compatibility: changes logging inside shared methods so logs go to the device object (fixing a long-standing bug that previously logged to the nearest enclosing configuration)."
                        },
                        {
                          "title": "dml12_misc",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0284",
                          "summary": "- Suggests rewriting occurrences of \"int1\" to use the uint1 type (grep pattern provided to find candidates).\n- Notes differences between traditional DML (inherits C undefined behavior) and modern DML:\n  - Modern DML defines formerly undefined operations (e.g., negative shift or division by zero cause a critical error; overly large shift operands or signed-shift overflow truncate).\n  - Comparison operators in traditional DML follow C semantics; in modern DML values are compared as integers, which affects signed vs. unsigned comparisons (example: -1 vs. 0xffffffffffffffff).\n  - The dml12_int compatibility flag only affects DML 1.2 files; imported DML 1.4 files continue to use modern semantics.\n- Documents the dml12_misc compatibility feature, which preserves various DML 1.2 quirks (when enabled, permits behaviors such as sizeof(typename), typeof on non-lvalues, select over vect types, passing string literals to non-const char* parameters, special uses of c_name, loggroup name accessibility in generated C, applying & to non-lvalues, extern without type, anonymous banks, unused templates instantiating non-existent templates, and reusing the same symbol name in top-level $ and non-$ scopes).\n- Describes io_memory compatibility: when enabled, use_io_memory defaults to true so bank objects implement io_memory (note that the transaction interface introduced in version 6 is intended to replace io_memory).\n- Describes shared_logs_on_device compatibility: changes log behavior inside shared methods so logs always target the device object rather than the nearest enclosing configuration object (documented as a long-standing bug that affected existing scripts)."
                        },
                        {
                          "title": "io_memory",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0285",
                          "summary": "- Suggests rewriting occurrences of the int1 type to use uint1 instead (recommend grepping for [^a-z_]int1[^0-9] to find candidates).\n- Describes differences between traditional DML (inherits C undefined behaviour) and modern DML (well-defined behaviour): modern DML raises critical errors for negative shifts or division by zero, truncates oversized shift operands, and handles signed shift overflow predictably.\n- Explains comparison operator semantics: traditional DML follows C semantics; modern DML compares values as integers, which affects comparisons between signed and unsigned values (example: -1 vs 0xffffffffffffffff).\n- Notes that the dml12_int feature only affects DML 1.2 files; importing a DML 1.4 file from a DML 1.2 file still uses modern DML semantics for operations in that file.\n- Documents the dml12_misc compatibility feature that restores several DML 1.2 quirks (examples listed):\n  - sizeof(typename)\n  - typeof on non-lvalues\n  - select statements over vect types\n  - passing string literals to non-const char* parameters\n  - using '-' in c_name for interface objects\n  - using c_name to override interface type in implement objects\n  - loggroup identifiers accessible by the same name in generated C\n  - applying & to non-lvalues\n  - extern statements without a specified type\n  - anonymous banks (bank { ... })\n  - unused templates potentially instantiating non-existing templates\n  - allowing the same symbol for a top-level $-scoped object and a non-$ top-level symbol\n- Describes io_memory/transaction transition: enabling the related feature sets top-level use_io_memory to true so bank objects implement io_memory by default; transaction is the newer interface introduced in version 6 intended to replace io_memory.\n- Explains shared_logs_on_device compatibility change: log statements inside shared methods now always log on the device object (fixing a long-standing bug where logs used the nearest enclosing configuration object), noting this change addresses legacy script behavior."
                        },
                        {
                          "title": "shared_logs_on_device",
                          "start_index": 129,
                          "end_index": 129,
                          "node_id": "0286",
                          "summary": "- Suggests replacing occurrences of int1 with uint1 where appropriate (grep pattern provided) to prefer the unsigned 1-bit type.\n- Describes differences between traditional DML and modern DML for operations with undefined or implementation-defined C behavior: modern DML defines them (e.g., unconditional critical errors for negative shifts or division by zero; truncation on overly large shift operands or signed shift overflow).\n- Explains comparison semantics changes: traditional DML inherits C comparison semantics, while modern DML compares values as integers (affecting signed vs unsigned comparisons such as -1 vs 0xffffffffffffffff).\n- Notes that the dml12_int feature only affects DML 1.2 files; imported DML 1.2 files in a DML 1.4 context still use modern semantics for operations in that file.\n- Documents the dml12_misc compatibility feature, which restores many DML 1.2 quirks in DML 1.4, and lists the specific allowances it re-enables (sizeof(typename) behavior, typeof on non-lvalues, select over vect types, passing string literals to non-const char*, using '-' in c_name, overriding interface type via c_name in implement, loggroup identifiers exposed in generated C, & on non-lvalues, extern without type, anonymous banks, unused templates instantiating nonexistent templates, and reusing the same symbol for top-level object and top-level symbol).\n- Describes io_memory vs transaction: a feature exists to prefer legacy io_memory behavior (use_io_memory default true) so bank objects implement io_memory instead of the newer transaction interface; transaction was introduced in version 6 and will eventually replace io_memory.\n- Explains shared_logs_on_device compatibility feature: changes logging semantics in shared methods so log statements always target the device object (fixing a historical bug that previously caused logs to go to the nearest enclosing configuration), noting many scripts depend on this behavior."
                        },
                        {
                          "title": "suppress_WLOGMIXUP",
                          "start_index": 129,
                          "end_index": 130,
                          "node_id": "0287",
                          "summary": "- Notes a source-code change recommendation: replace legacy int1 uses with uint1 (grep pattern provided) where appropriate.\n- Describes how modern DML defines behavior that was undefined in C/traditional DML: negative shifts or division by zero cause unconditional critical errors; overly large shifts or signed-shift overflow cause truncation.\n- Explains differences in comparison semantics: traditional DML inherits C comparison rules, while modern DML compares values as integers (affecting signed vs unsigned comparisons; e.g., -1 vs 0xffffffffffffffff).\n- Clarifies that the dml12_int compatibility flag applies only to DML 1.2 files; imported DML 1.4 files use modern semantics for operations.\n- Lists the dml12_misc compatibility feature that preserves many small DML 1.2 quirks (examples include: sizeof(typename); typeof on non-lvalues; select over vect types; passing string literals to non-const char *; use of '-' in c_name; c_name overriding interface types in implement; loggroup identifiers exposed in generated C; applying & to non-lvalues; extern statements without types; anonymous banks; unused templates instantiating missing templates; reuse of the same symbol for top-level object and top-level symbol).\n- Describes io_memory/transaction compatibility: enabling the feature makes use_io_memory default true so banks implement io_memory (legacy behavior) instead of the newer transaction interface.\n- Documents shared_logs_on_device compatibility: preserves an old bug by making logs from shared methods always target the device object (rather than the nearest configuration), to maintain existing script behavior.\n- Explains suppress_WLOGMIXUP: by default suppresses the WLOGMIXUP warning for Simics API versions below 7 to avoid spurious warnings; details how to force the warning with --no-compat=suppress_WLOGMIXUP or --warn=WLOGMIXUP and the slight differences in suppression behavior between those options.\n- Covers legacy compatibility flags for Simics API \u22647 (section C.3.2): features removed in API 8 can be individually disabled via --no-compat=TAG. Examples given: broken_conditional_is (silences errors when instantiating templates inside #if blocks) and broken_unused_types (silences errors for unused extern-declared types), both preserving earlier buggy behavior."
                        }
                      ],
                      "node_id": "0280",
                      "summary": "This partial document describes compatibility and semantic differences between traditional DML (notably DML 1.2) and modern DML, and several compatibility features that restore old DML 1.2 quirks. It starts with a small coding note recommending replacing usages of int1 with uint1 where appropriate. It explains how operations that are undefined in C are handled differently: traditional DML inherits C\u2019s undefined behavior, while modern DML gives well-defined results (e.g., unconditional critical errors on negative shifts or division by zero, and truncation on oversized shift operands or signed shift overflow). Comparison operator semantics also differ: traditional DML follows C semantics (which can yield surprising results when mixing signed and unsigned), whereas modern DML compares values as integers (so values like -1 and 0xffffffffffffffff are consistently distinct). The text clarifies that the dml12_int feature only affects files actually marked as DML 1.2; files imported into newer DML contexts use modern semantics. The dml12_misc compatibility feature is listed with many specific legacy behaviors it restores (sizeof(typename), typeof on non-lvalues, select over vect types, passing string literals to non-const char* params, use of '-' in c_name, c_name overrides for implement objects, loggroup naming in generated C, applying & to non-lvalues, untyped externs, anonymous banks, instantiation of non-existing templates from unused templates, and reuse of a symbol name for both $-scoped and non-$-scoped top-level symbols). Finally, two other compatibility notes: io_memory vs transaction (transaction was introduced later; enabling the feature defaults use_io_memory to true so banks implement io_memory) and shared_logs_on_device (a bugfix-like compatibility change making log statements in shared methods always log on the device object rather than the nearest enclosing configuration)."
                    },
                    {
                      "title": "C.3.2 Features available up to and including --simics-api=7",
                      "start_index": 130,
                      "end_index": 130,
                      "nodes": [
                        {
                          "title": "broken_conditional_is",
                          "start_index": 130,
                          "end_index": 130,
                          "node_id": "0289",
                          "summary": "Summary of partial document contents:\n\n- Describes compatibility features in the DML(DMLC) toolchain that preserve legacy/broken behaviors for older Simics API versions.\n- Explains the suppress_WLOGMIXUP feature:\n  - Suppresses the WLOGMIXUP warning by default for Simics API versions below 7 to avoid overwhelming users.\n  - WLOGMIXUP flags a common faulty pattern that produces broken log statements; users are advised to fix such patterns during migration to API version 7.\n  - Notes command-line controls: --no-compat=suppress_WLOGMIXUP has nearly the same effect as --warn=WLOGMIXUP (both cause the warning to be reported even when API < 7). The difference is that --no-compat allows later explicit suppression via --no-warn=WLOGMIXUP, whereas --warn=WLOGMIXUP does not permit suppression.\n- Lists features available up to and including --simics-api=7 (functionality removed in API 8+), which can be disabled individually with --no-compat=TAG:\n  - broken_conditional_is: preserves a bug where instantiating a template inside an #if block does not produce an error (example shown).\n  - broken_unused_types: preserves a bug where extern-declared types that are unused (and reference undefined member types) do not trigger errors.\n- Overall focus: documenting legacy compatibility switches, their rationale, examples of preserved buggy behaviors, and how to control them via compiler options."
                        },
                        {
                          "title": "broken_unused_types",
                          "start_index": 130,
                          "end_index": 130,
                          "node_id": "0290",
                          "summary": "Summary of the partial document:\n- Describes compatibility features in the DMLC compiler for preserving pre-Simics-8 behavior, particularly around logging and error reporting.\n- Explains suppress_WLOGMIXUP: this feature suppresses the WLOGMIXUP warning by default for Simics API versions below 7, because the warning flags a common faulty logging pattern. It notes how to enable reporting via --no-compat=suppress_WLOGMIXUP or --warn=WLOGMIXUP and clarifies the behavioral difference (--no-compat allows later explicit suppression with --no-warn, while --warn does not).\n- Introduces section C.3.2 covering features available up to and including --simics-api=7 (i.e., functionality removed in API 8) and how to disable individual compatibility tags with --no-compat=TAG.\n- Gives examples of preserved buggy behaviors: broken_conditional_is (suppresses errors when instantiating templates inside #if blocks) and broken_unused_types (suppresses errors for unused extern-declared types), both retained to match Simics \u22647 behavior."
                        },
                        {
                          "title": "experimental_vect",
                          "start_index": 131,
                          "end_index": 131,
                          "node_id": "0291",
                          "summary": "This partial document lists and explains several DMLC compatibility features and the effects of enabling or disabling them. It covers experimental_vect (controls whether the vect syntax is permitted when simics_util_vect is not enabled; enabling permits it with a warning in DML 1.4, disabling forbids it), function_in_extern_struct (allows the nonstandard omission of * in function-pointer members of extern typedef structs and explains the required change to the standard C form if disabled), legacy_attributes (uses the old SIM_register_typed_attribute API; disabling it removes support for the dictionary attribute type \"D\" and advises representing dictionaries as lists of two-element lists), and lenient_typechecking (makes DMLC\u2019s type checking lax compared to GCC, with guidance on pointer-const and void-pointer differences and adjustments needed for extern:d macros when this is disabled). The fragment also includes a heading for meaningless_log_levels but its content is not present."
                        },
                        {
                          "title": "function_in_extern_struct",
                          "start_index": 131,
                          "end_index": 131,
                          "node_id": "0292",
                          "summary": "Describes several DMLC compatibility features and their effects:\n- experimental_vect: controls whether the vect syntax is allowed in files without the simics_util_vect provisional feature; when enabled it permits the syntax and emits a WEXPERIMENTAL warning in DML 1.4 (no warning in DML 1.2); when disabled the syntax is forbidden.\n- function_in_extern_struct: allows an older shorthand for function pointer members in extern typedef struct declarations (omitting the *); shows the required standard C correction (void (*m)(...)) when this feature is disabled.\n- legacy_attributes: makes DMLC register attributes using the legacy SIM_register_typed_attribute API instead of the modern SIM_register_attribute family; disabling it removes support for the dictionary attribute type (\"D\"), and advises representing dictionaries instead as lists of two-element lists (e.g. [[X,Y]*]).\n- lenient_typechecking: makes DMLC\u2019s type checking permissive compared to GCC; disabling it commonly surfaces pointer-related errors (notably const-qualification and void-pointer equivalence) and may require adjusting extern:d macro signatures to match their effective types.\n- meaningless_log_levels: listed as a feature in the partial text, but its description is not included in the provided excerpt."
                        },
                        {
                          "title": "legacy_attributes",
                          "start_index": 131,
                          "end_index": 131,
                          "node_id": "0293",
                          "summary": "- The partial document describes DMLC compatibility features and their effects and migration implications.\n- experimental_vect: Controls allowance of the vect syntax in files without simics_util_vect. If enabled, uses are permitted and trigger a WEXPERIMENTAL warning in DML 1.4 (no warning in DML 1.2); if disabled, the vect syntax is forbidden.\n- function_in_extern_struct: Allows a legacy shorthand that omits the * for function-pointer members in extern typedef struct declarations. Disabling it requires converting declarations to the standard C form using void (*m)(...) for function pointers.\n- legacy_attributes: Causes DMLC to register attributes via the legacy SIM_register_typed_attribute API instead of the modern SIM_register_attribute family. Disabling this removes support for the dictionary attribute type (\"D\"); the document recommends representing dictionaries as lists of two-element lists (e.g., [[X,Y]*]) when migrating.\n- lenient_typechecking: Makes DMLC\u2019s type checking permissive compared to GCC, notably affecting method overrides and uses of extern:d macros. Turning it off will reveal type errors, especially pointer-type mismatches (e.g., implicit discarding of const qualification and broader acceptance of void*), and may require adjusting extern declaration signatures to match actual macro types.\n- meaningless_log_levels: listed as a feature heading but no details are included in the provided partial text."
                        },
                        {
                          "title": "lenient_typechecking",
                          "start_index": 131,
                          "end_index": 132,
                          "node_id": "0294",
                          "summary": "The partial document lists and explains compatibility/provisional language features in the DML/DMLC/Simics toolchain and the effects of enabling or disabling each. Main points:\n\n- experimental_vect: controls acceptance of vect syntax when simics_util_vect is not enabled; enabled produces a WEXPERIMENTAL warning (DML 1.4), disabled forbids the syntax.  \n- function_in_extern_struct: allows a legacy shorthand for function-pointer members in extern typedef struct declarations (omitting the *); disabling requires converting to standard C pointer syntax.  \n- legacy_attributes: registers attributes via the old SIM_register_typed_attribute API; disabling removes support for dictionary-type attributes (\"D\"), requiring replacement of dictionaries with alternate representations (e.g., lists of two-element lists).  \n- lenient_typechecking: makes DMLC perform permissive/inexact type checking (notably for method overrides and extern:d macros); disabling produces stricter pointer/const and void-pointer checks and may require fixing extern signatures.  \n- meaningless_log_levels: relaxes the typical log-level constraints for warning/error/critical kinds so secondary levels can be 1\u20134, but only primary level 1 triggers repeated logs (others treated as one-shot).  \n- no_method_index_asserts: suppresses implicit bounds assertions for methods on object arrays; disabling it should be prioritized because assertion failures indicate model bugs that could otherwise cause memory corruption.  \n- optional_version_statement: makes the file version statement (e.g., dml 1.4;) optional (with a warning if omitted) and treats dml 1.3; as a deprecated alias for dml 1.4;.  \n- port_proxy_attrs: when enabled, creates legacy-style proxy configuration attributes for banks/ports (as used in Simics 5), but only for certain banks/ports similar to historical behavior.  \n- port_proxy_ifaces: when enabled, creates old-style interface-port proxies for the newer separate configuration-object interfaces (again only where historically needed).  \n- warning_statement: historically enabled an _warning statement; this feature is no longer allowed in Simics API 8 and newer.\n\nOverall the section documents backward-compatibility toggles, their runtime/compiler effects, and migration guidance for moving to stricter or modern behavior."
                        },
                        {
                          "title": "meaningless_log_levels",
                          "start_index": 132,
                          "end_index": 131,
                          "node_id": "0295",
                          "summary": "The partial document contains no substantive text or content, so no main points or topics can be identified."
                        },
                        {
                          "title": "no_method_index_asserts",
                          "start_index": 131,
                          "end_index": 132,
                          "node_id": "0296",
                          "summary": "Summary of main points covered:\n\n- The excerpt documents various DMLC/Simics compatibility features and their effects on language/simulation behavior.\n- experimental_vect: whether the vect syntax is allowed when the simics_util_vect feature is not enabled; enables use with a DML 1.4 WEXPERIMENTAL warning, otherwise forbids it.\n- function_in_extern_struct: allows the nonstandard omission of '*' for function-pointer members in extern typedef struct declarations; disabling requires converting to standard void (*m)(...) form.\n- legacy_attributes: causes attributes to be registered via the old SIM_register_typed_attribute API; disabling it removes support for dictionary attribute type (\"D\") and suggests representing dictionaries as lists of two-element lists instead.\n- lenient_typechecking: makes DMLC perform permissive type checking (affecting method overrides and extern:d macros); disabling reveals pointer/const and void-pointer incompatibilities and may require adjusting extern signatures.\n- meaningless_log_levels: relaxes constraints on log levels for warning/error/critical kinds (allows values 1\u20134), but primary level treated as 1 and non-1 subsequent levels treated as 5.\n- no_method_index_asserts: suppresses implicit bounds assertions for methods on object arrays; disabling it can expose bugs and should be a migration priority if assertions occur.\n- optional_version_statement: allows omitting the dml version statement (with a warning) and treats dml 1.3; as a deprecated alias for dml 1.4;.\n- port_proxy_attrs: (Simics 5 compatibility) optionally creates device-level proxy configuration attributes for banks/ports; not created for all cases.\n- port_proxy_ifaces: (Simics 5 compatibility) optionally creates old-style interface-port proxies to newer per-port interface objects; proxies are only created where historically needed.\n- warning_statement: enables the _warning statement; marked obsolete and disallowed in Simics API 8+.\n- The excerpt appears in a section on provisional language features and changes between DML 1.2 and 1.4."
                        },
                        {
                          "title": "optional_version_statement",
                          "start_index": 132,
                          "end_index": 131,
                          "node_id": "0297",
                          "summary": "The provided partial document contains no text or content, so no main points can be identified or summarized."
                        },
                        {
                          "title": "port_proxy_attrs",
                          "start_index": 131,
                          "end_index": 131,
                          "node_id": "0298",
                          "summary": "- experimental_vect: toggles whether uses of the vect syntax are allowed in files that lack the simics_util_vect provisional feature. If enabled, such uses are permitted and emit a WEXPERIMENTAL warning in DML 1.4 (none in DML 1.2); if disabled, the vect syntax is forbidden.\n\n- function_in_extern_struct: allows the historically permitted shorthand for function-pointer members in extern typedef struct declarations where the * is omitted. Disabling it requires converting declarations like void m(conf_object_t *); to the standard C form void (*m)(conf_object_t *);\n\n- legacy_attributes: makes DMLC register attributes using the legacy SIM_register_typed_attribute API. Disabling it removes support for the dictionary attribute type (\"D\"), so models using dictionary attributes must be migrated to another representation (e.g., a list of two-element lists [[Key,Value]*]).\n\n- lenient_typechecking: causes DMLC to perform inexact, permissive type checking compared to GCC. Turning this off exposes discrepancies (especially pointer const-qualification and void-pointer equivalence) and can produce new type errors; fixes often involve correcting pointer const usage or adjusting extern:d macro signatures to match their effective types.\n\n- meaningless_log_levels: mentioned in the partial text but no description or details are provided."
                        },
                        {
                          "title": "port_proxy_ifaces",
                          "start_index": 131,
                          "end_index": 132,
                          "node_id": "0299",
                          "summary": "The partial document lists and explains a set of DML compatibility features that control backwards\u2011compatibility behaviors and migration implications between older Simics/DML versions (notably DML 1.2/1.3 and DML 1.4). For each feature it states what enabling it does, what disabling it forbids or changes, and common migration advice. Main points covered:\n\n- experimental_vect: controls acceptance of the vect syntax when simics_util_vect is not enabled. If enabled, uses are permitted (emit a WEXPERIMENTAL warning in DML 1.4); when disabled, the vect syntax is forbidden.\n\n- function_in_extern_struct: allows the historical shorthand that omits the * on function-pointer members in extern typedef struct declarations. Disabling requires changing declarations to the standard C form with void (*m)(...).\n\n- legacy_attributes: makes DMLC register attributes via the old SIM_register_typed_attribute API. Disabling this removes support for the dictionary attribute type (\"D\"); models using dictionary attributes must be migrated to another representation (e.g., lists of two-element lists for key/value pairs).\n\n- lenient_typechecking: relaxes DMLC type checking compared to GCC-generated C. Turning it off exposes stricter type rules (notably no implicit discard of const qualifiers, limited void-pointer equivalence) and may require adjusting extern:d macro signatures or method signatures to match actual types.\n\n- meaningless_log_levels: relaxes constraints on secondary log levels for warning/error/critical logs (allowing values 1\u20134). The primary level is always treated as 1; any secondary value other than 1 is treated as 5 (so the log happens only once).\n\n- no_method_index_asserts: suppresses implicit bounds assertions for methods defined on object arrays. Disabling should be a priority; assertion failures on disable indicate real model bugs that could otherwise lead to memory corruption.\n\n- optional_version_statement: makes the top-of-file dml version statement optional (compiler warns if omitted) and treats dml 1.3 as a deprecated alias for dml 1.4 with a warning.\n\n- port_proxy_attrs: when enabled, creates device-level proxy configuration attributes for banks/ports (the Simics 5 behavior where bank/port attributes were registered on the device). Proxies are not created for all banks/ports.\n\n- port_proxy_ifaces: when enabled, creates old-style interface ports (as in Simics 5) as proxies to the newer separate configuration-object interfaces. Only created where needed for backward compatibility (not for all banks/ports).\n\n- warning_statement: enables the _warning statement; this feature was later disallowed (not permitted in Simics API 8+).\n\nOverall the section provides behavioral descriptions and concrete migration notes for each compatibility feature to help move models toward newer, stricter DML/Simics conventions."
                        },
                        {
                          "title": "warning_statement",
                          "start_index": 132,
                          "end_index": 132,
                          "node_id": "0300",
                          "summary": "- Describes several backward-compatibility features and their behaviors:\n  - Log-level compatibility: for \"warning\", \"error\" or \"critical\" logs the primary level is treated as 1 and any non-1 subsequent level is treated as 5 (so logs typically occur only once); levels 1\u20134 are accepted for compatibility.\n  - no_method_index_asserts: disables implicit bounds assertions for methods defined on object arrays; warns that migrating away is important because re-enabling assertions revealing crashes indicates model bugs that could cause memory corruption.\n  - optional_version_statement: makes the DML version statement optional (with a compiler warning if omitted) and permits the deprecated alias dml 1.3; for dml 1.4;.\n  - port_proxy_attrs: recreates Simics 5 behavior where configuration attributes for banks and ports were registered on the device as proxy attributes (created only when this feature is enabled and not for all banks/ports).\n  - port_proxy_ifaces: recreates old-style interface ports as proxies to newer port-object interfaces when enabled; proxies are not created for all banks/ports (e.g., banks inside groups).\n  - warning_statement: enabled the _warning statement historically, but this feature is disallowed in Simics API 8+.\n- Shows section headings indicating additional content on provisional language features and changes from DML 1.2 to DML 1.4."
                        }
                      ],
                      "node_id": "0288",
                      "summary": "- The fragment documents compatibility features for the DMLC compiler related to Simics API versions, explaining options that preserve buggy behavior from older Simics releases so existing codebases are not flooded with errors or warnings during migration.\n- It explains the suppress_WLOGMIXUP compatibility feature: it suppresses the WLOGMIXUP warning by default for Simics API versions below 7 because the warned-of faulty logging pattern is widespread in existing code. It also describes how to override this behavior:\n  - --no-compat=suppress_WLOGMIXUP causes DMLC to report WLOGMIXUP even when using Simics API < 7, but still allows explicit suppression via --no-warn=WLOGMIXUP.\n  - --warn=WLOGMIXUP also forces the warning to be reported, but unlike --no-compat, it does not permit later suppression.\n- It states that the following features correspond to behavior present up to and including --simics-api=7 and were removed for Simics API 8+, and that individual compatibility features can be disabled with --no-compat=TAG.\n- Two preserved buggy behaviors are described with examples:\n  - broken_conditional_is: suppresses errors when a template instantiation occurs inside an #if block (a bug in older DMLC).\n  - broken_unused_types: suppresses errors for unused extern-declared types (another bug present up to Simics 7)."
                    }
                  ],
                  "node_id": "0279",
                  "summary": "This partial document explains rationale and controls for deprecating legacy DML features to keep codebases cleaner and leaner, and warns that legacy features can bloat models and hurt performance. It documents DMLC command-line controls: --api-version (and corresponding build variables SIMICS_API_VERSION / SIMICS_API / MODULE_SIMICS_API) to select the API version, and --no-compat=tag to disable specific compatibility features; each tag also exposes a global boolean parameter named _compat_tag that scripts can check. It then lists deprecated compatibility features removed when using Simics API 7+ (but individually disable-able under older APIs): dml12_goto (preserves goto semantics), dml12_inline (inlines constant typed arguments for DML 1.2), dml12_int (preserves many legacy integer/C semantics with examples and migration notes such as assert 0 \u2192 assert false, while (1) \u2192 while (true), int1 vs uint1, truncation and undefined-behavior differences), and dml12_misc (a collection of minor DML 1.2 quirks retained when enabled, enumerating items like sizeof(typename), typeof on non-lvalues, select over vect types, permissive externs, anonymous banks, and others). It also describes io_memory (transition from io_memory to the newer transaction interface, and the use_io_memory default) and shared_logs_on_device (changes to logging semantics in shared methods)."
                }
              ],
              "node_id": "0276",
              "summary": "This partial appendix describes how DML handles deprecated language features and how users can migrate large code bases. Main points covered:\n\n- Types of deprecations: removed/renamed library symbols (easy to fix), changes in semantics of language constructs or APIs (can silently alter behavior), and changes in how compiled models appear in Simics (affects end users and may require coordinated migration).\n- Primary deprecation mechanism: Simics API versions. Each deprecated DML feature is tied to an API version; Simics major-version upgrades eventually drop features from earlier API versions.\n- Recommended migration workflow across Simics major versions: 1) while on version N, update modules to use API version N (migrate modules incrementally); 2) upgrade Simics to N+1 (normally no immediate DML effect); 3) update modules to API N+1 one-by-one. Simics N+1 provides full support for API N to allow gradual migration.\n- Additional mechanism: compiler flags to selectively disable deprecated features that remain available in the current API. Uses include stepwise migration (disable one feature at a time) and proactively turning off legacy features to prevent their use in new code, easing future migrations."
            },
            {
              "title": "D Changes from DML 1.2 to DML 1.4",
              "start_index": 133,
              "end_index": 133,
              "nodes": [
                {
                  "title": "D.1 Toy DML 1.2 device",
                  "start_index": 133,
                  "end_index": 134,
                  "node_id": "0302",
                  "summary": "- Section heading: \u201cChanges from DML 1.2 to DML 1.4\u201d \u2014 notes that DML 1.4 is largely similar to 1.2 but contains key differences that are highlighted.\n- Subsections referenced: a toy DML 1.2 example, deviceC, \u201cManaging deprecated language features,\u201d and \u201cPorting DML 1.2 to DML 1.4\u201d \u2014 indicating coverage of migration and deprecation topics.\n- Included toy DML 1.2 code illustrating common language constructs and differences:\n  - device and device example declarations\n  - method definitions with returns, nothrow, local variables, inline calls, and exception throwing\n  - bank/register declarations with size, address arithmetic, and access qualifiers (e.g., is read) and associated hooks (method after_read(memop))\n  - fields and data declarations (e.g., field f[7:0], data bool c)\n  - template syntax and parameters (example showing both \u201cparameter p default 1\u201d and \u201cparameter p = 2\u201d forms)\n  - attribute declaration combining templates, attribute parameters (e.g., allocate_type = \"int32\"), and attribute methods (method after_set) using special identifiers ($this, $p) and calls to other methods (call $bar, inline $foo)\n- Overall: the fragment serves to contrast DML 1.2 examples and constructs with DML 1.4, and to introduce sections on deprecated features and porting guidance."
                },
                {
                  "title": "D.2 The corresponding DML 1.4 device",
                  "start_index": 135,
                  "end_index": 137,
                  "node_id": "0303",
                  "summary": "- Contains a DML 1.4 code example showing core language constructs: a device declaration, an inline method foo that returns a tuple (int, bool), a method bar that can throw, a bank with a register array and a read_register method, field bit-range syntax, a session variable, templates, and an attribute with a set method.\n- Demonstrates inline methods and how inline qualifiers are now attributes of the method and of specific arguments.\n- Shows return-value typing as anonymous tuple types (-> (int, bool)) and explicit return(...) usage; return identifiers are not implicitly declared in the method scope and must be defined as locals if needed.\n- Illustrates compile-time conditional evaluation using #if for constant-folding style checks.\n- Explains exception annotation: methods that can throw must be declared with the throws keyword.\n- Shows new object-array/register syntax: register r[i < 20] size 4 @ 0x0000 + i * 4 is read_register, with an explicit index name and the range form [index < size].\n- Includes examples of local variable usage, calling default(enabled_bytes, aux), tuple assignment from inline call, bit-field declaration (field f @ [7:0]), session state declaration, and use of templates with parameter defaults and inheritance.\n- Highlights attribute definition syntax and behavior, including a set method that may call default(value) and access template parameters."
                },
                {
                  "title": "D.3 Key Differences",
                  "start_index": 137,
                  "end_index": 137,
                  "node_id": "0304",
                  "summary": "Summary of main points covered:\n\n- States that DML 1.4 must be declared at the top of a file: `dml 1.4;`.\n- Inline method syntax changed: inlining is now an explicit attribute of the method and of which arguments are inline (e.g., `inline method foo(inline a) ...`).\n- Return-value semantics changed:\n  - Return values are no longer named in method signatures; only their types are declared (e.g., `... -> (int, bool) /* b, c */`).\n  - Those return names are not implicitly available as variables inside the method body; former return variables must be declared as locals (e.g., `local int b; local bool c;`).\n  - You must explicitly return values (e.g., `return (b, c);`).\n- Compile-time conditionals: use `#if (a == 0) { ... }` for compile-time constant evaluation (where older versions used regular `if`).\n- Exception annotation: methods that may throw must be annotated with the `throws` keyword (e.g., `method bar(int a) throws`).\n- Object/array indexing syntax changed: index name must be explicit and range-style syntax is used (e.g., `register r[i < 20] ...` or generally `[index < size]`).\n- Examples of address/arithmetic expressions shown (e.g., `.., @ 0x0000 + i * 4 ...`) indicating allowed address computation forms."
                }
              ],
              "node_id": "0301",
              "summary": "Appendix describing changes from DML 1.2 to 1.4: summary that 1.4 is largely similar to 1.2 but contains key differences; includes a toy DML 1.2 device example, guidance on managing deprecated language features, and a porting guide for migrating code from DML 1.2 to DML 1.4 (part of the Device Modeling Language 1.4 Reference Manual)."
            }
          ],
          "node_id": "0214",
          "summary": "Describes register and field template parameters and behaviors: a register must not be unmapped to an address and bank-array registers must share the same parameter values; registers include a fields list referencing their field objects; init_val specifies the default value used by init and reset implementations (default 0); configuration controls how Simics exposes the register attribute (\"required\"/\"optional\"/\"pseudo\"/\"none\") with default \"optional\"; persistent and internal booleans control persistence and internal visibility (internal defaults to true). The register template exposes overridable methods read_unmapped_bits and write_unmapped_bits: read_unmapped_bits returns masked values for bits not covered by fields (with possible side effects) and the default acts as if unmapped regions were covered by fields; write_unmapped_bits is invoked for writes affecting bytes not fully covered by fields, receives masked val and enabled bits, and by default logs spec-viol messages for mismatched unmapped bit ranges without modifying val. Begins description of field objects: the field template inherits from object and the init_val and shown_desc templates, inherits get, set, and init methods and the init_val parameter, and defines a val [integer] parameter."
        },
        {
          "title": "Event objects",
          "start_index": 92,
          "end_index": 92,
          "node_id": "0305",
          "summary": "Summarizes behavior of read/write/init templates and event templates/objects:\n- read/write templates: not implemented by fields or registers by default and must be explicitly instantiated to take effect; they extend the relevant field/get_val/set_val templates and provide overrideable read(uint64)/write(uint64) methods operating on fields or registers with values in the host\u2019s native endianness; default read/write use the get/set methods; instantiating read or write on a register makes the register behave as a single field (ignoring any actual field subobjects).\n- init_val template: extends init and supplies an init_val : uint64 parameter that sets the initial value of a register\u2019s val or the bits of a field; default is 0; overrides may be given on the register and/or on fields with field overrides taking precedence for the bits they cover; technically a field\u2019s default init_val is taken from the corresponding bits of the parent register\u2019s init_val, and the template provides a default init implementation that sets uncovered register bits and corresponding parent register bits from fields.\n- event objects/templates: an event object must instantiate one of six predefined templates (simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event), which expose methods such as event and post; the event template also inherits shown_desc."
        },
        {
          "title": "Event templates",
          "start_index": 92,
          "end_index": 94,
          "node_id": "0306",
          "summary": "- Read/write templates: read and write extend field/register templates (read_field, get_val, set_val for read; write_field, get_val, set_val for write) and provide single overrideable methods read(uint64) and write(uint64). They are not implemented by fields or registers by default and must be explicitly instantiated for overrides to take effect. Instantiating them on a register makes the register behave as a single-field register (register-level reads/writes ignore actual field subobjects). Values are represented in the host endianness and the default write uses the set method.\n\n- init_val parameter: extends the init template and provides init_val : uint64 to define the initial value for a register's val member (or for the bits covered by a field). Defaults to 0. In registers with fields, overrides can be applied at register and/or field levels; field overrides take precedence for their covered bits. Technically a field\u2019s default init_val is taken from the parent register\u2019s init_val. The template also supplies a default init implementation that sets bits in registers not covered by fields and sets corresponding bits of the parent register\u2019s val from a field.\n\n- Event objects: the event template itself is minimal and requires instantiation of one of six predefined event templates; it also inherits the shown_desc template.\n\n- Event template types: six predefined templates must be used\u2014simple_time_event, simple_cycle_event, uint64_time_event, uint64_cycle_event, custom_time_event, custom_cycle_event. simple_* carry no data; uint64_* carry a single 64-bit integer; custom_* carry complex user data requiring custom (de)serialization. *_time_event use seconds (double) for time; *_cycle_event use cycles (uint64).\n\n- Common event methods: all six templates define:\n  - event(), event(uint64 data), event(void *data): abstract callback invoked when the event triggers (custom events must free data if allocated).\n  - post(time), post(time, uint64 data), post(time, void *data): non-overrideable method that posts the event to the device queue; time units depend on the instantiated template; data (if any) is passed to event().\n\n- Methods for simple and uint64 events: remove(), remove(uint64 data) to remove matching queued events; posted() / posted(uint64) to test for presence; next() / next(uint64) to get time until next occurrence (returns seconds or cycles, negative if none).\n\n- Methods for custom events: get_event_info(void *data) -> attr_value_t used when saving checkpoints to produce serializable info for each pending event (default returns nil); set_event_info(attr_value_t) -> void * used when loading checkpoints to recreate user data from saved info (default expects nil); destroy(void *data) called on posted events when device is deleted to free user-allocated memory. destroy is not automatically called when an event triggers, so event() should usually free data or explicitly call destroy."
        }
      ],
      "node_id": "0112",
      "summary": "This partial document explains how Device Modeling Language (DML) implements functionality using templates, categorizing them into object-type templates (one instantiated per object type), behavior templates (standard implementations like uint64_attr), and interface templates (which provide abstract/overrideable methods or parameters). It emphasizes that to have an interface method called or to override a default, you must explicitly instantiate the corresponding template, with examples such as implementing a register write method and overriding init_val via a template (init_to_ten). It also advises inheriting the most specific needed templates for efficiency and flexibility and shows a log_on_change example that inherits specific members (write, get, name) rather than a whole object type. Finally, it introduces universal templates applicable to all objects\u2014name (exposes object name), desc (short description and shown_desc for user-visible text), shown_desc (typed shown_desc for shared methods), and documentation (longer descriptive text)."
    },
    {
      "title": "Standard Templates",
      "start_index": 95,
      "end_index": 95,
      "nodes": [
        {
          "title": "Templates for reset",
          "start_index": 95,
          "end_index": 96,
          "nodes": [
            {
              "title": "power_on_reset, hard_reset, soft_reset",
              "start_index": 96,
              "end_index": 96,
              "nodes": [
                {
                  "title": "Description",
                  "start_index": 96,
                  "end_index": 96,
                  "node_id": "0310",
                  "summary": "The excerpt documents reset behavior and conventions for device objects: it defines three reset templates/methods (power_on_reset, hard_reset, soft_reset) with defaults that restore registers/fields to init_val and recurse into sub\u2011objects. Methods signal_raise and signal_lower may be overridden to add side effects (e.g., prevent interaction during reset). Overriding a reset without calling default() suppresses recursive resets in sub\u2011objects. Common customizations are changing the reset value (via method override or the soft_reset_val parameter) and suppressing resets using templates (sticky suppresses soft reset, no_reset suppresses all resets). Guidance on ports: if hard and power-on resets are identical, prefer only an HRESET port; retain POWER when it implies distinct behavior. Less common cases: replace SRESET with device\u2011specific names if multiple soft resets exist, while keeping POWER/HRESET when unambiguous. For modeling powered\u2011off behavior, use POWER high=on/low=off and treat lowering POWER as a reset; note that this makes devices instantiated as off until POWER is raised. Two handling styles for POWER are discussed: treating it as a pure reset signal (convenient but unrealistic if power is modeled) or as an actual power supply signal (raise before simulation, lower to power down, reset on low\u2192high\u2014more correct but harder to implement)."
                },
                {
                  "title": "Related Templates",
                  "start_index": 96,
                  "end_index": 96,
                  "node_id": "0311",
                  "summary": "Describes reset handling in device templates: default behaviors (power_on_reset, hard_reset, soft_reset) and that registers/fields default to restoring init_val; ability to override signal_raise/signal_lower for side effects (e.g., blocking interaction during reset); the default recursive reset calling into sub-objects and the consequence that overriding without calling default() suppresses sub-object resets. Covers common override patterns: changing reset values (including the soft_reset_val parameter) and suppressing resets using standard templates (sticky for soft reset only, no_reset for all resets). Recommends using only an HRESET port when hard reset and power-on reset are identical, and preserving POWER/HRESET names when adapting SRESET to device-specific ports. Discusses simulating powered-off behavior by treating POWER low as no-power (device inert) and triggering reset on POWER low; notes that such devices start powered off and require raising POWER before normal operation. Explains two ways to treat POWER: as a pure reset pulse (convenient but inaccurate for full power modeling) or as an actual power supply signal (raised before simulation and lowered on power-down, with reset on low\u2192high transitions), with trade-offs between convenience and correctness. Mentions section heading: 5.1.1 power_on_reset, hard_reset, soft_reset."
                }
              ],
              "node_id": "0309",
              "summary": "Summary of main points covered:\n\n- Describes reset-related templates/methods (power_on_reset, hard_reset, soft_reset) and default behavior: registers/fields restore to init_val and reset methods recursively call sub-objects\u2019 resets.\n- Explains overridable hooks (signal_raise, signal_lower) for additional side effects during reset (e.g., tracking asserted reset to prevent interactions).\n- Notes that overriding a reset without calling default() suppresses reset propagation to sub-objects.\n- Common override patterns: change reset value (explicit override or soft_reset_val parameter for soft reset) and suppress resets using standard templates (sticky for soft reset only, no_reset for all resets).\n- Guidance on port usage: if hard and power-on reset behave identically, prefer exposing only HRESET; presence of POWER implies distinct power-cycle behavior.\n- Less common cases: recommend renaming SRESET to device-specific names when multiple soft-reset semantics exist, while preserving POWER and HRESET if unambiguous.\n- How to model powered-off behavior: treat POWER high as powered, low as unpowered (device reset on POWER low); using this means devices are off after instantiation and POWER must be raised before use.\n- Two recommended POWER handling approaches: treat POWER as a pure toggled reset (convenient but may misrepresent power-off behavior) or treat POWER as an actual power supply (raise before simulation, lower when power off, reset on low\u2192high transitions \u2014 more accurate but less convenient)."
            },
            {
              "title": "poreset, hreset, sreset",
              "start_index": 96,
              "end_index": 96,
              "nodes": [
                {
                  "title": "Description",
                  "start_index": 96,
                  "end_index": 96,
                  "node_id": "0313",
                  "summary": "- Explains reset-related templates and methods (power_on_reset, hard_reset, soft_reset) and that by default all registers/fields implement them, restoring to the init_val parameter.  \n- Notes signal_raise and signal_lower can be overridden to add side effects (e.g., tracking asserted reset to prevent device interaction).  \n- Describes default behavior: reset methods recursively call corresponding reset in sub-objects; if an override omits calling default(), resets are suppressed in sub-objects.  \n- Common override patterns: changing reset target values (via method override or soft_reset_val parameter for soft reset) and suppressing resets using standard templates (sticky for soft reset only; no_reset for all resets).  \n- Recommends creating only an HRESET port when hard reset and power-on reset are identical; presence of a POWER port should indicate distinct power-cycle behavior.  \n- Covers less common cases: replacing SRESET with device-specific port names when multiple soft-reset-like signals exist, while preserving POWER and HRESET when unambiguous.  \n- Describes simulating a powered-off state: treat POWER high = device powered, low = unpowered; lowering POWER triggers a device reset and device is considered off after instantiation until POWER is raised.  \n- Outlines two ways to handle a POWER port: treat as a pure reset port (convenient but inaccurate if power is modeled) or treat as an actual power supply (raise before simulation, lower to power down; reset on lower+raise), with the latter being more accurate."
                },
                {
                  "title": "Related Templates",
                  "start_index": 96,
                  "end_index": 97,
                  "node_id": "0314",
                  "summary": "- Describes reset infrastructure: three reset types (power_on_reset, hard_reset, soft_reset) and corresponding methods (power_on_reset, hard_reset, soft_reset) implemented on objects, registers and fields; default behavior restores init_val and reset methods recurse into sub-objects unless default() is called by an override.\n- Explains override hooks and side effects: signal_raise and signal_lower can be overridden to add behavior on reset (e.g., track asserted reset to prevent interaction).\n- Details common reset customizations: overriding methods to change reset values (or using the soft_reset_val template for soft reset) and suppressing resets via standard templates (sticky to suppress soft reset; no_reset to suppress all resets).\n- Recommends port usage: if hard reset and power-on reset behave identically, create only an HRESET port; include POWER port only when device exhibits distinct behavior on power cycling.\n- Discusses less common use cases and POWER semantics: guidance for renaming SRESET to device-specific names, simulating powered-off state by treating POWER high=powered, low=power-down (device reset on POWER low), and two approaches to using POWER\u2014treating it as a pure reset port or as an accurate power supply (raise before simulation, lower when off), with trade-offs in convenience vs correctness.\n- Lists top-level and object-level reset callbacks and related templates (power_on_reset/hard_reset/soft_reset on objects; poreset/hrset/srset at top level; related templates: poreset, hreset, sreset and power_on_reset, hard_reset, soft_reset).\n- Introduces templates for registers and fields and their semantics: templates can be applied to either registers or fields; when applied to a register they may override field-level implementations for the affected operation (e.g., read_unimpl on a register ignores field read overrides and returns register value; writes still propagate to fields).\n- Documents specific register/field templates:\n  - soft_reset_val: defines soft-reset value via parameter instead of init_val.\n  - ignore_write: causes writes to be ignored (useful for read-only fields within writable registers).\n  - read_zero: reads always return 0; writes unaffected.\n  - read_only: object is read-only to software but can be modified by hardware; first software write logs a spec_violation at level 1, subsequent writes at level 2; fields only log if value changes.\n- Notes logging behavior and guidance: when registers contain both read-only fields and writable fields, using ignore_write on fields may be preferable to global read_only on the register to avoid spurious logging and preserve expected write behavior."
                }
              ],
              "node_id": "0312",
              "summary": "The excerpt covers reset behavior and conventions for device models, including:\n- Standard reset templates (power_on_reset, hard_reset, soft_reset) and that registers/fields default to implementing them with init_val as the restore value.\n- Ability to override signal_raise and signal_lower to add side effects during reset (e.g., tracking asserted reset to block interactions).\n- Default reset methods recursively call the same reset in sub\u2011objects; failing to call default() in an override suppresses resets in sub\u2011objects.\n- Two common override patterns: change the reset value (via method override or the soft_reset_val parameter for soft reset) and suppress resets (using templates like sticky for soft resets or no_reset for all resets).\n- Port naming recommendations: prefer only HRESET when hard and power\u2011on resets are identical; preserve POWER and HRESET names when they represent distinct behaviors; consider device\u2011specific names for SRESET if needed.\n- How to model a powered\u2011off state: treat POWER high = powered, low = power\u2011off (device reset when POWER is lowered), with devices considered off after instantiation if this scheme is used (POWER must be raised explicitly).\n- Two approaches to POWER behavior: treat POWER as a pure reset signal (brief toggles for POR) or model it as an actual power supply (raise before simulation, lower on power loss, with reset triggered by low\u2192high), noting the latter is more accurate but less convenient.\n- Pointer to section 5.1.1 covering power_on_reset, hard_reset, soft_reset."
            }
          ],
          "node_id": "0308",
          "summary": "- Chapter introduces the standard templates provided in the Device Modeling Language (DML) utility.dml library, usable for both registers and fields; many templates share functionality but differ by name/log messages (e.g., undocumented vs. reserved).\n- Clarifies terminology: \u201cobject\u201d refers to registers and fields; distinguishes software accesses (io_memory reads/writes via DML read/write) from hardware accesses (Simics configuration attributes via DML set/get); device code can still modify registers even if hardware modification is prohibited.\n- Describes reset support via standard templates (no built-in DML reset): three reset types\u2014power-on reset, hard reset, and soft reset\u2014and how to enable them by instantiating poreset, hreset, and sreset which create POWER, HRESET, SRESET ports implementing the signal interface.\n- Explains behavior: raising the signal invokes corresponding methods (power_on_reset, hard_reset, soft_reset) in objects that implement the templates; default behavior restores registers/fields to init_val and reset methods recursively call sub-objects; signal_raise/signal_lower can be overridden for additional side effects.\n- Explains common overrides: change reset value (method override or soft_reset_val parameter for soft reset) and suppress reset (sticky suppresses soft reset; no_reset suppresses all resets). Notes that overriding without calling default() suppresses resets in sub-objects.\n- Gives guidance on POWER/HRESET usage: if power-on and hard reset are identical, prefer only HRESET; if SRESET doesn\u2019t map well, replace with device-specific ports while preserving POWER/HRESET when unambiguous.\n- Discusses modeling power-off state: recommended to treat POWER high = powered, low = off; device reset on POWER low; device considered off after instantiation and must have POWER raised to operate. Contrasts two POWER handling approaches\u2014pure reset port (convenient) vs. accurate power-supply modeling (more correct).\n- Leads into section 5.1.1 covering the specific templates/methods: power_on_reset, hard_reset, soft_reset."
        },
        {
          "title": "Templates for registers and fields",
          "start_index": 97,
          "end_index": 97,
          "nodes": [
            {
              "title": "soft_reset_val",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0316",
              "summary": "This partial document describes reset- and access-related templates for register and field objects. It specifies a generic reset callback interface automatically implemented by registers and fields, plus top-level templates for power-on, hard, and soft resets (power_on_reset, hard_reset, soft_reset). It explains templates that can be applied to registers or fields and how they affect read/write behavior, noting that register-level templates may override field implementations for reads while writes still propagate to fields. Specific templates covered include soft_reset_val (sets the soft-reset value instead of init_val), ignore_write (silences writes, useful for read-only fields within writable registers), read_zero (reads always return 0 while writes are unchanged), and read_only (software cannot modify the value; hardware can). The document also documents logging behavior for read_only writes (first software write logs a spec_violation at level 1, subsequent writes at level 2, and fields only log when the written value changes) and recommends using ignore_write for read-only fields in registers that also contain writable fields."
            },
            {
              "title": "ignore_write",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0317",
              "summary": "This partial document covers reset and access-control templates for registers and fields. It describes a generic reset-callback interface automatically implemented by registers and fields, plus top-level templates for standard reset behaviors (power-on, hard, soft resets) and their related template names. It explains that many templates apply to both registers and fields and that when applied to a register they can override field-specific read implementations (reads may ignore field overrides while writes still propagate to fields). Specific templates documented include: soft_reset_val (sets the reset value used on soft reset via a soft_reset_val parameter, related to soft_reset), ignore_write (silences writes, useful for read-only fields in writable registers), read_zero (forces reads to return 0 while leaving writes unaffected, related to read_constant), and read_only (makes an object read-only for software but writable by hardware, with logging behavior: first software write emits a spec_violation at log-level 1, subsequent writes at level 2; fields only log when the new value differs). The document notes practical guidance\u2014e.g., using ignore_write when a register mixes read-only and writable fields."
            },
            {
              "title": "read_zero",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0318",
              "summary": "Summary of main points in the partial document:\n\n- Reset callback interfaces:\n  - A generic reset-callback interface is implemented on objects to receive reset events; registers and fields get this automatically.\n  - Top-level reset templates (poreset, hreset, sreset) map to standard behaviors: power_on_reset, hard_reset, soft_reset.\n\n- Template application rules:\n  - Several templates can be applied to both registers and fields. Many affect only reads or writes.\n  - When applied to a register, a template can override/ignore field-level implementations for that operation (e.g., a register-level read template can bypass field read implementations), while the other operation (e.g., writes) still propagates to fields.\n\n- Specific templates described:\n  - soft_reset_val: When applied to a register or field, defines the value used on a soft reset via soft_reset_val parameter instead of the default init_val. Related to soft_reset.\n  - ignore_write: Causes software writes to be ignored; useful for making individual fields effectively read-only inside an otherwise writable register.\n  - read_zero: Reads always return 0 regardless of stored value; writes are unaffected. Related to read_constant.\n  - read_only: Makes the object read-only for software while allowing hardware updates. Logging behavior: the first software write produces a spec_violation log at level 1; subsequent writes log at level 2. Field-level logging only occurs if the written value differs from the previous value. For registers containing both read-only and writable fields, using ignore_write may be preferable."
            },
            {
              "title": "read_only",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0319",
              "summary": "- Describes reset-related templates and callbacks: a generic reset callback template implemented on any object (auto-implemented for registers and fields) and top-level templates for standard power-on, hard, and soft reset behavior.\n- Explains that many templates can be applied to both registers and fields and typically affect either read or write operations; when applied to a register they override field-level implementations for that operation while writes still propagate to fields.\n- Gives examples and semantics of specific templates:\n  - soft_reset_val: sets the reset value used on soft reset (soft_reset_val) instead of the default init_val.\n  - ignore_write: causes writes to be ignored (useful for read-only fields inside writable registers).\n  - read_zero: forces reads to return 0 regardless of stored value; writes are unaffected.\n  - read_only: makes the object read-only for software while allowing hardware modifications; documents logging behavior for attempted software writes (first write logs spec_violation at level 1, subsequent writes at level 2; fields only log if value changes).\n- Notes related template names for cross-reference (e.g., poreset/hreset/sreset \u2194 power_on_reset/hard_reset/soft_reset; soft_reset_val \u2194 soft_reset; read_zero \u2194 read_constant).\n- Advises that ignore_write may be preferable to read_only for fields inside registers with other writable fields because software often ignores written values."
            },
            {
              "title": "write_only",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0320",
              "summary": "This partial document describes reset callbacks and templates for registers and fields:\n\n- Reset callbacks: an interface implemented on objects to receive reset events; registers and fields get this automatically. Top-level templates provide standard behaviors for power-on reset, hard reset and soft reset (poreset/hreset/sreset corresponding to power_on_reset, hard_reset, soft_reset).\n- Templates can be applied to registers and fields and typically affect read or write behavior. When applied to a register with fields, some templates override field-level read implementations (example: read_unimpl on a register returns the register value via get and ignores field read overrides), while writes may still propagate to fields.\n- soft_reset_val: applied to a register or field to define the reset value used on soft reset (soft_reset_val parameter) instead of the default init_val; related to soft_reset.\n- ignore_write: makes writes ignored; useful for read-only fields inside an otherwise writable register (alternative to read_only when mixing writable and non-writable fields).\n- read_zero: causes reads to always return 0 regardless of stored value; writes are unaffected; related to read_constant.\n- read_only: marks the object read-only for software while hardware may modify it; software write attempts generate spec_violation log messages (first write at log-level 1, subsequent writes at log-level 2). Fields only log when the new written value differs from the old value. When a register contains both read-only and writable fields, ignore_write may be preferable to avoid unwanted software write behavior."
            },
            {
              "title": "write_1_clears",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0321",
              "summary": "This partial document describes templates and behaviors related to reset events and register/field access control in a register model. It defines a general reset-callback template (automatically provided for registers and fields) and top-level templates for standard reset behavior: power-on reset, hard reset, and soft reset. It then introduces templates that can be applied to both registers and fields, noting that some templates affect only read or write operations and that, when applied to a register, they override field-level implementations for that operation. Specific templates covered include: soft_reset_val (sets a custom reset value on soft reset), ignore_write (makes writes no-ops, useful for read-only fields inside writable registers), read_zero (reads always return 0; writes unaffected), and read_only (software cannot modify the value while hardware can). The read_only template\u2019s logging behavior is detailed (first illegal software write logged as spec_violation at level 1, subsequent writes at level 2; fields log only when the value would change), and the document notes that ignore_write may be preferable when a register mixes read-only and writable fields."
            },
            {
              "title": "clear_on_read",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0322",
              "summary": "This partial document section describes reset-related callbacks and access-control templates for registers and fields:\n\n- Reset callbacks:\n  - A generic reset callback interface is implemented on any object to receive its corresponding reset event; registers and fields get this automatically.\n  - Top-level reset templates provide standard behaviors for power-on, hard, and soft resets (named poreset/hreset/sreset and related to power_on_reset, hard_reset, soft_reset).\n\n- Template application rules:\n  - Many templates apply to both registers and fields and typically affect read or write behavior.\n  - When a template is applied to a register, it can override or ignore implementations in contained fields (example: a register-level read_unimpl causes reads to return the register value and ignore field read overrides), while writes may still propagate to fields.\n\n- Specific templates documented:\n  - soft_reset_val: Applied to a register or field to define a soft-reset value via soft_reset_val parameter instead of the default init_val; related to the soft_reset template.\n  - ignore_write: Causes writes to be ignored; useful for making individual fields effectively read-only inside otherwise writable registers (see read_only for more context).\n  - read_zero: Reads always return 0 regardless of stored value; writes are unaffected; related to read_constant.\n  - read_only: Makes the object read-only for software while allowing hardware modifications. Software write attempts produce spec_violation log messages (first write at log-level 1, subsequent writes at log-level 2); fields only log if the written value differs from the old value. For registers mixing writable fields and read-only fields, ignore_write may be a better choice."
            },
            {
              "title": "write_1_only",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0323",
              "summary": "The excerpt documents register/field templates and reset behavior. Main points:\n- Callback interface for reset events: a generic reset callback is implemented on objects (automatically on registers and fields).\n- Top-level reset templates: por, hreset, sreset provide standard power-on, hard, and soft reset behavior (related templates: power_on_reset, hard_reset, soft_reset).\n- General rule: many templates can be applied to both registers and fields and typically affect either read or write. When applied to a register, a template can override read or write behavior for the whole register and ignore field-level implementations for that operation, though writes may still propagate to fields (example: read_unimpl).\n- soft_reset_val: when applied to a register or field, defines the reset value used on soft reset (overrides default init_val); related to the soft_reset template.\n- ignore_write: causes writes to be ignored \u2014 useful for read-only fields that live inside writable registers (alternative to read_only in some cases).\n- read_zero: makes reads always return 0 while leaving writes unaffected; related to read_constant.\n- read_only: marks the object read-only for software but modifiable by hardware; software writes generate spec_violation log messages (first write at log level 1, subsequent writes at level 2), and fields only log when the written value differs from the old value."
            },
            {
              "title": "write_0_only",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0324",
              "summary": "This partial document describes reset and access-control templates for register/field objects:\n\n- Provides a reset-callback interface implemented on objects to receive corresponding reset events; registers and fields implement this automatically.\n- Introduces top-level standard reset templates for power-on, hard, and soft resets (por, hreset, sreset) with related template names power_on_reset, hard_reset, soft_reset.\n- Explains templates that apply to both registers and fields, noting that many affect only read or write operations and that applying a template to a register overrides field-level read implementations (example: read_unimpl on a register returns the register value via get and ignores field read overrides, while writes still propagate to fields).\n- soft_reset_val: when applied to a register or field, defines the reset value used on a soft reset via the soft_reset_val parameter instead of the default init_val; related to the soft_reset template.\n- ignore_write: causes writes to be ignored; useful for creating read-only fields within otherwise writable registers and is an alternative to read_only in mixed registers.\n- read_zero: makes reads always return 0 regardless of the stored value; writes are unaffected; related to read_constant.\n- read_only: marks the object as read-only to software while allowing hardware to modify it; software writes produce spec_violation log messages (first write at log-level 1, subsequent writes at log-level 2), and fields only log when the written value differs from the old value."
            },
            {
              "title": "read_constant",
              "start_index": 97,
              "end_index": 97,
              "node_id": "0325",
              "summary": "This partial document section describes reset- and access-related templates for registers and fields. It explains generic reset callbacks (automatically implemented on registers/fields), top-level power-on, hard and soft reset templates (por/hreset/sreset mapped to power_on_reset, hard_reset, soft_reset), and a class of templates that modify read/write behavior. It clarifies that templates can be applied to either registers or fields and that when applied to a register they may override or ignore field-level read implementations while writes still propagate to fields (example: read_unimpl). Specific templates covered include soft_reset_val (sets soft-reset value instead of init_val), ignore_write (makes writes ignored, useful for read-only fields within writable registers), read_zero (reads always return 0, writes unaffected), and read_only (software cannot modify the value though hardware can; writes generate spec_violation/log messages with first write at log-level 1 and subsequent writes at level 2, and field-level logging only occurs if the written value differs)."
            },
            {
              "title": "constant",
              "start_index": 98,
              "end_index": 98,
              "node_id": "0326",
              "summary": "Summarizes access-behavior templates for registers/fields: \n- write_only: register can be written but reads return 0; intended for registers (use read_zero for write-only fields); first read logs a spec_violation at level 1, subsequent reads log at level 2. \n- write_1_clears: software clears bits by writing 1s; new value = old & ~(written value); commonly used where hardware sets bits and software acknowledges by clearing. \n- clear_on_read: reads return the object value and then reset it to 0 as a side effect. \n- write_1_only: software can only set bits to 1; new value = old | written value (related to write_0_only). \n- write_0_only: software can only set bits to 0; new value = old & written value (related to write_1_only). \n- read_constant: reads always return a specified constant (writes do not affect the read result); the stored attribute still reflects the actual stored value; intended for cases where reads ignore the stored value\u2014use the separate constant template for truly non-storing constant fields. Parameter: read_val (the constant returned)."
            },
            {
              "title": "silent_constant",
              "start_index": 98,
              "end_index": 99,
              "node_id": "0327",
              "summary": "The partial document describes register/field access templates and their semantics, side effects, logging behavior, parameters, and related templates. Main points covered:\n\n- write_only\n  - Register value can be modified by software but reads return 0 (cannot be read back).\n  - Intended for registers; use read_zero for write-only fields.\n  - Logging: first read produces a spec_violation at log-level 1, subsequent reads at log-level 2.\n\n- write_1_clears\n  - Software can only clear bits by writing 1s; typically used where hardware sets bits and software clears them to acknowledge.\n  - New value = old_value AND (bitwise complement of written value).\n\n- clear_on_read\n  - Reads return the object value, and reading resets the object value to 0 as a side effect.\n\n- write_1_only\n  - Software can only set bits to 1.\n  - New value = old_value OR written_value.\n  - Related template: write_0_only.\n\n- write_0_only\n  - Software can only set bits to 0.\n  - New value = old_value AND written_value.\n  - Related template: write_1_only.\n\n- read_constant\n  - Reads always return a specified constant value (writes are unaffected).\n  - Intended for registers/fields that store a value but whose reads disregard the stored value.\n  - Attribute reflects stored value (not the read-returned constant).\n  - Parameter: read_val (the constant returned).\n  - Related templates: constant, silent_constant, read_zero.\n\n- constant\n  - Writes are forbidden and have no effect on the read behavior; the object retains backing storage that affects reads.\n  - End-users can modify the constant via the register attribute and such tweaks persist across reset.\n  - Using this template signals the object is intended to stay constant; model should not update the register value or override read method.\n  - Logging: first write (if it would change the stored value) produces a spec_violation at log-level 1, subsequent writes at log-level 2.\n  - Parameter: init_val (initial constant).\n  - Related templates: read_constant, silent_constant, read_only.\n\n- silent_constant\n  - Object value remains constant; writes are ignored and do not update the value.\n  - End-user tweaks to the value persist across reset.\n  - By convention the model should not modify this value; use ignore_write if model-driven modification is desired.\n  - Parameter: init_val.\n  - Related templates: constant, read_constant.\n\n- zeros\n  - Object value is constant zero; software writes are forbidden and do not update the value.\n  - Logging: first software write (if it would change the value) produces a spec_violation at log-level 1, subsequent writes at log-level 2.\n\n- ones\n  - Object value is constant all 1s; software writes do not update the value.\n  - Logging behavior mirrors zeros: first offending write logs a spec_violation at log-level 1, remaining writes at log-level 2."
            },
            {
              "title": "zeros",
              "start_index": 99,
              "end_index": 99,
              "node_id": "0328",
              "summary": "This partial document describes several register/object templates that define constant or immutable behaviors and their logging/parameters:\n\n- It lists related templates (e.g., constant, silent_constant, read_zero) and then details individual templates.\n\n- constant: Writes are forbidden and have no effect on the object value, though the object retains backing storage so an end-user can modify the value via the register attribute (changes survive reset). Using this template signals the model should not update the register value or override the read method; use read_only if a different behavior is desired. Log behavior: the first write that attempts to change the value emits a spec_violation at log level 1; subsequent writes log at level 2. Parameter: init_val. Related templates: read_constant, silent_constant, read_only.\n\n- silent_constant: The object value remains constant and writes are ignored (do not update the value). End-user tweaks to the attribute are allowed and persist across resets. By convention the model should not modify the object value; use ignore_write if model updates are wanted. Parameter: init_val. Related templates: constant, read_constant.\n\n- zeros: Object value is constant zero; software writes are forbidden and do not update the value. Logging mirrors constant: first offending write logs spec_violation at level 1, subsequent writes at level 2.\n\n- ones: Object value is constant all 1s; software writes do not update the value. Logging behavior is the same as zeros/constant (first write level 1, remaining writes level 2)."
            },
            {
              "title": "ones",
              "start_index": 99,
              "end_index": 99,
              "node_id": "0329",
              "summary": "The excerpt documents several register/field templates and their behaviors, including related templates, parameters and logging rules. Key points:\n- Templates covered: constant, silent_constant, zeros, ones (and cross-references to read_constant, read_only, ignore_write, read_zero, silent_constant).\n- constant: writes are forbidden and have no effect on the modeled update; the object still has backing storage so reads reflect that storage (end-users can modify the attribute and changes survive reset). Using this template indicates the model should not update the register value or override reads; use read_only if different behavior is desired. Parameter: init_val. Related templates: read_constant, silent_constant, read_only.\n- silent_constant: object value remains constant; software writes are ignored and do not change the value; end-user tweaks (via attribute) survive reset. The model should not modify the value; use ignore_write if alternate behavior is desired. Parameter: init_val. Related templates: constant, read_constant.\n- zeros: object value is constant zero; software writes are forbidden and do not update the value. Logging: first software write that changes value produces a spec_violation at log-level 1, subsequent writes at log-level 2.\n- ones: object value is constant all 1s; software writes do not update the value. Logging: same spec_violation behavior as zeros (first offending write log-level 1, remaining log-level 2)."
            },
            {
              "title": "ignore",
              "start_index": 99,
              "end_index": 99,
              "node_id": "0330",
              "summary": "This partial document section describes register/value templates that enforce constant or immutable behaviors. It defines the \"constant\" template (writes forbidden, backing storage retained so reads reflect stored value and users can tweak the attribute which persists across resets), with an init_val parameter and guidance that using this template signals the model should not update the register or override reads; related templates include read_constant, silent_constant, and read_only. The \"silent_constant\" template likewise produces a constant value (init_val) but ignores writes (no update), with the convention that the model should not modify the value; related templates include constant and read_constant. Special-case templates \"zeros\" and \"ones\" provide constant all-0 or all-1 values respectively; software writes do not change the value. For templates that forbid writes (constant, zeros, ones), the first offending software write (if it would change the field/register) generates a spec_violation log at level 1 and subsequent writes log at level 2."
            },
            {
              "title": "reserved",
              "start_index": 99,
              "end_index": 100,
              "node_id": "0331",
              "summary": "- Describes register/field templates that control read/write behavior and logging semantics.\n- constant: writes are forbidden/no effect but backing storage remains (user can tweak via attribute); model should avoid updating value; init_val parameter; related to read_constant, silent_constant, read_only; first write that changes value logs spec_violation at level 1, subsequent writes at level 2.\n- silent_constant: object value remains constant, writes ignored and do not update value; user tweaks survive reset; init_val parameter; related to constant, read_constant.\n- zero(s): object value is constant zero; software writes forbidden and do not update value; first differing write logs spec_violation at level 1, subsequent writes at level 2.\n- ones: object value is constant all 1s; software writes do not update value; first differing write logs spec_violation at level 1, subsequent writes at level 2.\n- ignore: object's functionality unimportant; reads return 0 and writes are ignored.\n- reserved: object marked reserved and should not be used by software; writes update storage, reads return storage; first software write that changes value logs spec_violation at level 2, no logs thereafter.\n- unimpl: functionality unimplemented; warn on usage; reads/writes use default implementations; first register read/write logs unimplemented at level 1, subsequent accesses at level 3; field reads do not log; first field write that changes value logs at level 1, then level 3; related to read_unimpl, write_unimpl, silent_unimpl, design_limitation.\n- read_unimpl: read functionality unimplemented (writes use default/overridable); first register read logs unimplemented at level 1, subsequent reads at level 3; field reads do not log; related templates mirror unimpl.\n- write_unimpl: write functionality unimplemented (reads use default/overridable); first register or field write that changes value logs unimplemented at level 1, subsequent writes at level 3; related templates mirror unimpl."
            },
            {
              "title": "unimpl",
              "start_index": 100,
              "end_index": 100,
              "node_id": "0332",
              "summary": "This partial document defines several register/object behavior templates and their logging policies. \"ignore\" indicates the object\u2019s functionality is unimportant: reads return 0 and writes are ignored. \"reserved\" marks objects that should not be used by software: writes update and reads return the stored value; the first software write to a register or to a field (when the field value differs from the write) emits a spec-viol log at level 2, with no logs on subsequent writes. \"unimpl\" denotes unimplemented functionality and advises warning on use; reads and writes use default implementations, with the first register read or write producing an unimplemented log at level 1 and subsequent accesses at level 3; field reads do not log, while the first field write (when value differs) logs at level 1 and later writes at level 3. The document also defines specialized variants: \"read_unimpl\" (reads unimplemented; first register read logs level 1, later reads level 3; field reads do not log) and \"write_unimpl\" (writes unimplemented; first register write logs level 1, later writes level 3; first differing field write logs level 1, later writes level 3). Related template references include read_unimpl, write_unimpl, silent_unimpl, and design_limitation."
            },
            {
              "title": "read_unimpl",
              "start_index": 100,
              "end_index": 100,
              "node_id": "0333",
              "summary": "This partial document defines several register/object behavior templates and their logging policies: \n- \"ignore\": object functionality is unimportant \u2014 reads return 0 and writes are ignored. \n- \"reserved\": the object is reserved and should not be used by software; writes update the stored value and reads return it. The first software write to a register or field (when the field value changes) emits a spec-viol log at level 2; subsequent writes produce no logs. \n- \"unimpl\": the object\u2019s functionality is unimplemented and should warn on use; reads and writes follow default implementations. The first register read or write emits an unimplemented log at level 1, subsequent accesses emit level 3; field reads do not log, while the first field write that changes value logs at level 1 and subsequent field writes at level 3. Related templates: read_unimpl, write_unimpl, silent_unimpl, design_limitation. \n- \"read_unimpl\": only read functionality is unimplemented (writes use default or can be overridden); the first register read logs unimplemented at level 1 and later reads at level 3; field reads do not log. Related templates listed. \n- \"write_unimpl\": only write functionality is unimplemented (reads use default or can be overridden); the first register write logs unimplemented at level 1 and later writes at level 3; the first field write that changes value logs at level 1 and subsequent field writes at level 3. Related templates listed."
            },
            {
              "title": "write_unimpl",
              "start_index": 100,
              "end_index": 100,
              "node_id": "0334",
              "summary": "This partial document defines several register/object behavior templates and their semantics: \"ignore\" (functionality unimportant\u2014reads return 0 and writes are ignored); \"reserved\" (object must not be used by software\u2014reads return the stored value and writes update it, with the first software write to a register or field that changes the value producing a spec-viol log at level 2 and no further logs); \"unimpl\" (functionality unimplemented\u2014reads and writes use default implementations but software use should be warned; first register read or write emits an unimplemented log at level 1 and subsequent accesses at level 3, field reads do not log, while first field writes that change the value log at level 1 and subsequent such writes log at level 3). It also documents two specialized unimplemented variants: \"read_unimpl\" (read functionality unimplemented, writes use default/overridable behavior; first register read logs at level 1, subsequent reads at level 3; field reads do not log) and \"write_unimpl\" (write functionality unimplemented, reads use default/overridable behavior; first register write logs at level 1, subsequent writes at level 3; first field write that changes the value logs at level 1 and subsequent such writes at level 3). Each template lists related templates that can be combined or used instead (e.g., read_unimpl, write_unimpl, silent_unimpl, design_limitation), and notes where default implementations can be overridden (for example by read_only or write_only templates)."
            },
            {
              "title": "silent_unimpl",
              "start_index": 100,
              "end_index": 99,
              "node_id": "0335",
              "summary": "The partial document contains no text or content, so no main points can be identified."
            },
            {
              "title": "undocumented",
              "start_index": 100,
              "end_index": 101,
              "node_id": "0336",
              "summary": "This partial document defines a set of register/field \"templates\" that describe semantics and logging behavior for different object states in a hardware model. It covers templates like ignore (reads return 0, writes ignored), reserved (writes update value; first software write logs a spec-viol at level 2), and various unimplemented variants (unimpl, read_unimpl, write_unimpl, silent_unimpl) that use default read/write implementations but emit warnings: typically the first register access logs at level 1 (or level 2 for silent_unimpl) and subsequent accesses at level 3, with field accesses treated specially (often no read log; field writes log only if the value changes). The undocumented template logs spec-violation on first software read/write (level 1) and level 2 afterwards. unmapped marks registers as excluded from a bank's address space. sticky and no_reset describe reset behavior (sticky: preserve value across soft-reset; no_reset: do not change value on hard or soft reset). design_limitation documents intentionally unimplemented features (default behavior provided) and is related to unimpl/silent_unimpl. Several templates list related templates and note that default read/write behavior can be overridden (e.g., by read_only/write_only). The section ends by beginning bank-related templates (function_mapped_bank)."
            },
            {
              "title": "unmapped",
              "start_index": 101,
              "end_index": 101,
              "node_id": "0337",
              "summary": "Summarizes register and field template behaviors: \u201csilent_unimpl\u201d denotes unimplemented functionality that uses default reads/writes while suppressing verbose logs (first software read/write generates an unimplemented message at log-level 2, subsequent accesses at level 3; field reads produce no message and field writes only log if value changes), and references related templates. \u201cundocumented\u201d marks poorly or undocumented functionality implemented with default reads/writes and produces spec_violation logs (first access at level 1, subsequent at level 2). \u201cunmapped\u201d excludes a register from the bank\u2019s address space. \u201csticky\u201d (sticky) prevents value changes on soft-reset. \u201cdesign_limitation\u201d indicates intentionally unimplemented functionality outside model scope (default accesses used; related to unimpl and silent_unimpl; e.g., debug registers). \u201cno_reset\u201d means register/field values are unchanged by hard or soft reset. The section then moves into bank-related templates, beginning with function_mapped_bank."
            },
            {
              "title": "sticky",
              "start_index": 101,
              "end_index": 101,
              "node_id": "0338",
              "summary": "The excerpt defines several register/object modeling templates and their behaviors: \n- silent_unimpl: object functionality is unimplemented but uses default reads/writes and suppresses noisy logging (first software read/write logs an \"unimplemented\" message at level 2, subsequent accesses at level 3; field reads do not log). Related to unimpl and design_limitation. \n- undocumented: functionality is undocumented or poorly documented, uses default reads/writes, with the first software read/write generating a spec_violation at log level 1 and subsequent ones at level 2. \n- unmapped: the register is excluded from the containing bank's address space. \n- sticky: do not reset the object value on soft reset (retain current value). \n- design_limitation: functionality is intentionally out of model scope and left unimplemented by design (default reads/writes); distinguished from unimpl and related to silent_unimpl. \n- no_reset: register/field value is not changed on hard or soft reset. \nThe section closes by beginning the bank-related templates with function_mapped_bank."
            },
            {
              "title": "design_limitation",
              "start_index": 101,
              "end_index": 101,
              "node_id": "0339",
              "summary": "This partial document lists and describes register/field template types and their behaviors, covering logging, reset behavior, and address-space treatment:\n\n- silent_unimpl: Object functionality is unimplemented but uses default reads/writes while minimizing log spam. First software register read/write logs an \u201cunimplemented\u201d message at level 2; subsequent accesses log at level 3. Reads to fields do not log; first field write (when value changes) logs at level 2, subsequent at level 3. Related to unimpl and design_limitation.\n\n- undocumented: Functionality is undocumented or poorly documented; default reads/writes are used. The first software read and write produce a spec_violation log at level 1; subsequent accesses log at level 2.\n\n- unmapped: The register is excluded from the containing bank\u2019s address space.\n\n- sticky: (labeled \u201cstick y\u201d) Object value is preserved on soft-reset (not cleared).\n\n- design_limitation: Functionality is intentionally left unimplemented because it is outside model scope; default reads/writes are used. Suggested for debug registers and distinguished from unimpl (which is an implementation gap). Related to unimpl and silent_unimpl.\n\n- no_reset: Register or field value is not changed on hard or soft reset.\n\n- Bank-related templates: begins with the heading for function_mapped_bank (section 5.3.1), indicating the next section will describe bank-level mapping behavior."
            },
            {
              "title": "no_reset",
              "start_index": 101,
              "end_index": 101,
              "node_id": "0340",
              "summary": "The partial document lists register and field modeling templates and their behaviors: \"silent_unimpl\" marks functionality as unimplemented but uses default reads/writes while minimizing log noise (first software read/write generates an unimplemented message at log level 2, subsequent accesses at level 3; field writes only log on first differing write); \"undocumented\" denotes poor or missing spec coverage and produces spec_violation logs (first read/write at level 1, remaining at level 2); \"unmapped\" excludes a register from its bank's address space; \"sticky\" preserves object value across soft resets; \"design_limitation\" indicates intentionally out-of-scope/unimplemented functionality (uses default reads/writes and is distinct from \"unimpl\"); and \"no_reset\" prevents value changes on hard or soft reset. The section then begins bank-related templates with \"function_mapped_bank.\""
            }
          ],
          "node_id": "0315",
          "summary": "Summary of main points in the partial document:\n\n- Reset callback interfaces:\n  - A generic reset callback template (implemented on any object) provides callbacks for corresponding reset events; registers and fields get this automatically.\n  - Top-level reset templates for power-on, hard, and soft resets provide standard reset behavior (poreset/hreset/sreset correspond to power_on_reset, hard_reset, soft_reset).\n\n- Templates applicable to registers and fields (general behavior):\n  - These templates can be applied to both registers and fields; most affect read or write operations.\n  - When applied to a register, read-related templates override field read implementations and return the register value (writes still propagate to fields).\n\n- Specific templates described:\n  - soft_reset_val: On soft reset, uses the soft_reset_val parameter instead of the default init_val (applies to registers/fields); related to soft_reset.\n  - ignore_write: Causes writes to be ignored; useful for making fields effectively read-only inside otherwise writable registers (alternative to read_only in some cases).\n  - read_zero: Reads always return 0 regardless of the stored value; writes are unaffected; related to read_constant.\n  - read_only: Makes the object read-only for software while allowing hardware modifications; logging behavior: first software write generates a spec_violation at log level 1, subsequent writes at level 2; fields log only when the new write differs from the old value. Note: when a register contains both read-only and writable fields, ignore_write may be preferable since software often does not care about written values."
        },
        {
          "title": "Bank related templates",
          "start_index": 101,
          "end_index": 101,
          "nodes": [
            {
              "title": "function_mapped_bank",
              "start_index": 101,
              "end_index": 102,
              "node_id": "0342",
              "summary": "- silent_unimpl: marks object functionality as unimplemented but suppresses verbose logging; reads/writes use default implementations. First software read/write to a register or first write to a field (when value changes) logs an \"unimplemented\" message at level 2; subsequent accesses log at level 3. Software reads to fields do not log. Related to unimpl and design_limitation.\n\n- undocumented: object is undocumented or poorly documented; uses default reads/writes. First software read/write emits a spec_violation at log-level 1, subsequent accesses at level 2.\n\n- unmapped: indicates a register is excluded from its containing bank's address space.\n\n- sticky: (typo shown as \"stick y\") object value is not reset on soft-reset; current value is retained.\n\n- design_limitation: functionality deliberately left out of model scope; default reads/writes used. Intended for design decisions (e.g., debug registers) rather than temporary unimplemented features. Related to unimpl and silent_unimpl.\n\n- no_reset: register or field value is unchanged on hard or soft reset.\n\n- function_mapped_bank (bank-only): marks a bank as function-mapped; parameter: function (integer). Related to function_io_memory.\n\n- function_io_memory (implement-only for io_memory): implements io_memory via function mapping\u2014transactions are routed to a bank in the same subdevice that instantiates function_mapped_bank with a matching function number. If no matching bank exists, an error is logged and a miss reported. Parameter: function (integer). Notes that function-number mapping is deprecated and PCI-standard function numbers are unrelated.\n\n- miss_pattern_bank (bank-only): handles unmapped accesses by ignoring writes and returning a specified byte value for each missed byte on reads. Parameter: miss_pattern; overriding unmapped_get customizes behavior.\n\n- map_target (connect-related): template for connect objects to target mappable objects; provides default set (assigns session variable map_target of type map_target_t *) and validate (checks SIM_new_map_target). Defines methods including read(uint64 addr, uint64 size) -> (uint64) throws (partial method list shown)."
            },
            {
              "title": "function_io_memory",
              "start_index": 102,
              "end_index": 102,
              "node_id": "0343",
              "summary": "- Describes templates and behaviors for mapping memory banks and handling IO/memory transactions in Simics.\n- function_mapped_bank: a template valid for bank objects; banks are marked with a function number parameter to be selected by function-based routing.\n- function_io_memory: an implement template (for objects named io_memory) that routes incoming memory transactions to a bank in the same (sub)device whose function number matches the transaction; logs an error and reports a miss if no match is found. Notes that function-number mapping is deprecated (legacy PCI use) and PCI function numbers are unrelated to bank function numbers.\n- Parameters common to these templates include a function integer specifying the function number.\n- miss_pattern_bank: a bank-object template that handles unmapped accesses by ignoring writes and returning a specified byte value for each unmapped read byte; advises overriding unmapped_get to customize behavior.\n- map_target (connect-related): a template for connect objects to send memory transactions to map-capable objects; provides a default set implementation that assigns a session map_target pointer and a validate implementation that checks SIM_new_map_target succeeds; defines methods such as read(addr, size) (method list truncated in the excerpt)."
            },
            {
              "title": "miss_pattern_bank",
              "start_index": 102,
              "end_index": 102,
              "node_id": "0344",
              "summary": "Summary of main points in the partial document:\n\n- function_mapped_bank\n  - Valid only in bank objects.\n  - Associated with the function_io_memory template for mapping banks by a function number.\n  - Parameter: function (integer).\n  - Related template: function_io_memory.\n\n- function_io_memory\n  - Valid only in implement objects named io_memory.\n  - Implements the io_memory interface by function-number mapping: incoming memory transactions are routed to a bank in the same (sub)device that instantiates function_mapped_bank and has a matching function number; if none exists, an error is logged and a miss is reported.\n  - Notes that mapping by function number is deprecated (still used by legacy PCI devices) and that PCI-defined function numbers are unrelated to bank function numbers.\n  - Parameter: function (integer).\n  - Related template: function_mapped_bank.\n\n- miss_pattern_bank\n  - Valid only in bank objects.\n  - Handles unmapped accesses by ignoring writes and returning a specified value for each unmapped byte on reads.\n  - Custom behavior can be achieved by overriding unmapped_get (which also customizes unmapped_read).\n  - Parameter: miss_pattern (value used for each missed byte).\n\n- map_target (connect-related template)\n  - Instantiated by connect objects to facilitate sending memory transactions to objects that can be mapped into Simics memory maps.\n  - Provides a default set implementation that stores a session variable map_target (map_target_t *) for issuing transactions to the connected object.\n  - Provides a default validate implementation that checks whether SIM_new_map_target can create a valid map target.\n  - Defines methods such as read(uint64 addr, uint64 size) -> (uint64) (description truncated)."
            }
          ],
          "node_id": "0341",
          "summary": "This partial document defines several register/object templates and their behaviors: \n- silent_unimpl: functionality is unimplemented but uses default reads/writes and minimizes log noise (first software read/write to a register emits an \u201cunimplemented\u201d message at log-level 2, subsequent accesses at level 3; software reads to fields produce no log; first field write that changes value logs at level 2, subsequent at level 3). Related templates: unimpl, design_limitation. \n- undocumented: functionality is undocumented or poorly documented, uses default reads/writes; first software read and write produce a spec_violation log at level 1, subsequent accesses at level 2. \n- unmapped: the register is excluded from the containing bank\u2019s address space. \n- sticky: object value is not changed on soft reset (preserve current value). \n- design_limitation: functionality intentionally left out of the model scope as a design decision (default reads/writes); differs from unimplemented because it is a deliberate limitation rather than an oversight; related templates: unimpl, silent_unimpl. \n- no_reset: register/field values are not changed on hard or soft reset. \nThe excerpt then begins the bank-related templates section with function_mapped_bank."
        },
        {
          "title": "Connect related templates",
          "start_index": 102,
          "end_index": 102,
          "nodes": [
            {
              "title": "map_target",
              "start_index": 102,
              "end_index": 103,
              "node_id": "0346",
              "summary": "This partial document describes several Simics template types and their behaviors, parameters, and relations:\n\n- function_mapped_bank (bank objects): Marks a bank as function-mapped and associates it with a function number (integer) used by function-based routing. Related to the function_io_memory template.\n\n- function_io_memory (implement objects named io_memory): Implements the io_memory interface by routing incoming memory transactions to a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number. If no matching bank exists, a miss is reported and an error is logged. Notes that function-number mapping is deprecated and unrelated to PCI function numbers. Parameter: function (integer). Related template: function_mapped_bank.\n\n- miss_pattern_bank (bank objects): Handles unmapped accesses by ignoring writes and returning a specified byte value for each unmapped byte on reads. Parameter: miss_pattern (byte value).\n\n- map_target (connect-related template for connect objects): Provides an easy way to send memory transactions to mappable objects via a session variable map_target of type map_target_t*. Supplies validation (using SIM_new_map_target) and convenience methods: read, read_bytes, write, write_bytes, and issue (a shorthand for SIM_issue_transaction). Methods throw exceptions on failures; read/write enforce little-endian and size limits.\n\n- signal_port (signal-related template): Implements a signal interface with saved state (boolean high). Logs spec-violation messages if raise/lower are invoked when already at that level. Methods signal_raise and signal_lower are overridable to add side effects.\n\n- signal_connect (connect-related signal template): Implements a connect with saved signal state (signal.high). On connect changes or finalization, it calls signal_lower on the old object and signal_raise on the new one when appropriate; initial creation with signal.high true triggers signal_raise in finalize. Behavior can be customized by overriding set and/or post_init. Provides set_level(uint1 high) to set signal level. Related template: signal_port."
            }
          ],
          "node_id": "0345",
          "summary": "- Describes the function_mapped_bank template: valid only in bank objects; banks instantiated from this template are recognized as function-mapped by function_io_memory and are associated with a specified integer function number (parameter: function).\n- Documents function_io_memory (implement objects named io_memory): implements the io_memory interface by mapping incoming memory transactions to a bank in the same (sub)device that instantiates function_mapped_bank with a matching function number; if no match is found, an error is logged and a miss is reported. Notes that function-number mapping is deprecated (legacy PCI use), and PCI function numbers are not the same as bank function numbers. (Parameter: function)\n- Describes miss_pattern_bank (valid only in bank objects): handles unmapped accesses by ignoring writes and returning a configured value for each unmapped read byte; customization can be done by overriding unmapped_get. (Parameter: miss_pattern)\n- Introduces the map_target connect-related template: connect objects can instantiate it to simplify sending memory transactions to objects mappable into Simics memory maps; provides a default set implementation that assigns a session variable map_target (type map_target_t *) for issuing transactions, and a validate implementation that checks SIM_new_map_target returns a valid pointer. Begins to list provided methods (e.g., read(uint64 addr, uint64 size) -> (uint64) throws)."
        },
        {
          "title": "Signal related templates",
          "start_index": 103,
          "end_index": 103,
          "nodes": [
            {
              "title": "signal_port",
              "start_index": 103,
              "end_index": 103,
              "node_id": "0348",
              "summary": "Summary of the partial document:\n\n- Memory access API: Describes methods for reading and writing bytes in a connected object:\n  - read(uint64 addr, uint64 size) -> uint64 and read_bytes(uint64 addr, uint64 size, uint8 *bytes): read up to 8 bytes (size \u2264 8), little-endian, throw exceptions on failure.\n  - write(uint64 addr, uint64 size, uint64 value) and write_bytes(uint64 addr, uint64 size, const uint8 *bytes): write up to 8 bytes, little-endian, throw exceptions on failure.\n  - issue(transaction_t *t, uint64 addr) -> (exception_type_t): a shorthand wrapper around SIM_issue_transaction used by the read/write methods; can be overridden to modify transaction behavior.\n\n- Signal-related templates (Section 5.5):\n  - signal_port: implements a signal interface with saved state (boolean high). Logs spec-violation messages if raise/lower calls contradict current state; signal_raise and signal_lower are overridable for extra side effects.\n  - signal_connect: implements a connect that holds a saved signal state (signal.high). When the connection changes while signal.high is true and the device is configured, it calls signal_lower on the old object and signal_raise on the new one; if created with signal.high true, signal_raise is invoked on the connected object during finalization. Behavior can be altered by overriding set and/or post_init. Provides set_level(uint1 high) to change level (calls raise/lower and updates signal.high).\n- Related templates: signal_port mentioned as related to signal_connect."
            },
            {
              "title": "signal_connect",
              "start_index": 103,
              "end_index": 103,
              "node_id": "0349",
              "summary": "- Describes memory access methods for a connected object: read, read_bytes, write, write_bytes. Reads/writes are little-endian, limited to at most 8 bytes for scalar access, and throw exceptions on failure.\n- Introduces an issue(transaction_t *t, uint64 addr) -> (exception_type_t) helper that wraps SIM_issue_transaction; used by the read/write methods and can be overridden to modify transactions (e.g., add atoms).\n- Begins a section on signal-related templates (5.5), detailing signal_port: a signal interface with saved boolean state (signal.high), logging of spec violations when raising/lowering an already-set/cleared signal, and overridable signal_raise/signal_lower hooks.\n- Describes signal_connect: a connect wrapper that tracks saved.signal.high, calls signal_lower on the old object and signal_raise on the new object when a connection changes while high, and calls signal_raise on the connected object during finalize if created with high true. Behavior can be customized by overriding set or post_init.\n- Documents the set_level(uint1 high) method: sets signal level by invoking signal_raise or signal_lower as appropriate and updates signal.high. Notes that signal_port is a related template."
            }
          ],
          "node_id": "0347",
          "summary": "Summary of main points in the partial document:\n\n- Memory read/write API: methods to read and write up to 8 bytes at a given 64-bit address, with little-endian byte order and exceptions thrown on failure.\n- read and read_bytes: read a value or raw bytes from the connected object into provided buffers; size must be \u22648 for scalar reads.\n- write and write_bytes: write a scalar value or raw bytes into the connected object; scalar write size must be \u22648 and uses little-endian order.\n- issue(transaction_t *t, uint64 addr): a convenience wrapper around SIM_issue_transaction used by the read/write methods; intended to be overridable to add atoms or customize transactions.\n- Signal-related templates (Section 5.5): signal_port implements a signal interface with saved boolean state (signal.high), logs spec violations when raising/lowering incorrectly, and allows overriding signal_raise/signal_lower for side effects.\n- signal_connect: implements a connection holding a signal interface and saved state; when connections change while the signal is high, it calls signal_lower on the old object and signal_raise on the new one; during finalize, an initially-high signal triggers a raise on the connected object. Behavior can be altered by overriding set or post_init; defines set_level(uint1 high) to update state and call raise/lower.\n- Notes that signal_port is a related template; the fragment also references later/library sections (e.g., \"4 Libraries and Built-ins A Messages\") not fully shown."
        }
      ],
      "node_id": "0307",
      "summary": "The partial document is from Chapter 5 \u201cStandard Templates\u201d of the Device Modeling Language (DML) reference and describes: standard templates provided in utility.dml for registers and fields; that many templates share functionality and differ mainly by name or log messages (examples: undocumented vs reserved); the use of the term \u201cobject\u201d to mean registers and fields; definitions of software vs hardware reads/writes (software via io_memory using DML read/write, hardware via Simics configuration attributes using DML get/set) and that device code can still modify registers even if hardware modification is prohibited. It also begins Section 5.1 on reset templates, noting DML has no built-in reset but provides poreset, hreset, and sreset templates to model common reset mechanisms (power-on, hard, and soft resets), explains typical reset effects (restoring registers to predefined values), and that instantiating these templates creates POWER/HRESET/SRESET ports implementing a signal interface which trigger corresponding reset methods on a rising edge."
    },
    {
      "title": "Messages",
      "start_index": 103,
      "end_index": 104,
      "nodes": [
        {
          "title": "Warning Messages",
          "start_index": 104,
          "end_index": 107,
          "node_id": "0351",
          "summary": "Appendix A, \"Messages,\" from the DML 1.4 reference manual: a catalog of dmlc diagnostics organized alphabetically with tag identifiers. A.1 lists warning messages with explanations, causes, examples and suggested remedies (including how to silence some warnings); topics include security-critical issues (unsafe use of after/send with pointers to stack data), type and representation problems (negative vs unsigned comparisons, truncation, sizeof vs sizeoftype, suspect pointer casts), logging misconfigurations, deprecated/experimental or version-compatibility issues (DML 1.2 vs 1.4, outdated AST), missing documentation/description warnings, unused-object/parameter diagnostics, duplicate checkpoint names, negative register offsets, and other common pitfalls. A.2 begins the error-message section, following the same tagged, alphabetical format (example: EERRSTMT for forced compilation error)."
        },
        {
          "title": "Error Messages",
          "start_index": 107,
          "end_index": 123,
          "node_id": "0352",
          "summary": "This partial document is a DML compiler diagnostics reference listing warnings and an extensive, alphabetized set of error messages (with tags like [WTTYPEC], [EAFTER], [ETYPE], etc.) and their explanations. Main points covered:\n\n- A few specific warnings: implicit time-value conversions for after calls, unused DML 1.2 implementations in DML 1.4 (suggesting conditional #if blocks), unused parameters/objects, and dangerous pointer-to-pointer casts with suggested mitigations.\n- Section A.2: a comprehensive catalogue of compiler errors, each named and tagged, describing causes and typical remedies. Errors cover templates and inheritance (ambiguous defaults, invalid template-qualified calls, abstract/override rules), shared vs non-shared methods, and method-call/context restrictions.\n- Many type and expression errors: unknown/invalid types or identifiers, wrong types for operators, illegal casts, non-boolean conditions, non-constant expressions, and serialization/checkpointability limits.\n- Object model and declaration errors: attribute/parameter conflicts and missing getters/setters, register/field/bit-range issues (overlap, out-of-bounds, sizes), array problems (sizes, indexing, variable-length/const rules), layout/struct/member restrictions.\n- Control-flow and syntax errors: malformed switches, missing return statements for output-argument methods, recursive inlining, uncaught exceptions, and general syntax errors.\n- Build/import and versioning errors: missing files, cyclic imports, incompatible DML/Simics API versions, and provisional feature checks.\n- Special constructs errors: illegal after/hook usages, logging/format string issues, interface/export/extern rules, and restrictions on where certain declarations may appear.\n- The entries often point to corrective actions (casts, conditional compilation, adding methods/implementations, changing declarations) and reference other document sections for details."
        }
      ],
      "node_id": "0350",
      "summary": "- API methods for memory access: read, read_bytes, write, write_bytes. Each reads/writes a specified size at a given addr in the connected object, with size limited to 8 bytes for scalar read/write, little-endian byte order, and exceptions thrown on failures.\n- issue(transaction_t *t, uint64 addr) helper: a shorthand wrapper for SIM_issue_transaction used by the read/write methods; can be overridden to modify transactions while retaining simple read/write calls.\n- signal-related templates:\n  - signal_port: implements a signal interface with saved boolean state (signal.high). Logs a level-2 spec-violation if the signal is raised or lowered when already in that state. signal_raise and signal_lower can be overridden for side effects.\n  - signal_connect: implements a connect with saved signal state; changing the connect or finalizing device creation triggers calls to signal_lower/signal_raise on old/new objects when signal.high is true. Behavior can be changed by overriding set or post_init. Provides set_level(uint1 high) to set the signal by calling signal_raise or signal_lower and updating signal.high.\n- Related templates: signal_port referenced under signal_connect.\n- Diagnostics section: lists warnings and error messages from dmlc with clarifications. Examples shown include tags like [WSYSTEMC], [WWRNSTMT], [WREDUNDANTLEVEL], and specific warnings such as:\n  - Unsafe use of immediate 'after' when callback arguments point to stack-allocated data ([WIMMAFTER]).\n  - Unsafe use of hook send with stack-allocated data pointers ([WHOOKSEND]) and guidance to use send_now or wrapper methods.\n  - Warning about comparing negative constants to unsigned integers having constant (likely unintended) results ([WNEGCONSTCOMP])."
    },
    {
      "title": "B Provisional language features",
      "start_index": 124,
      "end_index": 124,
      "nodes": [
        {
          "title": "B.1 List of stable provisional features",
          "start_index": 124,
          "end_index": 124,
          "nodes": [
            {
              "title": "explicit_param_decls",
              "start_index": 124,
              "end_index": 125,
              "node_id": "0355",
              "summary": "Summary of the partial document:\n- Explains DML provisional language features: temporary compiler extensions enabled per-file by adding \"provisional feature_name, other_feature_name;\" immediately after \"dml 1.4;\" and used when a feature isn\u2019t ready for full language inclusion (e.g., design not finalized or backward-incompatible).\n- Distinguishes two provisional flavours:\n  - Stable provisional features: design is proven and expected to remain relatively stable; major incompatible changes are handled by creating a new provisional version and keeping both; suitable for production use.\n  - Unstable provisional features: likely to change incompatibly, intended for early evaluation by modelers and not recommended for production.\n- Lists stable provisional features present in the fragment:\n  - explicit_param_decls: extends parameter syntax to differentiate declaring a new parameter versus overriding an existing one, introduces explicit forms (typed and untyped) that cause errors if used as overrides or if plain assignment is used without an existing parameter, and allows a paired declaration (param NAME;) to mark an assignment as potentially either new or override; enabling affects only that file.\n  - simics_util_vect: adds a vect type based on the Simics C API VECT macro as an interim vector mechanism, shows syntax (BASETYPE vect), warns that vect types typically must be typedef:ed due to C macro expansion producing incompatible struct definitions if repeated, notes typeof limitations, exposes many VECT-related C macros to DML, and maps DML indexing to VGET/VSET (example provided)."
            },
            {
              "title": "simics_util_vect",
              "start_index": 125,
              "end_index": 126,
              "node_id": "0356",
              "summary": "- Parameter declaration and override rules in DMLC:\n  - Shows forms: param NAME; param NAME = value; and param NAME default value;, and notes that param NAME:default value; is shorthand for using a separate param NAME; plus param NAME default value;.\n  - Explains that using these forms to try to override an existing parameter (when the declaration was not intended as an override) will produce an error, and conversely a plain param NAME = value; or param NAME default value; that does not override a pre-existing parameter is also an error.\n  - Describes a workaround for cases when it is unknown whether a declaration is an override: include both param NAME; and param NAME = value; (or param NAME default value;) in the same scope/rank to mark the assignment as allowed to be either a new parameter or an override.\n  - Notes that enabling the explicit_param_decls feature affects only the parameter definitions in the file where it is enabled.\n\n- simics_util_vect feature (Vect support in DML):\n  - Enables a vect type based on the Simics C API VECT macro (simics/util/vect.h), provided as an interim, somewhat inconsistent wrapper pending a cleaner vector mechanism.\n  - Syntax: BASETYPE vect (e.g., typedef int vect int_vect_t;) to define a vector-of-type typedef.\n  - Caveats:\n    - vect types usually need to be typedef:ed before use because VECT(int) expands to a struct; repeating the expansion yields incompatible types, which breaks features like typeof unless typedef:ed.\n    - The wrapper behaves inconsistently and is a temporary solution.\n  - Importing internal.dml exposes many underlying C macros (VINIT, VRESIZE, VADD, VREMOVE, VLEN, VCOPY, etc.) to DML.\n  - DML supports native indexing syntax for vects, translated to VGET/VSET for reads/writes (example provided showing v[0] and VLEN usage).\n  - Enabling simics_util_vect in a file affects only vect declarations in that file; disabling it makes vect usage an error unless the experimental_vect compatibility feature is enabled.\n\n- Miscellaneous:\n  - The document signals planned future improvements (a cleaner vector mechanism) and contains a heading or pointer toward managing deprecated language features."
            }
          ],
          "node_id": "0354",
          "summary": "The partial document explains DML\u2019s provisional language features: how to enable them per file (with provisional feature_name; after dml 1.4;), and the two flavours\u2014stable provisionals (mature, safe for production, tracked by versioned names if changed) and unstable provisionals (experimental, subject to breaking changes, intended for evaluation). It then begins a list of stable provisional features and documents explicit_param_decls: a syntax extension that distinguishes declaring a new parameter from overriding an existing one (helping catch misspelled overrides), and introduces new shorthand forms for typed and untyped parameter declarations (e.g., variants of param NAME: TYPE = value; param NAME: TYPE default value; and param NAME := value;), with further details truncated."
        }
      ],
      "node_id": "0353",
      "summary": "- Discusses provisional language features in the DML compiler and how they are enabled on a per-file basis (using provisional feature_name, other_feature_name; immediately after dml 1.4;).\n- Defines two flavours of provisional features:\n  - Stable provisional: proven designs expected to remain fairly stable; may change details between versions but incompatible changes produce a new provisional name/version kept in parallel; suitable for production use.\n  - Unstable provisional: likely to undergo significant incompatible changes, intended for early evaluation by a small team and not recommended for production without coordination with the DML team.\n- Begins a list of stable provisional features and documents explicit_param_decls:\n  - Extends parameter-definition syntax to distinguish declaring a new parameter vs overriding an existing one (including providing definitions for abstract parameters), enabling compile-time detection of misspelled overrides.\n  - Introduces new shorthand forms for typed parameters (e.g., param NAME: TYPE = value; and param NAME: TYPE default value; as shorthands for separate declaration + value forms) and a new form for untyped parameters (param NAME := value;). The text cuts off while describing the untyped case."
    },
    {
      "title": "C Managing deprecated language features",
      "start_index": 127,
      "end_index": 127,
      "nodes": [
        {
          "title": "C.1 Deprecation mechanisms",
          "start_index": 127,
          "end_index": 128,
          "node_id": "0358",
          "summary": "Overview of Appendix C (Managing deprecated language features)\n\n- Purpose: explains how DML handles language and API deprecations and provides mechanisms to ease migration for large DML code bases and their end-users.\n\n- Types of deprecations: \n  - Removed/renamed library symbols (easy to fix via compile errors).\n  - Changed semantics of language constructs or APIs (can alter model behavior without errors).\n  - Changes to how compiled models appear in Simics (affects model end-users and may require synchronized migration).\n\n- Primary deprecation mechanism: Simics API versions.\n  - Each deprecated DML feature is tied to a Simics API version; Simics major upgrades drop features from previous API versions.\n  - Migration workflow (from Simics N to N+1): \n    1. While on N, update modules to API N (can be done one-by-one).\n    2. Upgrade Simics to N+1.\n    3. Update modules to API N+1 progressively; Simics N+1 still supports API N.\n\n- Compiler-level controls:\n  - --api-version (or make/CMake variables SIMICS_API_VERSION, SIMICS_API/MODULE_SIMICS_API) to select API version.\n  - --no-compat=tag to disable individual legacy features; each tag also creates a global boolean parameter named _compat_tag that DML programs can check.\n  - Uses: allow gradual migration by disabling features one at a time; proactively disable legacy features to avoid their use in new code; reduce redundancy and potential performance impact.\n\n- Concrete deprecated features (those removed when compiling with --simics-api >=7; individually disable-able when using older APIs):\n  - dml12_goto: preserves the deprecated goto statement; recommended migration is replacing goto/label with throw/catch, but goto can be disabled separately for phased migration.\n  - dml12_inline: in DML 1.2, inline could fold constant typed parameters as constants; this improves compile time but has unintuitive semantics.\n  - dml12_int: affects many integer arithmetic semantics. When enabled, integer ops were translated directly to C (leading to differences for odd-sized uintNN types). Disabling it causes some syntactic/semantic changes (e.g., assert 0 -> assert false; while (1) -> while (true)), changes to representation/truncation of non-standard integer sizes (e.g., uint5), and differences in permissible values for int1 (old code comparing int1 to 1 may break since new semantics restrict int1 values).\n\n- Overall guidance: use API-versioning and selective disabling to perform smooth, controlled migrations; avoid relying on legacy features in new code to ease future upgrades."
        },
        {
          "title": "C.2 Controlling deprecation on the DML command-line",
          "start_index": 128,
          "end_index": 128,
          "node_id": "0359",
          "summary": "Summary of partial document:\n\n- Rationale for deprecation: avoiding older features in favor of newer replacements keeps the code base cleaner, more consistent, and can reduce model bloat and performance costs.\n\n- How to control deprecation via DMLC/Simics build:\n  - DMLC supports an --api-version flag to select the API version for a model.\n  - When using Simics build systems, the API version is set via SIMICS_API_VERSION (make) or SIMICS_API / MODULE_SIMICS_API (CMake).\n  - The --no-compat=tag compiler flag disables a specific legacy feature. Each tag also creates a global boolean parameter named _compat_tag that DML programs can check.\n\n- List of deprecated compatibility features (removed when compiling with Simics API 7+), with examples and effects:\n  - dml12_goto: preserves the legacy goto statement; goto is deprecated and most constructs can be refactored to throw/catch, though this may be nontrivial.\n  - dml12_inline: when enabled, inlines constant arguments in DML 1.2 methods as constants \u2014 can speed compilation but has unintuitive semantics.\n  - dml12_int: affects many integer-arithmetic semantics by translating integer ops directly to C (without modern DML adjustments). Disabling this changes required code patterns (e.g., assert 0 \u2192 assert false; while (1) \u2192 while (true)). Other effects include representation of odd-sized integer types as larger native C types (possibly allowing out-of-range values) and changes in the semantics of very small integer types (e.g., int1 behavior differs between versions)."
        },
        {
          "title": "C.3 List of deprecated features",
          "start_index": 128,
          "end_index": 129,
          "nodes": [
            {
              "title": "C.3.1 Features available up to and including --simics-api=6",
              "start_index": 129,
              "end_index": 130,
              "node_id": "0361",
              "summary": "- Suggests replacing occurrences of int1 with the uint1 type where appropriate (grep pattern provided).\n- Describes changes in operation semantics between traditional DML (inheriting C\u2019s undefined behaviour) and modern DML: modern DML makes previously-undefined cases well-defined (e.g., negative shift or division by zero cause a critical error; overly large shift operands or signed-shift overflow cause truncation).\n- Explains comparison operator semantic differences: traditional DML follows C-style rules, while modern DML compares values as integers\u2014affecting signed/unsigned comparisons (example: -1 vs 0xffffffffffffffff).\n- Notes that the dml12_int compatibility feature only applies to DML 1.2 files; importing a DML 1.2 file into a DML 1.4 context still uses modern semantics for operations.\n- Documents the dml12_misc compatibility feature, which re-enables many DML 1.2 quirks (allowed constructs include sizeof(typename), typeof on non-lvalues, select over vect types, passing string literals to non-const char*, use of '-' in c_name, overriding interface type via c_name, loggroup name exposure in generated C, applying & to non-lvalues, extern without type, anonymous banks, instantiation of non-existing templates from unused templates, and reuse of the same symbol for top-level object and top-level symbol).\n- Describes io_memory compatibility: transaction was introduced in Simics 6, but enabling this compatibility makes use_io_memory default to true so banks implement io_memory by default (preserving older behavior).\n- Documents shared_logs_on_device compatibility: preserves a long-standing bug so that log statements in shared methods always log on the device object rather than the nearest enclosing configuration object.\n- Describes suppress_WLOGMIXUP: suppresses the WLOGMIXUP warning by default for Simics API versions below 7 to avoid many warnings; explains how --no-compat=suppress_WLOGMIXUP and --warn=WLOGMIXUP interact and the difference in whether the warning can subsequently be suppressed.\n- Covers compatibility features retained up to and including --simics-api=7 (removed in API 8+): broken_conditional_is (silences errors instantiating templates inside #if blocks) and broken_unused_types (suppresses errors for unused extern-declared types), both preserving historical bugs."
            },
            {
              "title": "C.3.2 Features available up to and including --simics-api=7",
              "start_index": 130,
              "end_index": 132,
              "node_id": "0362",
              "summary": "This partial document lists and explains compatibility features in the DMLC/Simics toolchain, focused on preserving legacy or buggy behaviors and how to opt in/out of them. Main points covered:\n\n- General control: features tied to Simics API versions (notably differences below/above API 7 vs API 8+) and how to disable individual compat features with --no-compat=TAG; interaction with warning flags (e.g., --warn=WLOGMIXUP vs --no-compat=suppress_WLOGMIXUP).\n- suppress_WLOGMIXUP: suppresses the WLOGMIXUP warning by default for API < 7, rationale, and differences between using --no-compat and --warn.\n- A set of features available up to and including --simics-api=7 that reproduce older/buggy behavior so older models still compile:\n  - broken_conditional_is: suppresses template instantiation errors inside #if blocks.\n  - broken_unused_types: ignores errors on extern-declared but unused types.\n  - experimental_vect: permits vect syntax without the provisional feature enabled (and controls warnings).\n  - function_in_extern_struct: allows nonstandard omission of * for function-pointer members in extern structs.\n  - legacy_attributes: registers attributes with the old API (affects dictionary attribute support and migration guidance to list-based representations).\n  - lenient_typechecking: makes DMLC\u2019s type checking lax compared to C/GCC, with notes on pointer constness and extern:d macros when disabling.\n  - meaningless_log_levels: relaxes constraints on log level integers for warning/error/critical kinds.\n  - no_method_index_asserts: disables implicit bounds assertions for methods on object arrays (migration warning that disablement reveals real bugs).\n  - optional_version_statement: makes the dml version line optional (with warnings) and accepts dml 1.3; as deprecated alias.\n  - port_proxy_attrs and port_proxy_ifaces: recreate older Simics 5 behavior by creating proxy configuration attributes and interface ports for banks/ports (with caveats about which proxies are created).\n  - warning_statement: re-enables the deprecated _warning statement (removed in API 8+).\n- Migration guidance woven throughout: which incompatibilities to fix (e.g., change function-pointer syntax, update dictionary attributes, tighten type signatures) and warnings that some compat features mask real bugs that should be addressed when moving to newer Simics API versions."
            }
          ],
          "node_id": "0360",
          "summary": "Partial document describes how Simics/DMLC controls deprecation and compatibility via command-line flags (--api-version, SIMICS_API_VERSION/SIMICS_API, and --no-compat=tag), and that each compatibility tag also exposes a global boolean parameter named _compat_<tag>. It then lists deprecated compatibility features removed when compiling with Simics API 7+ (available for older API versions via --no-compat=TAG), and explains the purpose and effects of each tag:\n\n- dml12_goto: preserves legacy goto semantics; recommends rewriting goto-based control flow to throw/catch.\n- dml12_inline: controls inlining of constant arguments for DML 1.2 methods, affecting compilation behavior and semantics.\n- dml12_int: preserves many legacy integer semantics (translation into C, representation of odd-sized integer types, comparisons, undefined C behaviors vs modern DML defined behavior); notes required source changes (e.g., assert 0 \u2192 assert false) and that it only applies to DML 1.2 files.\n- dml12_misc: preserves assorted DML 1.2 quirks (sizeof(typename), typeof on non-lvalues, select over vect types, passing string literals to char* params, special c_name uses, loggroup name behavior, & on non-lvalues, typeless externs, anonymous banks, template instantiation quirks, reuse of symbols across $ and non-$ scopes, etc.).\n- io_memory: compatibility for older io_memory-based banks vs the newer transaction interface (use_io_memory default behavior).\n- shared_logs_on_device: preserves legacy bug/behavior where log statements in shared methods always log on the device object rather than the enclosing configuration.\n\n(Partial fragment ends mid-explanation.)"
        }
      ],
      "node_id": "0357",
      "summary": "This partial document is an appendix on managing deprecated DML language features, aimed at helping users migrate large code bases. It identifies three kinds of deprecations\u2014removed/renamed library symbols, changes in construct/API semantics that alter behavior without errors, and changes to how compiled models appear in Simics that affect end-users\u2014and notes the need to coordinate migrations affecting end-users. The primary deprecation mechanism is Simics API versions: features are associated with an API version and are removed when moving to a new Simics major version. The text outlines a recommended migration sequence (update modules to the current API while on the current Simics version, upgrade Simics, then migrate modules to the new API one by one) and emphasizes that newer Simics versions continue to support older API versions to ease transition. It also describes compiler flags that can selectively disable deprecated features to allow gradual migration and to prevent new code from using legacy features."
    },
    {
      "title": "D Changes from DML 1.2 to DML 1.4",
      "start_index": 133,
      "end_index": 133,
      "nodes": [
        {
          "title": "D.1 Toy DML 1.2 device",
          "start_index": 133,
          "end_index": 134,
          "node_id": "0364",
          "summary": "- Section header indicating changes from DML 1.2 to DML 1.4 and that 1.4 is largely similar but has key differences to be highlighted.\n- Table of contents-like entries: D.1 Toy DML 1.2 device, C Managing deprecated language features, D.4 Porting DML 1.2 to DML 1.4.\n- A toy DML 1.2 code example illustrating core language constructs and idioms used in the comparison:\n  - device and method definitions, including return parameters and the nothrow qualifier.\n  - exception use with throw inside methods.\n  - bank/register declarations with arrayed registers, explicit size and base address arithmetic ($i * 4), and an is read handler.\n  - register-scoped method after_read(memop) showing local variables and an inline call to another method with parameter passing and multi-value returns (inline $foo(2) -> (b, $c)).\n  - field and data declarations (e.g., field f[7:0]; data bool c).\n  - templates with parameters and default/value syntax (template t1 parameter p default 1; template t2 parameter p = 2).\n  - attribute declaration combining templates (attribute a is (t1, t2)) with parameter settings (allocate_type = \"int32\") and attribute methods (after_set) that call device methods, use $this, and assign template parameters to attributes.\n- Implicit focus areas for the rest of the section: deprecated features handling and practical porting guidance from DML 1.2 to DML 1.4 using the example as a basis."
        },
        {
          "title": "D.2 The corresponding DML 1.4 device",
          "start_index": 135,
          "end_index": 136,
          "node_id": "0365",
          "summary": "- Source: DML 1.4 device-modeling code snippet illustrating language constructs.\n- Top-level constructs: device declaration, bank and register definitions, templates, and attributes.\n- Inline function example: foo(inline a) returns a tuple (int, bool); declares local variables, assigns values, uses a conditional (#if) to set a boolean, and returns a tuple.\n- Exception example: method bar(int a) throws; demonstrates throwing on a condition.\n- Bank/register: bank b contains a register array r[i < 20] with size and computed base address (0x0000 + i * 4), declared as is read_register (a register method).\n- Register method: read_register(uint64 enabled_bytes, void *aux) -> (uint64) shows use of default(enabled_bytes, aux), local variables, tuple unpacking assignment (b, c) = foo(2), and returning a value.\n- Register internals: a field f with bit range annotation @ [7:0] and a session-scoped boolean c.\n- Templates: t1 declares a parameter p with default 1; t2 inherits (is t1) and overrides/sets param p = 2, showing template inheritance and parameterization.\n- Attribute: attribute a is composed of types (int64_attr, t1, t2) and defines a method set(attr_value_t value) throws that calls default(value) and assigns this.val = p, illustrating attribute methods, default handling, and use of template parameter within attribute logic."
        },
        {
          "title": "D.3 Key Differences",
          "start_index": 136,
          "end_index": 138,
          "node_id": "0366",
          "summary": "- Example DML 1.4 fragment showing:\n  - File header \u201cdml 1.4;\u201d\n  - An inline method foo with inline parameter, local variables, compile-time #if, and explicit return of a tuple (int,bool)\n  - A method bar declared with throws\n  - A bank with a register array r[i < 20] at computed addresses, an overridden read_register method that calls default(...), a field with bit-range, and a session bool c\n  - Templates t1 and t2 demonstrating parameter defaults and overrides\n  - An attribute a composed from int64_attr and templates, with a set method calling default and assigning this.val = p\n\n- Key language changes from DML 1.2 to DML 1.4 highlighted:\n  - The file version declaration (dml 1.4;) must be the first declaration.\n  - Inline is now an attribute of the method and of specific arguments.\n  - Return values are no longer named in method declarations; return types only, and returns must be explicit.\n  - Formerly implicit return variables must now be declared as local variables.\n  - Compile-time conditionals use #if(...) for constant evaluation.\n  - Methods that may throw require the throws annotation.\n  - Object/array register syntax changed to explicit index: register r[i < size] ...\n  - Removal of the $ prefix on variables (affects variable scope).\n  - Builtin API changes: e.g., after_read replaced by overriding read_register and calling default(...) to implement post-read behavior.\n  - Field bit-range syntax requires an @ before the range: field f @ [7:0];\n  - Data declarations replaced by session declarations (e.g., session bool c).\n  - Template parameter override resolution is stricter and follows template hierarchy rather than picking the lone non-default.\n  - Attribute lifecycle methods: after_set replaced by overriding set and calling default(value).\n  - Registers, fields, and attributes are no longer proper values; access their .val session variable or use get/set methods.\n\n- Porting notes:\n  - Section headings indicate guidance for porting DML 1.2 to DML 1.4 and that a port-dml script handles many language differences."
        },
        {
          "title": "D.4 Porting DML 1.2 to DML 1.4",
          "start_index": 138,
          "end_index": 138,
          "node_id": "0367",
          "summary": "Summary of main points in the partial document:\n\n- Variable naming/scope: The $ prefix on variables has been removed; see backward incompatible changes for resulting variable scope implications.\n- Builtin API change (read logic): The after_read hook was removed; implementations must now override read_register(enabled_bytes, aux), call its default(enabled_bytes, aux) and then perform the after-read logic.\n- Field declaration syntax: Field declarations now require an @ before the bit-range (e.g., field f @ [7:0];).\n- Data \u2192 session: Data declarations were replaced by session declarations (e.g., session bool c;).\n- Template parameter override semantics: Parameter override behavior is stricter\u2014when multiple declarations conflict, DML determines overrides via the template hierarchy rather than picking a single non-default declaration.\n- Attribute API change (set logic): The after_set hook was removed; attribute implementations must override set(attr_value_t value) and call default(value) to perform default behavior before/after custom logic.\n- Registers/fields/attributes value model: Registers, fields, and attributes are no longer \u201cproper values\u201d in DML 1.4; code must access their .val session variable or use their get/set methods.\n- Migration pointers: Sections D.4 and D.5 reference porting DML 1.2 to 1.4 and language differences handled by the port-dml script."
        },
        {
          "title": "D.5 Language differences handled by the port-dml script",
          "start_index": 138,
          "end_index": 138,
          "node_id": "0368",
          "summary": "Summary of main points in the partial document:\n\n- Removal of the $ prefix on variables; see backward-incompatible changes for variable scope implications.\n- Builtin API changed: after_read is removed \u2014 override read_register(uint64 enabled_bytes, void *aux) and call its default implementation, then implement the after-read logic.\n- Field declaration syntax changed: bit ranges must be preceded by an @ (e.g., field f @ [7:0];).\n- Data declarations renamed: use session declarations (e.g., session bool c;).\n- Template parameter override semantics tightened: when multiple parameter declarations conflict, DML inspects the template hierarchy to determine overrides rather than picking the sole non-default.\n- Attribute API changed: after_set removed \u2014 override set(attr_value_t value) and call default(value) to preserve prior behavior.\n- Registers, fields, and attributes are no longer direct values in DML 1.4; access their session variable .val or use get/set methods.\n- The document points to porting guidance (D.4 Porting DML 1.2 to DML 1.4) and a port-dml script that handles language differences (D.5)."
        },
        {
          "title": "D.6 Backward incompatible changes, not automatically converted",
          "start_index": 139,
          "end_index": 139,
          "node_id": "0369",
          "summary": "Section headings indicating guidance on migration and compatibility: a list of backward-incompatible changes that are not automatically converted (requiring manual fixes), strategies for managing deprecated language features, and a porting guide specifically for upgrading DML from version 1.2 to 1.4."
        }
      ],
      "node_id": "0363",
      "summary": "Section D outlines changes from DML 1.2 to DML 1.4, noting that the new version is largely similar in syntax and semantics but includes important differences. It indicates the manual will highlight those key differences, present a toy DML 1.2 device example, discuss managing deprecated language features, and provide guidance for porting code from DML 1.2 to DML 1.4. The excerpt is from the Device Modeling Language 1.4 Reference Manual."
    },
    {
      "title": "E Formal Grammar",
      "start_index": 140,
      "end_index": 151,
      "node_id": "0370",
      "summary": "Partial grammar for the Device Modeling Language (DML) 1.4. Main points covered:\n\n- Overall structure: top-level production (dml) decomposes into optional provisional/device/bitorder declarations followed by a sequence of device_statements and object_statements.\n\n- Top-level and module constructs: templates, headers/footers, loggroup, constant/extern/typedef/import declarations, export, and module-level if/else/conditional constructs.\n\n- Device/object kinds: productions for device, register, field, connect, interface, attribute, bank, event, group, port, implement, subdevice, session/data/saved declarations, and hooks.\n\n- Object specification: object_spec/object_statements/object_statement_or_typedparam, with support for optional descriptions, braced statement blocks, arrays, sizespec/offsetspec, bitrange annotations, and istemplate lists.\n\n- Methods and templates: method and shared_method syntax (including qualifiers like independent, startup, memoized), inline methods, method parameter forms (typed/untyped, in/out/throws), shared hooks, template statements and instantiation forms.\n\n- Declarations and type system: cdecl and named_cdecl grammar, basetypes (typeident, struct, layout, bitfields, typeof, sequence, hook), pointers/vectors/const, function declarators, typedefs and extern typedefs, layout and struct declarations.\n\n- Bitfields and bitranges: bitfields grammar with integer sizes and per-declaration bit ranges.\n\n- Arrays, initializers and designated initializers: array forms, array_list/arraydef, initializer, single_initializer, single_initializer_list, tuple and designated struct initializers.\n\n- Expressions and literals: full expression grammar including binary/unary operators, ternary, casts, sizeof, new, indexing, member access (., ->), defined/stringify, ++/--, various literal forms (integer/hex/binary/char/float/string, utf8), composed/bracketed string literals, sizeoftype/typeops.\n\n- Statements and control flow: compound statements, declarations/local/static/saved, assignment and assignops, if/else (including nested preprocessor-like hashif), while/do/for (pre/post forms), switch/case/cond-case, break/continue/goto/return/throw/delete, try/catch, after/timer-style statements, foreach/#foreach, and preprocessor-style constructs (#if/#else/#select).\n\n- Logging, errors and warnings: log statements with kinds/levels/args, error and warning statements, error_stmt forms with optional messages.\n\n- Miscellaneous: hook declarations, identifier token set (list of keywords and identifiers), param/param specs, size/offset/bitorder handling, and a trailing note referencing backward-incompatible changes (D.6)."
    }
  ]
}